--- PROJECT STRUCTURE SUMMARY ---
ðŸ“‚ lib/
    ðŸ“„ main.dart
            ðŸ“‚ screens/
                ðŸ“„ results_screen.dart
                ðŸ“„ test_history_screen.dart
            ðŸ“‚ widgets/
                ðŸ“„ attempt_display_card.dart
            ðŸ“‚ screens/
                ðŸ“„ auth_page.dart
                ðŸ“„ auth_wrapper.dart
                ðŸ“„ login_screen.dart
                ðŸ“„ onboarding_screen.dart
                ðŸ“„ register_screen.dart
            ðŸ“‚ widgets/
                ðŸ“„ question_preview_card.dart
            ðŸ“‚ screens/
                ðŸ“„ home_screen.dart
            ðŸ“‚ widgets/
                ðŸ“„ student_assignments_list.dart
            ðŸ“‚ screens/
                ðŸ“„ teacher_curation_screen.dart
                ðŸ“„ teacher_filter_screen.dart
            ðŸ“‚ screens/
                ðŸ“„ custom_test_history_screen.dart
                ðŸ“„ syllabus_screen.dart
            ðŸ“‚ screens/
                ðŸ“„ enter_code_screen.dart
                ðŸ“„ test_preview_screen.dart
                ðŸ“„ test_screen.dart
    ðŸ“‚ models/
        ðŸ“„ attempt_item_model.dart
        ðŸ“„ attempt_model.dart
        ðŸ“„ custom_test_model.dart
        ðŸ“„ nta_test_models.dart
        ðŸ“„ question_model.dart
        ðŸ“„ test_enums.dart
        ðŸ“„ test_model.dart
        ðŸ“„ test_result.dart
        ðŸ“„ user_model.dart
    ðŸ“‚ services/
        ðŸ“„ auth_service.dart
        ðŸ“„ custom_test_service.dart
        ðŸ“„ onboarding_service.dart
        ðŸ“„ teacher_service.dart
        ðŸ“„ test_orchestration_service.dart
        ðŸ“„ test_service.dart
    ðŸ“‚ widgets/
        ðŸ“„ expandable_image.dart
        ðŸ“„ question_input_widget.dart
        ðŸ“„ question_palette.dart
        ðŸ“„ solution_detail_sheet.dart
        ðŸ“„ test_configuration_bottom_sheet.dart

Total Source Files: 39
--------------------------------------------------
--- FILE CONTENTS ---

================================================================================
FILE: pubspec.yaml
================================================================================
name: study_smart_qc
description: "A new Flutter project."
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.10.4



dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^1.0.8
  firebase_core: ^4.3.0
  cloud_firestore: ^6.1.1
  firebase_auth: ^6.1.3
  google_sign_in: 6.2.1
  fl_chart: ^0.68.0
  intl: ^0.19.0 # Added for date formatting
  provider: ^6.1.5+1

dev_dependencies:
  flutter_test:
    sdk: flutter

  flutter_lints: ^6.0.0
  flutter_native_splash: "^2.3.10"
  flutter_launcher_icons: "^0.13.1"

flutter_native_splash:
  color: "#FFFFFF" # Background color
  image: assets/splash_bg.png
  android_12:
    image: assets/splash_bg.png

flutter_launcher_icons:
  android: "launcher_icon"
  ios: true
  image_path: "assets/app_icon.png"
  adaptive_icon_background: "#FFFFFF" # Change to your brand color

flutter:
  uses-material-design: true

  assets:
    - assets/google_logo.png
    - assets/app_icon.png
    - assets/splash_bg.png

================================================================================
FILE: ios/Runner/Info.plist
================================================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>CFBundleDevelopmentRegion</key>
		<string>$(DEVELOPMENT_LANGUAGE)</string>
		<key>CFBundleDisplayName</key>
		<string>Study Smart Qc</string>
		<key>CFBundleExecutable</key>
		<string>$(EXECUTABLE_NAME)</string>
		<key>CFBundleIdentifier</key>
		<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
		<key>CFBundleInfoDictionaryVersion</key>
		<string>6.0</string>
		<key>CFBundleName</key>
		<string>study_smart_qc</string>
		<key>CFBundlePackageType</key>
		<string>APPL</string>
		<key>CFBundleShortVersionString</key>
		<string>$(FLUTTER_BUILD_NAME)</string>
		<key>CFBundleSignature</key>
		<string>????</string>
		<key>CFBundleVersion</key>
		<string>$(FLUTTER_BUILD_NUMBER)</string>
		<key>LSRequiresIPhoneOS</key>
		<true/>
		<key>UILaunchStoryboardName</key>
		<string>LaunchScreen</string>
		<key>UIMainStoryboardFile</key>
		<string>Main</string>
		<key>UISupportedInterfaceOrientations</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>UISupportedInterfaceOrientations~ipad</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationPortraitUpsideDown</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>CADisableMinimumFrameDurationOnPhone</key>
		<true/>
		<key>UIApplicationSupportsIndirectInputEvents</key>
		<true/>
		<key>UIStatusBarHidden</key>
		<false/>
	</dict>
</plist>


================================================================================
FILE: lib/main.dart
================================================================================
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/auth/screens/auth_page.dart';
import 'package:study_smart_qc/features/auth/screens/auth_wrapper.dart'; // NEW IMPORT
import 'package:study_smart_qc/services/auth_service.dart';
import 'firebase_options.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'StudySmart',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: StreamBuilder<User?>(
        stream: AuthService().userStream, // Listens to auth state changes
        builder: (context, snapshot) {
          // 1. Loading State
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Scaffold(
              body: Center(child: CircularProgressIndicator()),
            );
          }

          // 2. Logged In -> Hand off to AuthWrapper
          // The wrapper will check the database to decide between Home vs Onboarding
          if (snapshot.hasData && snapshot.data != null) {
            return AuthWrapper(firebaseUser: snapshot.data!);
          }

          // 3. Not Logged In -> Show Login/Register Page
          return const AuthPage();
        },
      ),
    );
  }
}

================================================================================
FILE: lib/features/analytics/screens/results_screen.dart
================================================================================
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/widgets/solution_detail_sheet.dart';

class ResultsScreen extends StatefulWidget {
  final TestResult result;

  const ResultsScreen({super.key, required this.result});

  @override
  State<ResultsScreen> createState() => _ResultsScreenState();
}

class _ResultsScreenState extends State<ResultsScreen> {
  int correctCount = 0;
  int incorrectCount = 0;
  int unattemptedCount = 0;

  int marksObtained = 0;
  double accuracy = 0.0;
  double attemptPercentage = 0.0;

  @override
  void initState() {
    super.initState();
    _calculateResults();
  }

  void _calculateResults() {
    int tempCorrect = 0;
    int tempIncorrect = 0;
    int tempSkipped = 0;

    // Prefer using the detailed 'responses' map if available
    if (widget.result.responses.isNotEmpty) {
      widget.result.responses.forEach((key, response) {
        switch (response.status) {
          case 'CORRECT':
            tempCorrect++;
            break;
          case 'INCORRECT':
            tempIncorrect++;
            break;
          case 'REVIEW':
          // "Marked for Review" without answer counts as SKIPPED
            tempSkipped++;
            break;
          default: // SKIPPED
            tempSkipped++;
            break;
        }
      });
      // Adjust for questions missing from responses map (pure skips)
      int totalTracked = tempCorrect + tempIncorrect + tempSkipped;
      if (totalTracked < widget.result.questions.length) {
        tempSkipped += (widget.result.questions.length - totalTracked);
      }
    } else {
      // Fallback Logic (if responses map is empty)
      widget.result.answerStates.forEach((index, state) {
        if (state.status == AnswerStatus.answered || state.status == AnswerStatus.answeredAndMarked) {
          final question = widget.result.questions[index];
          final userAnswer = state.userAnswer;
          if (userAnswer != null && userAnswer.trim().toLowerCase() == question.correctAnswer.trim().toLowerCase()) {
            tempCorrect++;
          } else {
            tempIncorrect++;
          }
        } else {
          // Not Visited, Not Answered, or Marked For Review (without answer) -> Skipped
          tempSkipped++;
        }
      });
    }

    setState(() {
      correctCount = tempCorrect;
      incorrectCount = tempIncorrect;
      unattemptedCount = tempSkipped;

      final totalAttempted = correctCount + incorrectCount;

      marksObtained = (correctCount * 4) - (incorrectCount * 1);
      accuracy = (totalAttempted > 0) ? (correctCount / totalAttempted) * 100 : 0.0;
      attemptPercentage = (widget.result.questions.isNotEmpty)
          ? (totalAttempted / widget.result.questions.length) * 100
          : 0.0;
    });
  }

  void _showSolutionSheet(int initialIndex) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        return Container(
          height: MediaQuery.of(context).size.height * 0.9,
          child: SolutionDetailSheet(
            result: widget.result,
            initialIndex: initialIndex,
          ),
        );
      },
    );
  }

  String get _formattedTimeTaken {
    final minutes = widget.result.timeTaken.inMinutes.toString().padLeft(2, '0');
    final seconds = (widget.result.timeTaken.inSeconds % 60).toString().padLeft(2, '0');
    return '$minutes:$seconds';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Test Analysis'),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.of(context).popUntil((route) => route.isFirst),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _buildScoreCard(),
            const SizedBox(height: 20),
            _buildStatsRow(),
            const SizedBox(height: 20),
            _buildVisualAnalysis(),
            const SizedBox(height: 20),
            _buildReviewSolutionsGrid(),
          ],
        ),
      ),
    );
  }

  Widget _buildScoreCard() {
    double percentage = (marksObtained / widget.result.totalMarks) * 100;
    String motivation = percentage >= 75 ? 'Excellent Work!' : percentage >= 50 ? 'Good Effort!' : 'Keep Improving!';

    return Card(
      color: Colors.deepPurple.shade700,
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          children: [
            Text('Marks Obtained', style: TextStyle(color: Colors.white.withOpacity(0.8), fontSize: 16)),
            const SizedBox(height: 8),
            Text('$marksObtained / ${widget.result.totalMarks}', style: const TextStyle(color: Colors.white, fontSize: 36, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text(motivation, style: const TextStyle(color: Colors.yellowAccent, fontSize: 14, fontWeight: FontWeight.bold)),
          ],
        ),
      ),
    );
  }

  Widget _buildStatsRow() {
    return Row(
      children: [
        _buildStatCard('Accuracy', '${accuracy.toStringAsFixed(0)}%', Icons.track_changes, Colors.blue),
        _buildStatCard('Attempt %', '${attemptPercentage.toStringAsFixed(0)}%', Icons.rule, Colors.orange),
        _buildStatCard('Time Taken', _formattedTimeTaken, Icons.timer_outlined, Colors.purple),
      ],
    );
  }

  Widget _buildStatCard(String title, String value, IconData icon, Color color) {
    return Expanded(
      child: Card(
        elevation: 2,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 8.0),
          child: Column(
            children: [
              Icon(icon, color: color, size: 28),
              const SizedBox(height: 8),
              Text(title, style: TextStyle(fontSize: 12, color: Colors.grey[600])),
              const SizedBox(height: 4),
              Text(value, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16))
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildVisualAnalysis() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            const Text('Performance Distribution', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
            const SizedBox(height: 20),
            SizedBox(
              height: 180,
              child: PieChart(
                PieChartData(
                  sectionsSpace: 2,
                  centerSpaceRadius: 40,
                  sections: [
                    PieChartSectionData(value: correctCount.toDouble(), title: '$correctCount', color: Colors.green, radius: 50, titleStyle: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                    PieChartSectionData(value: incorrectCount.toDouble(), title: '$incorrectCount', color: Colors.red, radius: 50, titleStyle: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                    PieChartSectionData(value: unattemptedCount.toDouble(), title: '$unattemptedCount', color: Colors.grey.shade300, radius: 50, titleStyle: const TextStyle(color: Colors.black54, fontWeight: FontWeight.bold)),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 20),
            // Legend
            Wrap(
              spacing: 16,
              runSpacing: 8,
              alignment: WrapAlignment.center,
              children: [
                _buildLegendItem(Colors.green, 'Correct'),
                _buildLegendItem(Colors.red, 'Incorrect'),
                _buildLegendItem(Colors.grey.shade300, 'Skipped'),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLegendItem(Color color, String text) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(width: 12, height: 12, decoration: BoxDecoration(color: color, shape: BoxShape.circle)),
        const SizedBox(width: 6),
        Text(text, style: const TextStyle(fontSize: 12)),
      ],
    );
  }

  Widget _buildReviewSolutionsGrid() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Question Analysis', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
            const SizedBox(height: 5),
            const Text('Tap on a number to view solution & time spent.', style: TextStyle(fontSize: 12, color: Colors.grey)),
            const SizedBox(height: 15),
            GridView.builder(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 6,
                  crossAxisSpacing: 10,
                  mainAxisSpacing: 10
              ),
              itemCount: widget.result.questions.length,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemBuilder: (context, index) {
                final question = widget.result.questions[index];

                String statusStr = 'SKIPPED';
                if (widget.result.responses.containsKey(question.id)) {
                  statusStr = widget.result.responses[question.id]!.status;
                }

                // Map 'REVIEW' to 'SKIPPED' colors for the final grid as well
                Color color = Colors.grey.shade300;
                Color textColor = Colors.black;

                if (statusStr == 'CORRECT') {
                  color = Colors.green;
                  textColor = Colors.white;
                } else if (statusStr == 'INCORRECT') {
                  color = Colors.red;
                  textColor = Colors.white;
                } else {
                  // SKIPPED or REVIEW (without answer)
                  color = Colors.grey.shade200;
                  textColor = Colors.black;
                }

                return GestureDetector(
                  onTap: () => _showSolutionSheet(index),
                  child: Container(
                    decoration: BoxDecoration(
                        color: color,
                        borderRadius: BorderRadius.circular(4),
                        border: Border.all(color: Colors.grey.shade300)
                    ),
                    child: Center(
                      child: Text(
                          '${index + 1}',
                          style: TextStyle(color: textColor, fontWeight: FontWeight.bold)
                      ),
                    ),
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/analytics/screens/test_history_screen.dart
================================================================================
// lib/features/analytics/screens/test_history_screen.dart

import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/test_enums.dart';
// Import the new reusable widget
import 'package:study_smart_qc/features/analytics/widgets/attempt_display_card.dart';

class TestHistoryScreen extends StatefulWidget {
  const TestHistoryScreen({Key? key}) : super(key: key);

  @override
  State<TestHistoryScreen> createState() => _TestHistoryScreenState();
}

class _TestHistoryScreenState extends State<TestHistoryScreen> {
  late Future<List<AttemptModel>> _attemptsFuture;
  final TestOrchestrationService _service = TestOrchestrationService();

  @override
  void initState() {
    super.initState();
    // Fetch attempts from Firestore via the orchestration service
    _attemptsFuture = _service.getUserAttempts();
  }

  Future<void> _refresh() async {
    setState(() {
      _attemptsFuture = _service.getUserAttempts();
    });
  }

  void _navigateToAnalysis(AttemptModel attempt) async {
    // 1. Show Loading UI while fetching question details
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      // 2. Extract Question IDs from the attempt responses
      List<String> questionIds = attempt.responses.keys.toList();

      // 3. Fetch Full Question Objects from Firestore to render the UI
      List<Question> questions = await _service.getQuestionsByIds(questionIds);

      // 4. Reconstruct AnswerStates from the history data for the ResultsScreen
      Map<int, AnswerState> answerStates = {};

      for (int i = 0; i < questions.length; i++) {
        final q = questions[i];
        final response = attempt.responses[q.id];

        AnswerStatus status = AnswerStatus.notVisited;
        if (response != null) {
          if (response.status == 'CORRECT' || response.status == 'INCORRECT') {
            status = AnswerStatus.answered;
          } else if (response.status == 'SKIPPED') {
            status = AnswerStatus.notAnswered;
          }
        }

        answerStates[i] = AnswerState(
          status: status,
          userAnswer: response?.selectedOption, // Supports String, List, or Map
        );
      }

      // 5. Create a TestResult object to pass to the ResultsScreen
      final result = TestResult(
        attemptId: attempt.id, // FIXED: Added attemptId here
        questions: questions,
        answerStates: answerStates,
        timeTaken: Duration(seconds: attempt.timeTakenSeconds),
        totalMarks: questions.length * 4,
        responses: attempt.responses,
      );

      // 6. Navigate to Analysis
      if (mounted) {
        Navigator.pop(context); // Close loader
        Navigator.push(
          context,
          MaterialPageRoute(builder: (context) => ResultsScreen(result: result)),
        );
      }
    } catch (e) {
      if (mounted) Navigator.pop(context); // Close loader on error
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Error loading analysis: $e")),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("History & Analysis"),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 0,
        actions: [
          IconButton(onPressed: _refresh, icon: const Icon(Icons.refresh))
        ],
      ),
      body: FutureBuilder<List<AttemptModel>>(
        future: _attemptsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (!snapshot.hasData || snapshot.data!.isEmpty) {
            return _buildEmptyState();
          }

          final attempts = snapshot.data!;

          return ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: attempts.length,
            itemBuilder: (context, index) {
              // Using the reusable AttemptDisplayCard for consistent UI
              return AttemptDisplayCard(
                attempt: attempts[index],
                onTap: () => _navigateToAnalysis(attempts[index]),
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.assignment_outlined, size: 64, color: Colors.grey.shade300),
          const SizedBox(height: 16),
          const Text("No tests taken yet!", style: TextStyle(color: Colors.grey)),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/features/analytics/widgets/attempt_display_card.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/attempt_model.dart';

class AttemptDisplayCard extends StatelessWidget {
  final AttemptModel attempt;
  final VoidCallback onTap;

  const AttemptDisplayCard({
    super.key,
    required this.attempt,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    // Formatting the date
    final date = attempt.completedAt.toDate();
    final dateStr = "${date.day}/${date.month}/${date.year}";

    // UI logic for mode-based colors
    final bool isTest = attempt.mode == 'Test';

    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: const Color(0xFFF9F7FB), // Light lavender tint like assignments
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.grey.shade200),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.05),
              blurRadius: 4,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Top Row: Code and Date
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: const Color(0xFFDED6F5),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    "CODE: ${attempt.assignmentCode}",
                    style: const TextStyle(
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                      color: Color(0xFF4A148C),
                    ),
                  ),
                ),
                Text(
                  dateStr,
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ],
            ),
            const SizedBox(height: 12),

            // Mode Label (Test/Practice)
            Text(
              "${attempt.mode} Attempt",
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: Colors.black87,
              ),
            ),
            const SizedBox(height: 8),

            // Bottom Row: Icons and Score
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    const Icon(Icons.timer_outlined, size: 16, color: Colors.grey),
                    const SizedBox(width: 4),
                    Text(
                      "${(attempt.timeTakenSeconds / 60).toStringAsFixed(1)} min",
                      style: const TextStyle(fontSize: 13, color: Colors.black54),
                    ),
                  ],
                ),
                // Score Display
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                  decoration: BoxDecoration(
                    color: attempt.score >= 0 ? Colors.green.shade50 : Colors.red.shade50,
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(
                      color: attempt.score >= 0 ? Colors.green.shade200 : Colors.red.shade200,
                    ),
                  ),
                  child: Text(
                    "Score: ${attempt.score}",
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: attempt.score >= 0 ? Colors.green.shade700 : Colors.red.shade700,
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/auth/screens/auth_page.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/auth/screens/login_screen.dart';
import 'package:study_smart_qc/features/auth/screens/register_screen.dart';

class AuthPage extends StatefulWidget {
  const AuthPage({super.key});

  @override
  State<AuthPage> createState() => _AuthPageState();
}

class _AuthPageState extends State<AuthPage> {
  bool _showLoginScreen = true;

  void toggleScreens() {
    setState(() {
      _showLoginScreen = !_showLoginScreen;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_showLoginScreen) {
      return LoginScreen(showRegisterScreen: toggleScreens);
    } else {
      return RegisterScreen(showLoginScreen: toggleScreens);
    }
  }
}


================================================================================
FILE: lib/features/auth/screens/auth_wrapper.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/auth/screens/onboarding_screen.dart';
import 'package:study_smart_qc/features/home/screens/home_screen.dart';
import 'package:study_smart_qc/models/user_model.dart';

class AuthWrapper extends StatelessWidget {
  final User firebaseUser;

  const AuthWrapper({super.key, required this.firebaseUser});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<DocumentSnapshot>(
      stream: FirebaseFirestore.instance
          .collection('users')
          .doc(firebaseUser.uid)
          .snapshots(),
      builder: (context, snapshot) {
        // 1. Loading State
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        // 2. Error State or No Data
        if (snapshot.hasError || !snapshot.hasData || !snapshot.data!.exists) {
          return const Scaffold(
            body: Center(child: Text("Error loading user profile.")),
          );
        }

        // 3. Parse User Data
        try {
          // We use our model to parse the data safely
          UserModel user = UserModel.fromFirestore(snapshot.data!);

          // 4. routing Logic
          if (user.onboardingCompleted) {
            return const HomeScreen();
          } else {
            return const OnboardingScreen();
          }
        } catch (e) {
          return Scaffold(
            body: Center(child: Text("Error parsing user data: $e")),
          );
        }
      },
    );
  }
}

================================================================================
FILE: lib/features/auth/screens/login_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/auth_service.dart';

class LoginScreen extends StatefulWidget {
  final VoidCallback showRegisterScreen;
  const LoginScreen({super.key, required this.showRegisterScreen});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;

  Future<void> _signIn() async {
    if (_formKey.currentState!.validate()) {
      setState(() => _isLoading = true);
      await AuthService().signInWithEmailAndPassword(
        _emailController.text.trim(),
        _passwordController.text.trim(),
      );
      // The auth stream will handle navigation
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.deepPurple[50],
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text('StudySmart', style: TextStyle(fontSize: 48, fontWeight: FontWeight.bold, color: Colors.deepPurple)),
                const SizedBox(height: 50),
                TextFormField(
                  controller: _emailController,
                  decoration: const InputDecoration(labelText: 'Email'),
                  validator: (value) => value!.isEmpty ? 'Please enter an email' : null,
                ),
                const SizedBox(height: 12),
                TextFormField(
                  controller: _passwordController,
                  decoration: const InputDecoration(labelText: 'Password'),
                  obscureText: true,
                  validator: (value) => value!.isEmpty ? 'Please enter a password' : null,
                ),
                const SizedBox(height: 20),
                if (_isLoading)
                  const CircularProgressIndicator()
                else
                  ElevatedButton(
                    onPressed: _signIn,
                    style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 50)),
                    child: const Text('Sign In'),
                  ),
                const SizedBox(height: 12),
                ElevatedButton.icon(
                  icon: Image.asset('assets/google_logo.png', height: 24.0),
                  label: const Text('Sign in with Google', style: TextStyle(fontSize: 16)),
                  style: ElevatedButton.styleFrom(
                      foregroundColor: Colors.black, backgroundColor: Colors.white, minimumSize: const Size(double.infinity, 50)),
                  onPressed: () => AuthService().signInWithGoogle(),
                ),
                TextButton(
                  onPressed: widget.showRegisterScreen,
                  child: const Text('Not a member? Register now'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


================================================================================
FILE: lib/features/auth/screens/onboarding_screen.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/onboarding_service.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final OnboardingService _onboardingService = OnboardingService();
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Loading States
  bool _isFetchingOptions = true;
  bool _isSubmitting = false;

  // Data Options (Fetched from Firestore)
  List<String> _examsList = [];
  List<String> _classesList = [];
  List<String> _subjectsList = [];
  List<int> _targetYears = [];

  // Form State - Student
  String? _selectedExam;
  String? _selectedClass;
  int? _selectedYear;

  // Form State - Teacher
  final List<String> _teacherSelectedExams = [];
  final List<String> _teacherSelectedSubjects = [];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _fetchOptions();
  }

  Future<void> _fetchOptions() async {
    try {
      final doc = await FirebaseFirestore.instance
          .collection('static_data')
          .doc('option_sets')
          .get();

      if (doc.exists) {
        final data = doc.data()!;
        setState(() {
          _examsList = List<String>.from(data['exams_list'] ?? []);
          _classesList = List<String>.from(data['classes_list'] ?? []);
          _subjectsList = List<String>.from(data['subjects_list'] ?? []);
          _targetYears = List<int>.from(data['target_years'] ?? []);
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading options: $e')),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isFetchingOptions = false);
      }
    }
  }

  Future<void> _handleSubmit() async {
    final user = _auth.currentUser;
    if (user == null) return;

    setState(() => _isSubmitting = true);

    try {
      final isStudent = _tabController.index == 0;
      final role = isStudent ? 'student' : 'teacher';
      Map<String, dynamic> profileData = {};

      if (isStudent) {
        // Validate Student Form
        if (_selectedExam == null ||
            _selectedClass == null ||
            _selectedYear == null) {
          throw Exception("Please fill all fields.");
        }
        profileData = {
          'targetExam': _selectedExam,
          'currentClass': _selectedClass,
          'targetYear': _selectedYear,
        };
      } else {
        // Validate Teacher Form
        if (_teacherSelectedExams.isEmpty ||
            _teacherSelectedSubjects.isEmpty) {
          throw Exception("Please select at least one exam and one subject.");
        }
        profileData = {
          'teachingExams': _teacherSelectedExams,
          'teachingSubjects': _teacherSelectedSubjects,
        };
      }

      // Call Service
      await _onboardingService.completeOnboarding(
        uid: user.uid,
        role: role,
        profileData: profileData,
      );

      // No manual navigation needed here; AuthWrapper will react to the data change.
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(e.toString().replaceAll('Exception: ', '')),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isFetchingOptions) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text("Welcome to StudySmart"),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: "I'm a Student", icon: Icon(Icons.school)),
            Tab(text: "I'm a Teacher", icon: Icon(Icons.person_outline)),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildStudentForm(),
          _buildTeacherForm(),
        ],
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.all(20.0),
        child: ElevatedButton(
          style: ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(vertical: 15),
            backgroundColor: Colors.deepPurple,
            foregroundColor: Colors.white,
          ),
          onPressed: _isSubmitting ? null : _handleSubmit,
          child: _isSubmitting
              ? const SizedBox(
            height: 20,
            width: 20,
            child: CircularProgressIndicator(
                color: Colors.white, strokeWidth: 2),
          )
              : const Text("Complete Profile", style: TextStyle(fontSize: 18)),
        ),
      ),
    );
  }

  Widget _buildStudentForm() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("Help us personalize your learning path.",
              style: TextStyle(fontSize: 16, color: Colors.grey)),
          const SizedBox(height: 30),
          _buildDropdown(
            label: "Target Exam",
            value: _selectedExam,
            items: _examsList,
            onChanged: (val) => setState(() => _selectedExam = val),
          ),
          const SizedBox(height: 20),
          _buildDropdown(
            label: "Current Class",
            value: _selectedClass,
            items: _classesList,
            onChanged: (val) => setState(() => _selectedClass = val),
          ),
          const SizedBox(height: 20),
          DropdownButtonFormField<int>(
            // FIX: Using initialValue instead of value
            initialValue: _selectedYear,
            decoration: const InputDecoration(
              labelText: "Target Exam Year",
              border: OutlineInputBorder(),
            ),
            items: _targetYears
                .map((year) => DropdownMenuItem(
              value: year,
              child: Text(year.toString()),
            ))
                .toList(),
            onChanged: (val) => setState(() => _selectedYear = val),
          ),
        ],
      ),
    );
  }

  Widget _buildTeacherForm() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("Tell us about your teaching expertise.",
              style: TextStyle(fontSize: 16, color: Colors.grey)),
          const SizedBox(height: 30),
          const Text("Exams you teach:",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
          const SizedBox(height: 10),
          Wrap(
            spacing: 8.0,
            children: _examsList.map((exam) {
              final isSelected = _teacherSelectedExams.contains(exam);
              return FilterChip(
                label: Text(exam),
                selected: isSelected,
                onSelected: (selected) {
                  setState(() {
                    selected
                        ? _teacherSelectedExams.add(exam)
                        : _teacherSelectedExams.remove(exam);
                  });
                },
              );
            }).toList(),
          ),
          const SizedBox(height: 30),
          const Text("Subjects:",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
          const SizedBox(height: 10),
          Wrap(
            spacing: 8.0,
            children: _subjectsList.map((subject) {
              final isSelected = _teacherSelectedSubjects.contains(subject);
              return FilterChip(
                label: Text(subject),
                selected: isSelected,
                onSelected: (selected) {
                  setState(() {
                    selected
                        ? _teacherSelectedSubjects.add(subject)
                        : _teacherSelectedSubjects.remove(subject);
                  });
                },
              );
            }).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildDropdown({
    required String label,
    required String? value,
    required List<String> items,
    required Function(String?) onChanged,
  }) {
    return DropdownButtonFormField<String>(
      // FIX: Using initialValue instead of value
      initialValue: value,
      decoration: InputDecoration(
        labelText: label,
        border: const OutlineInputBorder(),
      ),
      items: items
          .map((item) => DropdownMenuItem(
        value: item,
        child: Text(item),
      ))
          .toList(),
      onChanged: onChanged,
    );
  }
}

================================================================================
FILE: lib/features/auth/screens/register_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/auth_service.dart';

class RegisterScreen extends StatefulWidget {
  final VoidCallback showLoginScreen;
  const RegisterScreen({super.key, required this.showLoginScreen});

  @override
  State<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends State<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _displayNameController = TextEditingController();
  bool _isLoading = false;

  Future<void> _signUp() async {
    if (_formKey.currentState!.validate()) {
      setState(() => _isLoading = true);
      await AuthService().signUpWithEmailAndPassword(
        _emailController.text.trim(),
        _passwordController.text.trim(),
        _displayNameController.text.trim(),
      );
      // The auth stream will handle navigation
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _displayNameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Register')),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                TextFormField(
                  controller: _displayNameController,
                  decoration: const InputDecoration(labelText: 'Full Name'),
                  validator: (value) => value!.isEmpty ? 'Please enter your name' : null,
                ),
                const SizedBox(height: 12),
                TextFormField(
                  controller: _emailController,
                  decoration: const InputDecoration(labelText: 'Email'),
                  validator: (value) => value!.isEmpty ? 'Please enter an email' : null,
                ),
                const SizedBox(height: 12),
                TextFormField(
                  controller: _passwordController,
                  decoration: const InputDecoration(labelText: 'Password'),
                  obscureText: true,
                  validator: (value) => value!.length < 6 ? 'Password must be at least 6 characters' : null,
                ),
                const SizedBox(height: 20),
                if (_isLoading)
                  const CircularProgressIndicator()
                else
                  ElevatedButton(
                    onPressed: _signUp,
                    child: const Text('Sign Up'),
                  ),
                TextButton(
                  onPressed: widget.showLoginScreen,
                  child: const Text('Already have an account? Login'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


================================================================================
FILE: lib/features/common/widgets/question_preview_card.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/question_model.dart';

class QuestionPreviewCard extends StatefulWidget {
  final Question question;
  final bool isExpanded; // If true, shows full details initially

  const QuestionPreviewCard({
    super.key,
    required this.question,
    this.isExpanded = false,
  });

  @override
  State<QuestionPreviewCard> createState() => _QuestionPreviewCardState();
}

class _QuestionPreviewCardState extends State<QuestionPreviewCard> {
  bool _showAnswer = false;

  @override
  Widget build(BuildContext context) {
    final q = widget.question;

    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // HEADER: ID + Tags
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.deepPurple.shade50,
              borderRadius: const BorderRadius.vertical(top: Radius.circular(12)),
            ),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Colors.deepPurple,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    "QID: ${q.id}",
                    style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 12),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      children: [
                        // UPDATED TAGS: Source -> Chapter -> Topic -> Difficulty
                        if (q.source.isNotEmpty) ...[
                          _buildTag(q.source, Colors.blue.shade50, Colors.blue.shade700),
                          const SizedBox(width: 5),
                        ],
                        if (q.chapterId.isNotEmpty) ...[
                          _buildTag(_formatTag(q.chapterId), Colors.orange.shade50, Colors.orange.shade800),
                          const SizedBox(width: 5),
                        ],
                        _buildTag(_formatTag(q.topicId), Colors.grey.shade100, Colors.grey.shade700),
                        const SizedBox(width: 5),
                        _buildTag(q.difficulty, _getDifficultyColor(q.difficulty), Colors.black87),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),

          // BODY: Question Image
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text("Question:", style: TextStyle(fontWeight: FontWeight.bold, color: Colors.grey)),
                const SizedBox(height: 8),
                Center(
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxHeight: 250),
                    child: Image.network(
                      q.imageUrl,
                      loadingBuilder: (ctx, child, p) => p == null ? child : const CircularProgressIndicator(),
                      errorBuilder: (ctx, err, stack) => const Icon(Icons.broken_image, size: 50, color: Colors.grey),
                    ),
                  ),
                ),
              ],
            ),
          ),

          // FOOTER: Show Answer Toggle
          const Divider(height: 1),
          if (!_showAnswer)
            SizedBox(
              width: double.infinity,
              child: TextButton.icon(
                icon: const Icon(Icons.visibility),
                label: const Text("Show Answer & Solution"),
                onPressed: () => setState(() => _showAnswer = true),
              ),
            ),

          // ANSWER SECTION (Conditional)
          if (_showAnswer)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.green.shade50,
                borderRadius: const BorderRadius.vertical(bottom: Radius.circular(12)),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text("Solution:", style: TextStyle(fontWeight: FontWeight.bold, color: Colors.green)),
                      IconButton(
                        icon: const Icon(Icons.close, size: 16),
                        onPressed: () => setState(() => _showAnswer = false),
                      )
                    ],
                  ),
                  const SizedBox(height: 8),

                  // CORRECT ANSWER TEXT
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      border: Border.all(color: Colors.green.shade200),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Text("Correct Option: ", style: TextStyle(fontWeight: FontWeight.bold)),
                        Text(q.correctAnswer, style: const TextStyle(color: Colors.green, fontWeight: FontWeight.bold, fontSize: 16)),
                      ],
                    ),
                  ),

                  const SizedBox(height: 10),

                  // SOLUTION IMAGE
                  if (q.solutionUrl != null && q.solutionUrl!.isNotEmpty)
                    Center(
                      child: Image.network(
                        q.solutionUrl!,
                        errorBuilder: (ctx, err, stack) => const Text("Solution image not available"),
                      ),
                    )
                  else
                    const Text("No detailed solution image available.", style: TextStyle(fontStyle: FontStyle.italic, color: Colors.grey)),
                ],
              ),
            ),
        ],
      ),
    );
  }

  // Helper to clean up ID strings (e.g., "ray_optics" -> "Ray Optics")
  String _formatTag(String text) {
    if (text.isEmpty) return "";
    return text.split('_').map((str) => str.isNotEmpty ? str[0].toUpperCase() + str.substring(1) : '').join(' ');
  }

  Color _getDifficultyColor(String diff) {
    switch (diff.toLowerCase()) {
      case 'easy': return Colors.green.shade100;
      case 'medium': return Colors.yellow.shade100;
      case 'hard': return Colors.red.shade100;
      default: return Colors.grey.shade200;
    }
  }

  Widget _buildTag(String text, Color bg, Color fg) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: bg.withOpacity(0.5)),
      ),
      child: Text(text, style: TextStyle(fontSize: 10, color: fg, fontWeight: FontWeight.w500)),
    );
  }
}

================================================================================
FILE: lib/features/home/screens/home_screen.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

// --- CRITICAL IMPORTS ---
import 'package:study_smart_qc/features/teacher/screens/teacher_curation_screen.dart';
import 'package:study_smart_qc/features/test_creation/screens/custom_test_history_screen.dart';
import 'package:study_smart_qc/features/test_taking/screens/enter_code_screen.dart';
import 'package:study_smart_qc/features/student/widgets/student_assignments_list.dart';
import 'package:study_smart_qc/services/auth_service.dart';

// NEW IMPORT FOR HISTORY
import 'package:study_smart_qc/features/analytics/screens/test_history_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  String? _userRole;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _fetchUserRole();
  }

  Future<void> _fetchUserRole() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      try {
        final doc = await FirebaseFirestore.instance
            .collection('users')
            .doc(user.uid)
            .get();
        if (mounted) {
          setState(() {
            _userRole = doc.data()?['role'] ?? 'student';
            _isLoading = false;
          });
        }
      } catch (e) {
        if (mounted) setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('StudySmart'),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
      ),
      drawer: _buildDrawer(context),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Center(
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // --- TEACHER ONLY BUTTON ---
                if (_userRole == 'teacher') ...[
                  ElevatedButton.icon(
                    icon: const Icon(Icons.school),
                    label: const Text('Create questions curation'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurple.shade100,
                      foregroundColor: Colors.deepPurple.shade900,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 30,
                        vertical: 15,
                      ),
                      textStyle: const TextStyle(fontSize: 18),
                    ),
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => const TeacherCurationScreen(),
                        ),
                      );
                    },
                  ),
                  const SizedBox(height: 20),
                ],

                // --- STUDENT ASSIGNMENTS SECTION ---
                if (_userRole != 'teacher') ...[
                  const StudentAssignmentsList(),
                  const SizedBox(height: 20),
                  const Divider(),
                  const SizedBox(height: 20),
                ],

                // --- STANDARD BUTTONS ---

                // 1. Create Test
                ElevatedButton.icon(
                  icon: const Icon(Icons.edit_note),
                  label: const Text('Create your own test'),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 30,
                      vertical: 15,
                    ),
                    textStyle: const TextStyle(fontSize: 18),
                  ),
                  onPressed: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => const CustomTestHistoryScreen(),
                      ),
                    );
                  },
                ),
                const SizedBox(height: 20),

                // 2. Attempt Tests
                OutlinedButton.icon(
                  icon: const Icon(Icons.qr_code_scanner),
                  label: const Text('Attempt pre-made tests'),
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 30,
                      vertical: 15,
                    ),
                    textStyle: const TextStyle(fontSize: 18),
                  ),
                  onPressed: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => const EnterCodeScreen(),
                      ),
                    );
                  },
                ),
                const SizedBox(height: 20),

                // 3. NEW: MY ATTEMPTS & ANALYSIS
                ElevatedButton.icon(
                  icon: const Icon(Icons.analytics_outlined),
                  label: const Text('My Past Attempts & Analysis'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green.shade600,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                      horizontal: 30,
                      vertical: 15,
                    ),
                    textStyle: const TextStyle(fontSize: 18),
                  ),
                  onPressed: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => const TestHistoryScreen(),
                      ),
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDrawer(BuildContext context) {
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          const DrawerHeader(
            decoration: BoxDecoration(color: Colors.deepPurple),
            child: Text(
              'StudySmart',
              style: TextStyle(color: Colors.white, fontSize: 24),
            ),
          ),
          ListTile(
            leading: const Icon(Icons.history),
            title: const Text('My History'),
            onTap: () {
              Navigator.of(context).pop();
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const TestHistoryScreen(),
                ),
              );
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.logout),
            title: const Text('Logout'),
            onTap: () {
              Navigator.of(context).pop();
              AuthService().signOut();
            },
          ),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/features/student/widgets/student_assignments_list.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

// --- CRITICAL IMPORTS ---
import 'package:study_smart_qc/models/test_enums.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';

class StudentAssignmentsList extends StatelessWidget {
  const StudentAssignmentsList({super.key});

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return const SizedBox.shrink();

    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('questions_curation')
          .where('studentUid', isEqualTo: user.uid)
          .where('status', isEqualTo: 'assigned') // Only show pending work
          .orderBy('createdAt', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        // --- ERROR HANDLING FOR MISSING INDEX ---
        if (snapshot.hasError) {
          return Container(
            padding: const EdgeInsets.all(16),
            color: Colors.red.shade50,
            child: Column(
              children: [
                const Icon(Icons.error_outline, color: Colors.red),
                const SizedBox(height: 10),
                const Text(
                  "Database Index Missing",
                  style: TextStyle(fontWeight: FontWeight.bold, color: Colors.red),
                ),
                const SizedBox(height: 5),
                SelectableText(
                  "Please create the index using the link below (check console logs if truncated):\n\n${snapshot.error}",
                  style: const TextStyle(color: Colors.red),
                ),
              ],
            ),
          );
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return _buildEmptyState();
        }

        final docs = snapshot.data!.docs;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0),
              child: Text(
                "My Assignments",
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
            ),
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: docs.length,
              itemBuilder: (context, index) {
                final data = docs[index].data() as Map<String, dynamic>;
                final docId = docs[index].id;
                return _buildAssignmentCard(context, data, docId);
              },
            ),
          ],
        );
      },
    );
  }

  Widget _buildEmptyState() {
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: const Center(
        child: Column(
          children: [
            Icon(Icons.assignment_turned_in_outlined, size: 40, color: Colors.grey),
            SizedBox(height: 10),
            Text("No pending assignments!", style: TextStyle(color: Colors.grey)),
          ],
        ),
      ),
    );
  }

  Widget _buildAssignmentCard(BuildContext context, Map<String, dynamic> data, String docId) {
    final Timestamp? ts = data['createdAt'];
    final dateStr = ts != null
        ? DateFormat('MMM d, yyyy').format(ts.toDate())
        : 'Unknown Date';

    final List<dynamic> subjects = data['subjects'] ?? [];
    final int questionCount = (data['questionIds'] as List?)?.length ?? 0;
    final String code = data['assignmentCode'] ?? '----';

    return Card(
      elevation: 3,
      margin: const EdgeInsets.only(bottom: 12),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: () {
          _showModeSelectionDialog(context, docId, data);
        },
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                    decoration: BoxDecoration(
                      color: Colors.deepPurple.shade100,
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      "CODE: $code",
                      style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.deepPurple.shade900),
                    ),
                  ),
                  Text(dateStr, style: const TextStyle(fontSize: 12, color: Colors.grey)),
                ],
              ),
              const SizedBox(height: 10),

              // Title
              Text(
                data['title'] ?? "Untitled Assignment",
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 5),

              // Details
              Row(
                children: [
                  Icon(Icons.menu_book, size: 14, color: Colors.grey.shade600),
                  const SizedBox(width: 4),
                  Text(
                    subjects.join(", "),
                    style: TextStyle(fontSize: 13, color: Colors.grey.shade700),
                  ),
                  const SizedBox(width: 15),
                  Icon(Icons.quiz, size: 14, color: Colors.grey.shade600),
                  const SizedBox(width: 4),
                  Text(
                    "$questionCount Questions",
                    style: TextStyle(fontSize: 13, color: Colors.grey.shade700),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showModeSelectionDialog(BuildContext context, String docId, Map<String, dynamic> data) {
    final questionIds = List<String>.from(data['questionIds'] ?? []);
    // Extract the assignment code to pass along
    final String code = data['assignmentCode'] ?? '----';

    showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text("Start Assignment"),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text("Title: ${data['title']}"),
              const SizedBox(height: 10),
              Text("Questions: ${questionIds.length}"),
              const SizedBox(height: 20),
              const Text("Select Mode:", style: TextStyle(fontWeight: FontWeight.bold)),
            ],
          ),
          actions: [
            // PRACTICE BUTTON
            OutlinedButton.icon(
              icon: const Icon(Icons.school_outlined),
              label: const Text("Practice Mode"),
              onPressed: () {
                Navigator.pop(ctx);
                _launchTest(context, docId, code, questionIds, TestMode.practice);
              },
            ),

            // TEST BUTTON
            ElevatedButton.icon(
              icon: const Icon(Icons.timer),
              label: const Text("Test Mode"),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.deepPurple,
                foregroundColor: Colors.white,
              ),
              onPressed: () {
                Navigator.pop(ctx);
                _launchTest(context, docId, code, questionIds, TestMode.test);
              },
            ),
          ],
        )
    );
  }

  // UPDATED: Now accepts assignmentCode
  Future<void> _launchTest(BuildContext context, String assignmentId, String assignmentCode, List<String> questionIds, TestMode mode) async {
    // Show loading
    showDialog(
        context: context,
        barrierDismissible: false,
        builder: (ctx) => const Center(child: CircularProgressIndicator())
    );

    try {
      // 1. Fetch Questions
      final questions = await TestOrchestrationService().getQuestionsByIds(questionIds);

      if (!context.mounted) return;
      Navigator.pop(context); // Hide loading

      if (questions.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Error: Questions not found.")));
        return;
      }

      // 2. Navigate to Player
      Navigator.push(
          context,
          MaterialPageRoute(
              builder: (_) => TestScreen(
                sourceId: assignmentId, // Linking for analytics
                assignmentCode: assignmentCode, // NEW: Passed to TestScreen
                questions: questions,
                timeLimitInMinutes: questions.length * 3, // Default 3 mins per question
                testMode: mode, // Pass the selected mode
              )
          )
      );

    } catch (e) {
      if (context.mounted) {
        Navigator.pop(context); // Hide loading
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error loading test: $e")));
      }
    }
  }
}

================================================================================
FILE: lib/features/teacher/screens/teacher_curation_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/teacher_service.dart';
import 'package:study_smart_qc/features/teacher/screens/teacher_filter_screen.dart';

class TeacherCurationScreen extends StatefulWidget {
  const TeacherCurationScreen({super.key});

  @override
  State<TeacherCurationScreen> createState() => _TeacherCurationScreenState();
}

class _TeacherCurationScreenState extends State<TeacherCurationScreen> {
  final TeacherService _teacherService = TeacherService();
  final TextEditingController _studentIdController = TextEditingController();

  // State
  String _targetAudience = 'Particular Student'; // 'General', 'Particular Student', 'Batch'
  bool _isLoadingStats = false;
  Map<String, int>? _studentStats;

  void _fetchStats() async {
    final idStr = _studentIdController.text.trim();
    if (idStr.isEmpty) return;

    setState(() => _isLoadingStats = true);
    try {
      final stats = await _teacherService.getStudentStats(int.parse(idStr));
      setState(() => _studentStats = stats);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    } finally {
      if (mounted) setState(() => _isLoadingStats = false);
    }
  }

  void _onNextPressed() {
    if (_targetAudience == 'Particular Student' && _studentIdController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Please enter a Student ID")));
      return;
    }

    // Navigate to Step 2 (Filters)
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => TeacherFilterScreen(
          audienceType: _targetAudience,
          studentId: _studentIdController.text.isNotEmpty ? int.parse(_studentIdController.text) : null,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Questions Curation'),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 1. Audience
            _buildSectionHeader('1. Target Audience'),
            Wrap(
              spacing: 10,
              children: ['General', 'Particular Student', 'Batch'].map((type) {
                return ChoiceChip(
                  label: Text(type),
                  selected: _targetAudience == type,
                  onSelected: (selected) {
                    if (selected) setState(() {
                      _targetAudience = type;
                      _studentStats = null; // Reset stats on change
                    });
                  },
                );
              }).toList(),
            ),

            const SizedBox(height: 30),

            // 2. Student Input (Conditional)
            if (_targetAudience == 'Particular Student') ...[
              _buildSectionHeader('2. Student Details'),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _studentIdController,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                        labelText: 'Enter Student ID',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.person),
                      ),
                      onChanged: (_) => setState(() => _studentStats = null), // Clear stats on edit
                    ),
                  ),
                  const SizedBox(width: 10),
                  ElevatedButton(
                    onPressed: _fetchStats,
                    child: const Text("Load Stats"),
                  ),
                ],
              ),
              const SizedBox(height: 20),

              if (_isLoadingStats)
                const Center(child: CircularProgressIndicator())
              else if (_studentStats != null)
                _buildStatsGrid(),
            ],

            const SizedBox(height: 40),

            // 3. Next Action
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.deepPurple,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                onPressed: _onNextPressed,
                child: const Text('Next', style: TextStyle(fontSize: 18)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 10.0),
      child: Text(title, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.grey)),
    );
  }

  Widget _buildStatsGrid() {
    if (_studentStats!.isEmpty) return const Text("No data found for this student.");

    return GridView.count(
      shrinkWrap: true,
      crossAxisCount: 3,
      childAspectRatio: 1.5,
      physics: const NeverScrollableScrollPhysics(),
      mainAxisSpacing: 10,
      crossAxisSpacing: 10,
      children: _studentStats!.entries.map((e) {
        return Card(
          color: Colors.deepPurple.shade50,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(e.value.toString(), style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Colors.deepPurple)),
              Text(e.key, style: const TextStyle(fontSize: 12, color: Colors.grey)),
            ],
          ),
        );
      }).toList(),
    );
  }
}

================================================================================
FILE: lib/features/teacher/screens/teacher_filter_screen.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/common/widgets/question_preview_card.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/services/teacher_service.dart';

class TeacherFilterScreen extends StatefulWidget {
  final String audienceType;
  final int? studentId;

  const TeacherFilterScreen({
    super.key,
    required this.audienceType,
    this.studentId,
  });

  @override
  State<TeacherFilterScreen> createState() => _TeacherFilterScreenState();
}

class _TeacherFilterScreenState extends State<TeacherFilterScreen> {
  final TeacherService _teacherService = TeacherService();

  // Data
  bool _isLoadingSyllabus = true;
  Map<String, dynamic>? _syllabusData;
  List<String> _subjects = [];

  // Selection
  String? _selectedSubject;
  final Set<String> _selectedChapters = {};
  final Set<String> _selectedTopics = {};
  String? _smartFilter;

  // Search
  bool _isSearching = false;
  List<Question>? _results;
  final Set<String> _selectedQuestionIds = {};

  @override
  void initState() {
    super.initState();
    _fetchSyllabus();
    if (widget.audienceType == 'Particular Student') {
      _smartFilter = 'New Questions';
    }
  }

  Future<void> _fetchSyllabus() async {
    try {
      final doc = await FirebaseFirestore.instance.collection('static_data').doc('syllabus').get();
      if (doc.exists) {
        final data = doc.data()!;
        setState(() {
          _syllabusData = data['subjects'];
          _subjects = _syllabusData?.keys.toList() ?? [];
        });
      }
    } catch (e) {
      debugPrint("Error loading syllabus: $e");
    } finally {
      if (mounted) setState(() => _isLoadingSyllabus = false);
    }
  }

  // --- HELPERS ---
  List<String> get _availableChapters {
    if (_selectedSubject == null || _syllabusData == null) return [];
    final chaptersMap = _syllabusData![_selectedSubject]['chapters'] as Map<String, dynamic>?;
    return chaptersMap?.keys.toList() ?? [];
  }

  List<String> get _availableTopics {
    if (_selectedSubject == null || _selectedChapters.isEmpty || _syllabusData == null) return [];
    List<String> topics = [];
    final chaptersMap = _syllabusData![_selectedSubject]['chapters'];

    for (var chapId in _selectedChapters) {
      final chapData = chaptersMap[chapId];
      if (chapData != null && chapData['topics'] != null) {
        final topicMap = chapData['topics'] as Map<String, dynamic>;
        topics.addAll(topicMap.keys);
      }
    }
    return topics;
  }

  String _formatName(String id) {
    return id.split('_').map((str) => str.isNotEmpty ? str[0].toUpperCase() + str.substring(1) : '').join(' ');
  }

  String _getSelectionSummary(Set<String> selected) {
    if (selected.isEmpty) return "Select Options";
    if (selected.length == 1) return _formatName(selected.first);
    if (selected.length == 2) return "${_formatName(selected.first)}, ${_formatName(selected.last)}";
    return "${_formatName(selected.first)} (+${selected.length - 1} more)";
  }

  // --- ACTIONS ---

  Future<void> _onSearch() async {
    setState(() {
      _isSearching = true;
      _results = null;
      _selectedQuestionIds.clear();
    });

    try {
      final questions = await _teacherService.fetchQuestions(
        audienceType: widget.audienceType,
        studentId: widget.studentId,
        smartFilter: _smartFilter,
        subject: _selectedSubject,
        chapterIds: _selectedChapters.isNotEmpty ? _selectedChapters.toList() : null,
        topicIds: _selectedTopics.isNotEmpty ? _selectedTopics.toList() : null,
      );
      setState(() => _results = questions);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
    } finally {
      setState(() => _isSearching = false);
    }
  }

  Future<void> _onAssign() async {
    if (_selectedQuestionIds.isEmpty) return;
    final teacher = FirebaseAuth.instance.currentUser;
    if (teacher == null) return;

    final titleCtrl = TextEditingController(text: "Homework - ${DateTime.now().toString().split(' ')[0]}");
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Confirm Assignment"),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text("Assigning ${_selectedQuestionIds.length} questions."),
            const SizedBox(height: 10),
            TextField(controller: titleCtrl, decoration: const InputDecoration(labelText: "Assignment Title")),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("Cancel")),
          ElevatedButton(onPressed: () => Navigator.pop(ctx, true), child: const Text("Assign")),
        ],
      ),
    );

    if (confirm != true) return;

    try {
      if (widget.audienceType != 'Particular Student') {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Batch assignment coming soon!")));
        return;
      }

      // 1. FILTER OBJECTS: We need to pass the full Question objects now
      final selectedQuestions = _results!.where((q) => _selectedQuestionIds.contains(q.id)).toList();

      await _teacherService.assignQuestionsToStudent(
        studentId: widget.studentId!,
        questions: selectedQuestions, // PASSING OBJECTS
        teacherUid: teacher.uid,
        targetAudience: widget.audienceType, // PASSING AUDIENCE
        assignmentTitle: titleCtrl.text,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Assigned Successfully!")));
        Navigator.pop(context);
        Navigator.pop(context);
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
    }
  }

  // --- CUSTOM MULTI-SELECT DIALOG ---
  void _showMultiSelectDialog({
    required String title,
    required List<String> items,
    required Set<String> selectedItems,
    required Function(Set<String>) onConfirm,
  }) {
    showDialog(
      context: context,
      builder: (context) {
        Set<String> localSelected = Set.from(selectedItems);
        String searchQuery = "";

        return StatefulBuilder(
          builder: (context, setDialogState) {
            final filteredItems = items.where((item) =>
                item.toLowerCase().contains(searchQuery.toLowerCase())
            ).toList();

            return Dialog(
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              child: Container(
                constraints: BoxConstraints(maxHeight: MediaQuery.of(context).size.height * 0.6),
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
                    const SizedBox(height: 10),

                    TextField(
                      decoration: const InputDecoration(
                        hintText: "Search...",
                        prefixIcon: Icon(Icons.search),
                        border: OutlineInputBorder(),
                        contentPadding: EdgeInsets.symmetric(vertical: 8),
                      ),
                      onChanged: (val) => setDialogState(() => searchQuery = val),
                    ),
                    const SizedBox(height: 10),

                    Expanded(
                      child: ListView.builder(
                        itemCount: filteredItems.length,
                        itemBuilder: (context, index) {
                          final item = filteredItems[index];
                          final isSelected = localSelected.contains(item);
                          return CheckboxListTile(
                            title: Text(_formatName(item)),
                            value: isSelected,
                            activeColor: Colors.deepPurple,
                            onChanged: (val) {
                              setDialogState(() {
                                val == true ? localSelected.add(item) : localSelected.remove(item);
                              });
                            },
                          );
                        },
                      ),
                    ),

                    const SizedBox(height: 10),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text("${localSelected.length} Selected", style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.deepPurple)),
                        ElevatedButton(
                          onPressed: () {
                            onConfirm(localSelected);
                            Navigator.pop(context);
                          },
                          child: const Text("Done"),
                        )
                      ],
                    )
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final inputDecoration = InputDecoration(
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 15),
    );

    return Scaffold(
      appBar: AppBar(title: const Text("Filter & Search"), backgroundColor: Colors.deepPurple, foregroundColor: Colors.white),
      body: Stack(
        children: [
          SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 80),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text("Syllabus Filters", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                const SizedBox(height: 15),

                if (_isLoadingSyllabus)
                  const Center(child: LinearProgressIndicator())
                else ...[
                  // 1. SUBJECT
                  DropdownButtonFormField<String>(
                    value: _selectedSubject,
                    hint: const Text("Select Subject"),
                    items: _subjects.map((s) => DropdownMenuItem(value: s, child: Text(_formatName(s)))).toList(),
                    onChanged: (val) => setState(() {
                      _selectedSubject = val;
                      _selectedChapters.clear();
                      _selectedTopics.clear();
                    }),
                    decoration: inputDecoration.copyWith(labelText: "Subject"),
                  ),
                  const SizedBox(height: 15),

                  // 2. CHAPTERS
                  InkWell(
                    onTap: _selectedSubject == null ? null : () {
                      _showMultiSelectDialog(
                        title: "Select Chapters",
                        items: _availableChapters,
                        selectedItems: _selectedChapters,
                        onConfirm: (newSet) => setState(() {
                          _selectedChapters.clear();
                          _selectedChapters.addAll(newSet);
                          _selectedTopics.clear();
                        }),
                      );
                    },
                    child: InputDecorator(
                      decoration: inputDecoration.copyWith(
                        labelText: "Chapters",
                        enabled: _selectedSubject != null,
                        suffixIcon: const Icon(Icons.arrow_drop_down),
                      ),
                      child: Text(
                        _getSelectionSummary(_selectedChapters),
                        style: TextStyle(color: _selectedSubject == null ? Colors.grey : Colors.black),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ),
                  const SizedBox(height: 15),

                  // 3. TOPICS
                  InkWell(
                    onTap: _selectedChapters.isEmpty ? null : () {
                      _showMultiSelectDialog(
                        title: "Select Topics",
                        items: _availableTopics,
                        selectedItems: _selectedTopics,
                        onConfirm: (newSet) => setState(() {
                          _selectedTopics.clear();
                          _selectedTopics.addAll(newSet);
                        }),
                      );
                    },
                    child: InputDecorator(
                      decoration: inputDecoration.copyWith(
                        labelText: "Topics",
                        enabled: _selectedChapters.isNotEmpty,
                        suffixIcon: const Icon(Icons.arrow_drop_down),
                      ),
                      child: Text(
                        _getSelectionSummary(_selectedTopics),
                        style: TextStyle(color: _selectedChapters.isEmpty ? Colors.grey : Colors.black),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ),
                ],

                const SizedBox(height: 20),

                // 4. SMART FILTERS
                if (widget.audienceType == 'Particular Student') ...[
                  const Text("Smart Filters", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                  const SizedBox(height: 10),
                  DropdownButtonFormField<String>(
                    value: _smartFilter,
                    items: ['New Questions', 'Incorrect', 'Unattempted', 'Skipped', 'Correct']
                        .map((f) => DropdownMenuItem(value: f, child: Text(f))).toList(),
                    onChanged: (val) => setState(() => _smartFilter = val),
                    decoration: inputDecoration.copyWith(labelText: "Status"),
                  ),
                ],

                const SizedBox(height: 30),

                // 5. SEARCH BUTTON
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    icon: const Icon(Icons.search),
                    label: const Text("Search Questions"),
                    style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurple,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 16)
                    ),
                    onPressed: _onSearch,
                  ),
                ),

                const Divider(height: 40),

                // 6. RESULTS
                if (_isSearching)
                  const Center(child: CircularProgressIndicator())
                else if (_results != null)
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text("Found ${_results!.length} Questions", style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
                      const SizedBox(height: 10),
                      if (_results!.isEmpty) const Text("No questions found."),

                      ListView.builder(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        itemCount: _results!.length,
                        itemBuilder: (context, index) {
                          final q = _results![index];
                          final isSelected = _selectedQuestionIds.contains(q.id);

                          return Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(top: 8.0),
                                child: Checkbox(
                                  value: isSelected,
                                  onChanged: (val) => setState(() {
                                    val == true ? _selectedQuestionIds.add(q.id) : _selectedQuestionIds.remove(q.id);
                                  }),
                                ),
                              ),
                              Expanded(
                                child: QuestionPreviewCard(question: q),
                              ),
                            ],
                          );
                        },
                      ),
                    ],
                  ),
              ],
            ),
          ),

          if (_selectedQuestionIds.isNotEmpty)
            Positioned(
              bottom: 20, left: 20, right: 20,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  elevation: 5,
                ),
                onPressed: _onAssign,
                child: Text("Assign ${_selectedQuestionIds.length} Questions", style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              ),
            ),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/features/test_creation/screens/custom_test_history_screen.dart
================================================================================
// lib/features/test_creation/screens/custom_test_history_screen.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';
import 'package:study_smart_qc/features/test_creation/screens/syllabus_screen.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';
// CRITICAL IMPORT: Needed for TestMode
import 'package:study_smart_qc/models/test_enums.dart';

class CustomTestHistoryScreen extends StatefulWidget {
  const CustomTestHistoryScreen({super.key});
  @override
  State<CustomTestHistoryScreen> createState() =>
      _CustomTestHistoryScreenState();
}

class _CustomTestHistoryScreenState extends State<CustomTestHistoryScreen> {
  final TestOrchestrationService _testService = TestOrchestrationService();
  String _filter = 'All';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Create Your Own Test')),
      body: Column(
        children: [
          _buildFilterChips(),
          Expanded(
            child: StreamBuilder<List<TestModel>>(
              stream: _testService.getSavedTestsStream(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                if (!snapshot.hasData || snapshot.data!.isEmpty) {
                  return const Center(child: Text('No tests created yet.'));
                }

                final allTests = snapshot.data!;
                final filteredTests = allTests.where((test) {
                  if (_filter == 'All') return true;
                  return test.status == _filter;
                }).toList();

                if (filteredTests.isEmpty) {
                  return Center(
                    child: Text('No tests match the \'$_filter\' filter.'),
                  );
                }

                return ListView.builder(
                  padding: const EdgeInsets.only(bottom: 100),
                  itemCount: filteredTests.length,
                  itemBuilder: (context, index) {
                    final test = filteredTests[index];
                    return _buildTestListItem(test);
                  },
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          Navigator.of(context).push(
            MaterialPageRoute(builder: (context) => const SyllabusScreen()),
          );
        },
        icon: const Icon(Icons.add),
        label: const Text('Create new custom test'),
        backgroundColor: Colors.blue,
        foregroundColor: Colors.white,
      ),
    );
  }

  Widget _buildFilterChips() {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: ['All', 'Attempted', 'Not Attempted'].map((filter) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 4.0),
            child: ChoiceChip(
              label: Text(filter),
              selected: _filter == filter,
              onSelected: (selected) {
                if (selected) {
                  setState(() => _filter = filter);
                }
              },
            ),
          );
        }).toList(),
      ),
    );
  }

  Widget _buildTestListItem(TestModel test) {
    final formattedDate = DateFormat(
      'd MMM yyyy',
    ).format(test.createdAt.toDate());
    bool isAttempted = test.status == 'Attempted';

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              test.testName,
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 4),
            Text(
              'JEE Main â€¢ $formattedDate',
              style: TextStyle(color: Colors.grey.shade600),
            ),
            const SizedBox(height: 12),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () async {
                    if (isAttempted) {
                      final attempt = await _testService.getAttemptForTest(
                        test.id,
                      );
                      final questions = await _testService.getQuestionsByIds(
                        test.questionIds,
                      );
                      if (mounted && attempt != null) {
                        final answerStates = <int, AnswerState>{};
                        for (int i = 0; i < questions.length; i++) {
                          final questionId = questions[i].id;
                          final response = attempt.responses[questionId];
                          answerStates[i] = AnswerState(
                            userAnswer: response?.selectedOption,
                            status: response?.status == 'CORRECT' ||
                                response?.status == 'INCORRECT'
                                ? AnswerStatus.answered
                                : AnswerStatus.notAnswered,
                          );
                        }

                        // FIXED: Added attemptId here
                        final result = TestResult(
                          attemptId: attempt.id,
                          questions: questions,
                          answerStates: answerStates,
                          timeTaken: Duration(
                            seconds: attempt.timeTakenSeconds,
                          ),
                          totalMarks: questions.length * 4,
                          responses: attempt.responses,
                        );

                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (context) => ResultsScreen(result: result),
                          ),
                        );
                      }
                    } else {
                      final List<Question> questions = await _testService
                          .getQuestionsByIds(test.questionIds);
                      if (mounted) {
                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (context) => TestScreen(
                              questions: questions,
                              timeLimitInMinutes:
                              test.config.durationSeconds ~/ 60,
                              // FIXED: Using sourceId instead of testId
                              sourceId: test.id,
                              // FIXED: Added TestMode enum
                              testMode: TestMode.test,
                            ),
                          ),
                        );
                      }
                    }
                  },
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(isAttempted ? 'View Analysis' : 'Attempt now'),
                      const Icon(Icons.arrow_forward_ios, size: 14),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/test_creation/screens/syllabus_screen.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/auth_service.dart';
import 'package:study_smart_qc/widgets/test_configuration_bottom_sheet.dart';

class SyllabusScreen extends StatefulWidget {
  const SyllabusScreen({super.key});

  @override
  State<SyllabusScreen> createState() => _SyllabusScreenState();
}

class _SyllabusScreenState extends State<SyllabusScreen> {
  // State for user selections
  final Set<String> _selectedTopicIds = {};
  final Set<String> _selectedChapterIds = {};
  final Map<String, bool> _expansionState = {};

  // State to hold parsed syllabus data, preventing re-parsing on every UI rebuild
  Map<String, String> _chapterIdToNameMap = {};
  Map<String, String> _topicIdToNameMap = {};
  Map<String, Map<String, String>> _chapterIdToTopicsMap = {};
  List<String> _chapterKeys = [];

  void _onTopicSelected(bool isSelected, String chapterId, String topicId) {
    setState(() {
      if (isSelected) {
        _selectedTopicIds.add(topicId);
        _selectedChapterIds.add(chapterId);
      } else {
        _selectedTopicIds.remove(topicId);
        final chapterTopics = _chapterIdToTopicsMap[chapterId]?.keys ?? [];
        if (chapterTopics.every((topic) => !_selectedTopicIds.contains(topic))) {
          _selectedChapterIds.remove(chapterId);
        }
      }
    });
  }

  void _toggleSelectAll(String chapterId, Set<String> topicKeys) {
    setState(() {
      final areAllSelected = topicKeys.isNotEmpty && topicKeys.every((key) => _selectedTopicIds.contains(key));
      if (areAllSelected) {
        _selectedTopicIds.removeAll(topicKeys);
        _selectedChapterIds.remove(chapterId);
      } else {
        _selectedTopicIds.addAll(topicKeys);
        _selectedChapterIds.add(chapterId);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Select Topics"),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
        actions: [
          IconButton(icon: const Icon(Icons.logout), onPressed: () => AuthService().signOut()),
        ],
      ),
      body: StreamBuilder<DocumentSnapshot>(
        stream: FirebaseFirestore.instance.collection('static_data').doc('syllabus').snapshots(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (!snapshot.hasData || !snapshot.data!.exists) {
            return const Center(child: Text("No Syllabus Found"));
          }

          if (snapshot.hasData) {
            Map<String, dynamic> data = snapshot.data!.data() as Map<String, dynamic>;
            final chapters = data['subjects']?['physics']?['chapters'] as Map<String, dynamic>? ?? {};
            _chapterKeys = chapters.keys.toList();

            _chapterIdToNameMap = {};
            _topicIdToNameMap = {};
            _chapterIdToTopicsMap = {};

            for (var chapterKey in _chapterKeys) {
              final chapterData = chapters[chapterKey] as Map<String, dynamic>;
              _chapterIdToNameMap[chapterKey] = chapterData['name'] ?? 'Unnamed Chapter';
              final topics = Map<String, String>.from(chapterData['topics'] ?? {});
              _chapterIdToTopicsMap[chapterKey] = topics;
              for (var topicEntry in topics.entries) {
                _topicIdToNameMap[topicEntry.key] = topicEntry.value as String;
              }
            }
          }

          return ListView.builder(
            key: const PageStorageKey<String>('syllabus_list'),
            padding: const EdgeInsets.only(bottom: 120),
            itemCount: _chapterKeys.length,
            itemBuilder: (context, index) {
              final chapterKey = _chapterKeys[index];
              final chapterName = _chapterIdToNameMap[chapterKey]!;
              final topics = _chapterIdToTopicsMap[chapterKey]!;
              final topicKeys = topics.keys.toSet();

              final areAllSelected = topicKeys.isNotEmpty && topicKeys.every((key) => _selectedTopicIds.contains(key));
              final isExpanded = _expansionState[chapterKey] ?? false;

              return Card(
                margin: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                  side: BorderSide(color: areAllSelected ? Colors.green : Colors.transparent, width: 2),
                ),
                child: Column(
                  children: [
                    ListTile(
                      leading: const Icon(Icons.book, color: Colors.deepPurple),
                      title: Text(chapterName, style: const TextStyle(fontWeight: FontWeight.bold)),
                      onTap: () => _toggleSelectAll(chapterKey, topicKeys),
                      trailing: IconButton(
                        icon: Icon(isExpanded ? Icons.expand_less : Icons.expand_more),
                        onPressed: () => setState(() => _expansionState[chapterKey] = !isExpanded),
                      ),
                    ),
                    if (isExpanded)
                      Padding(
                        padding: const EdgeInsets.all(8.0),
                        child: GridView.builder(
                          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 2,
                            childAspectRatio: 2.5,
                            crossAxisSpacing: 8,
                            mainAxisSpacing: 8,
                          ),
                          itemCount: topicKeys.length,
                          shrinkWrap: true,
                          physics: const NeverScrollableScrollPhysics(),
                          itemBuilder: (context, gridIndex) {
                            final topicKey = topicKeys.elementAt(gridIndex);
                            final topicName = topics[topicKey]!;
                            final isSelected = _selectedTopicIds.contains(topicKey);

                            return GestureDetector(
                              onTap: () => _onTopicSelected(!isSelected, chapterKey, topicKey),
                              child: Card(
                                color: isSelected ? Colors.green.withOpacity(0.15) : null,
                                elevation: 0,
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8), side: BorderSide(color: Colors.grey.shade300)),
                                child: Center(
                                  child: Padding(
                                    padding: const EdgeInsets.all(8.0),
                                    child: Text(topicName, textAlign: TextAlign.center, style: const TextStyle(fontSize: 12)),
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                      ),
                  ],
                ),
              );
            },
          );
        },
      ),
      bottomSheet: _selectedTopicIds.isNotEmpty ? _buildStickyBottomBar() : null,
    );
  }

  Widget _buildStickyBottomBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 15).copyWith(bottom: MediaQuery.of(context).padding.bottom + 10),
      decoration: BoxDecoration(color: Colors.deepPurple.shade700, boxShadow: const [BoxShadow(color: Colors.black26, blurRadius: 8, offset: Offset(0, -2))]),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${_selectedTopicIds.length} Topic(s) Selected', style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16)),
              Text('${_selectedChapterIds.length} Chapter(s)', style: const TextStyle(color: Colors.white70, fontSize: 12)),
            ],
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(foregroundColor: Colors.deepPurple, backgroundColor: Colors.white, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)), padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12)),
            onPressed: () {
              showModalBottomSheet(
                context: context,
                isScrollControlled: true,
                builder: (ctx) => TestConfigurationBottomSheet(
                  chapterIds: _selectedChapterIds,
                  topicIds: _selectedTopicIds,
                  chapterIdToNameMap: _chapterIdToNameMap,
                  topicIdToNameMap: _topicIdToNameMap,
                  chapterIdToTopicsMap: _chapterIdToTopicsMap, // FIX: This is now correctly passed
                ),
              );
            },
            child: const Row(children: [Text('Configure Test'), SizedBox(width: 5), Icon(Icons.arrow_forward_ios, size: 14)]),
          ),
        ],
      ),
    );
  }
}


================================================================================
FILE: lib/features/test_taking/screens/enter_code_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_preview_screen.dart';

class EnterCodeScreen extends StatefulWidget {
  const EnterCodeScreen({super.key});

  @override
  State<EnterCodeScreen> createState() => _EnterCodeScreenState();
}

class _EnterCodeScreenState extends State<EnterCodeScreen> {
  final _codeController = TextEditingController();
  final _testService = TestOrchestrationService();
  bool _isLoading = false;
  String? _errorText;

  Future<void> _findTest() async {
    if (_codeController.text.isEmpty) return;

    setState(() {
      _isLoading = true;
      _errorText = null;
    });

    final test = await _testService.getTestByShareCode(
      _codeController.text.trim(),
    );

    if (test == null) {
      setState(() {
        _isLoading = false;
        _errorText = 'Invalid or expired test code.';
      });
      return;
    }

    final questions = await _testService.getQuestionsByIds(test.questionIds);

    if (!mounted) return;

    setState(() => _isLoading = false);

    // Navigate to Test Preview Screen
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => TestPreviewScreen(
          questions: questions,
          timeLimitInMinutes: test.config.durationSeconds ~/ 60,
          selectedSyllabus: {
            for (var v in test.chapters) v: [],
          }, // Reconstruct a simplified map
          testName: test.testName,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Enter Test Code')),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            TextField(
              controller: _codeController,
              textAlign: TextAlign.center,
              style: const TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                letterSpacing: 8,
              ),
              decoration: InputDecoration(
                hintText: '_ _ _ _',
                errorText: _errorText,
                border: const OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 20),
            if (_isLoading)
              const CircularProgressIndicator()
            else
              ElevatedButton(
                onPressed: _findTest,
                child: const Text('Find Test'),
              ),
          ],
        ),
      ),
    );
  }
}


================================================================================
FILE: lib/features/test_taking/screens/test_preview_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
// NEW IMPORT
import 'package:study_smart_qc/models/test_enums.dart';

class TestPreviewScreen extends StatelessWidget {
  final List<Question> questions;
  final int timeLimitInMinutes;
  final Map<String, List<String>> selectedSyllabus;
  final String testName;
  final TestModel? existingTest;

  const TestPreviewScreen({
    super.key,
    required this.questions,
    required this.timeLimitInMinutes,
    required this.selectedSyllabus,
    required this.testName,
    this.existingTest,
  });

  Future<void> _handleAttemptLater(BuildContext context) async {
    final service = TestOrchestrationService();
    if (existingTest == null) {
      await service.createAndSaveTestBlueprint(
        questions: questions,
        durationSeconds: timeLimitInMinutes * 60,
        chapterNames: selectedSyllabus.keys.toList(),
        testName: testName,
      );
    }

    if (context.mounted) {
      Navigator.of(context).popUntil((route) => route.isFirst);
    }
  }

  Future<void> _handleAttemptNow(BuildContext context) async {
    final service = TestOrchestrationService();
    TestModel? testToAttempt = existingTest;

    if (testToAttempt == null) {
      testToAttempt = await service.createAndSaveTestBlueprint(
        questions: questions,
        durationSeconds: timeLimitInMinutes * 60,
        chapterNames: selectedSyllabus.keys.toList(),
        testName: testName,
      );
    }

    if (testToAttempt == null) return;

    await service.recordTestAttempt(testToAttempt.id);

    if (context.mounted) {
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (context) => TestScreen(
            questions: questions,
            timeLimitInMinutes: timeLimitInMinutes,
            // FIXED: Updated arguments here
            sourceId: testToAttempt!.id,
            testMode: TestMode.test,
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Test Preview'),
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              testName,
              style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            const Wrap(
              spacing: 8.0,
              children: [
                Chip(
                  label: Text('JEE Main'),
                  avatar: Icon(Icons.check_circle, color: Colors.green),
                ),
                Chip(label: Text('Physics')),
              ],
            ),
            const SizedBox(height: 20),
            Row(
              children: [
                Expanded(
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        children: [
                          const Icon(
                            Icons.help_outline,
                            color: Colors.deepPurple,
                          ),
                          const SizedBox(height: 8),
                          Text('${questions.length} Qs'),
                        ],
                      ),
                    ),
                  ),
                ),
                Expanded(
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        children: [
                          const Icon(
                            Icons.timer_outlined,
                            color: Colors.deepPurple,
                          ),
                          const SizedBox(height: 8),
                          Text('$timeLimitInMinutes Mins'),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),
            const Divider(),
            const SizedBox(height: 10),
            Text(
              'Syllabus - ${selectedSyllabus.length} chapters',
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            Expanded(
              child: ListView.builder(
                itemCount: selectedSyllabus.length,
                itemBuilder: (context, index) {
                  final chapterName = selectedSyllabus.keys.elementAt(index);
                  final topicNames = selectedSyllabus[chapterName]!;
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 8.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'â€¢ $chapterName',
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        if (topicNames.isNotEmpty)
                          Padding(
                            padding: const EdgeInsets.only(left: 20, top: 4),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: topicNames
                                  .map(
                                    (topic) => Text(
                                  '    - $topic',
                                  style: TextStyle(
                                    color: Colors.grey.shade700,
                                  ),
                                ),
                              )
                                  .toList(),
                            ),
                          ),
                      ],
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                onPressed: () => _handleAttemptNow(context),
                child: const Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text('Attempt test now'),
                    Icon(Icons.arrow_forward),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 10),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: () => _handleAttemptLater(context),
                child: const Text('Attempt later'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/test_taking/screens/test_screen.dart
================================================================================
// lib/features/test_taking/screens/test_screen.dart

import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart'; // Added for fetching ID
import 'package:firebase_auth/firebase_auth.dart'; // Added for fetching ID
import 'package:flutter/foundation.dart'; // For list/map equality checks
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/models/test_enums.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/widgets/expandable_image.dart';
import 'package:study_smart_qc/widgets/question_input_widget.dart';

class TestScreen extends StatefulWidget {
  final String sourceId;
  final String assignmentCode;
  final List<Question> questions;
  final int timeLimitInMinutes;
  final TestMode testMode;

  const TestScreen({
    super.key,
    required this.questions,
    required this.timeLimitInMinutes,
    this.sourceId = '',
    this.assignmentCode = 'PRAC',
    this.testMode = TestMode.test,
  });

  @override
  State<TestScreen> createState() => _TestScreenState();
}

class _TestScreenState extends State<TestScreen> {
  late final PageController _pageController;
  late final Timer _timer;
  late Duration _overallTimeCounter;
  bool _isPaused = false;

  // State Maps
  final Map<int, AnswerState> _answerStates = {};
  final Map<int, int> _visitCounts = {};
  final Map<int, Stopwatch> _timeTrackers = {};

  int _currentPage = 0;
  bool _isAnswerChecked = false;

  @override
  void initState() {
    super.initState();
    _pageController = PageController();

    // 1. Timer Setup
    if (widget.testMode == TestMode.test) {
      _overallTimeCounter = Duration(minutes: widget.timeLimitInMinutes);
    } else {
      _overallTimeCounter = Duration.zero;
    }

    // 2. Initialize Questions
    for (int i = 0; i < widget.questions.length; i++) {
      // AnswerState.userAnswer will now hold dynamic data (String, List, or Map)
      _answerStates[i] = AnswerState(status: AnswerStatus.notVisited);
      _visitCounts[i] = 0;
      _timeTrackers[i] = Stopwatch();
    }

    // Initialize first page
    _onPageChanged(0, fromInit: true);
    _startTimer();
  }

  // --- TIMER LOGIC ---
  void _startTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_isPaused) return;
      if (mounted) {
        setState(() {
          if (widget.testMode == TestMode.test) {
            if (_overallTimeCounter.inSeconds > 0) {
              _overallTimeCounter -= const Duration(seconds: 1);
            } else {
              _timer.cancel();
              _handleSubmit();
            }
          } else {
            _overallTimeCounter += const Duration(seconds: 1);
          }
        });
      }
    });
  }

  void _onPageChanged(int page, {bool fromInit = false}) {
    if (!fromInit && _timeTrackers.containsKey(_currentPage)) {
      _timeTrackers[_currentPage]!.stop();
    }

    setState(() {
      _currentPage = page;
      _isAnswerChecked = false;
      _visitCounts[page] = (_visitCounts[page] ?? 0) + 1;

      if (_answerStates[page]?.status == AnswerStatus.notVisited) {
        _answerStates[page]?.status = AnswerStatus.notAnswered;
      }
    });

    if (_timeTrackers.containsKey(page)) {
      _timeTrackers[page]!.start();
    }
  }

  void _togglePause() {
    setState(() => _isPaused = !_isPaused);
    if (_isPaused) {
      _timeTrackers[_currentPage]?.stop();
    } else {
      _timeTrackers[_currentPage]?.start();
    }
  }

  @override
  void dispose() {
    _timer.cancel();
    _pageController.dispose();
    super.dispose();
  }

  // --- HELPER: COMPARE ANSWERS (Handles Lists & Maps) ---
  bool _checkEquality(dynamic userAns, dynamic correctAns) {
    if (userAns == null || correctAns == null) return false;

    // 1. Simple String/Number comparison
    if (userAns is String || userAns is num) {
      return userAns.toString().trim().toLowerCase() ==
          correctAns.toString().trim().toLowerCase();
    }

    // 2. List Comparison (Multi-Correct) - Order doesn't matter
    if (userAns is List && correctAns is List) {
      if (userAns.length != correctAns.length) return false;
      final userSet = userAns.map((e) => e.toString()).toSet();
      final correctSet = correctAns.map((e) => e.toString()).toSet();
      return userSet.containsAll(correctSet);
    }

    // 3. Map Comparison (Matrix)
    if (userAns is Map && correctAns is Map) {
      if (userAns.length != correctAns.length) return false;
      for (var key in userAns.keys) {
        if (!correctAns.containsKey(key)) return false;
        // Compare values (which are usually lists in Matrix)
        if (!_checkEquality(userAns[key], correctAns[key])) return false;
      }
      return true;
    }

    return userAns == correctAns;
  }

  // --- ACTION HANDLERS ---

  void _checkAnswer() {
    final state = _answerStates[_currentPage]!;

    // Check if answer is empty/null
    bool isEmpty = false;
    if (state.userAnswer == null) isEmpty = true;
    if (state.userAnswer is String && (state.userAnswer as String).isEmpty)
      isEmpty = true;
    if (state.userAnswer is List && (state.userAnswer as List).isEmpty)
      isEmpty = true;
    if (state.userAnswer is Map && (state.userAnswer as Map).isEmpty)
      isEmpty = true;

    if (isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Please select an answer first!")));
      return;
    }
    setState(() {
      _isAnswerChecked = true;
    });
  }

  void _showSolution() {
    final q = widget.questions[_currentPage];
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (ctx) => Container(
        padding: const EdgeInsets.all(16),
        height: MediaQuery.of(ctx).size.height * 0.7,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text("Solution",
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const Divider(),
            const SizedBox(height: 10),
            // Correct Answer display might need formatting for Map/List types
            Text("Correct Answer: ${q.correctAnswer}",
                style: const TextStyle(
                    fontWeight: FontWeight.bold, color: Colors.green)),
            const SizedBox(height: 10),
            if (q.solutionUrl != null)
              Expanded(
                  child: Center(
                      child: ExpandableImage(imageUrl: q.solutionUrl!)))
            else
              const Text("No image solution available."),
          ],
        ),
      ),
    );
  }

  void _handleSaveAndNext() {
    final state = _answerStates[_currentPage]!;

    // Check if answered
    bool hasAnswer = state.userAnswer != null;
    if (state.userAnswer is String && (state.userAnswer as String).isEmpty)
      hasAnswer = false;
    if (state.userAnswer is List && (state.userAnswer as List).isEmpty)
      hasAnswer = false;

    if (hasAnswer) {
      setState(() => state.status = AnswerStatus.answered);
    } else {
      setState(() => state.status = AnswerStatus.notAnswered);
    }
    _moveToNextPage();
  }

  void _handleSaveAndMarkForReview() {
    final state = _answerStates[_currentPage]!;
    bool hasAnswer = state.userAnswer != null;
    if (state.userAnswer is String && (state.userAnswer as String).isEmpty)
      hasAnswer = false;
    if (state.userAnswer is List && (state.userAnswer as List).isEmpty)
      hasAnswer = false;

    if (hasAnswer) {
      setState(() => state.status = AnswerStatus.answeredAndMarked);
      _moveToNextPage();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text("Please select an answer to Save & Mark for Review")),
      );
    }
  }

  void _handleMarkForReviewAndNext() {
    setState(() {
      _answerStates[_currentPage]!.status = AnswerStatus.markedForReview;
    });
    _moveToNextPage();
  }

  void _handleClearResponse() {
    setState(() {
      _answerStates[_currentPage]!.userAnswer = null; // Clear dynamic answer
      _answerStates[_currentPage]!.status = AnswerStatus.notAnswered;
      _isAnswerChecked = false;
    });
  }

  void _moveToNextPage() {
    if (_currentPage < widget.questions.length - 1) {
      _pageController.nextPage(
          duration: const Duration(milliseconds: 300), curve: Curves.easeIn);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content:
            Text("You are on the last question. Click Submit to finish.")),
      );
    }
  }

  void _handleSubmit() async {
    _timer.cancel();
    _timeTrackers.values.forEach((sw) => sw.stop());
    Map<String, ResponseObject> responses = {};

    for (int i = 0; i < widget.questions.length; i++) {
      final question = widget.questions[i];
      final state = _answerStates[i]!;
      String finalStatus = 'SKIPPED';

      if (state.status == AnswerStatus.answered ||
          state.status == AnswerStatus.answeredAndMarked) {
        // USE NEW EQUALITY CHECK
        final isCorrect =
        _checkEquality(state.userAnswer, question.correctAnswer);
        finalStatus = isCorrect ? 'CORRECT' : 'INCORRECT';
      } else if (state.status == AnswerStatus.markedForReview) {
        finalStatus = 'REVIEW';
      }

      // Convert complex answers to String for storage if ResponseObject requires String
      // If ResponseObject accepts dynamic, you can pass state.userAnswer directly
      String storedAnswer = state.userAnswer.toString();

      responses[question.id] = ResponseObject(
        status: finalStatus,
        selectedOption: storedAnswer,
        correctOption: question.correctAnswer.toString(),
        timeSpent: _timeTrackers[i]!.elapsed.inSeconds,
        visitCount: _visitCounts[i] ?? 0,
        q_no: i + 1,
      );
    }

    final score =
        (responses.values.where((r) => r.status == 'CORRECT').length * 4) -
            (responses.values.where((r) => r.status == 'INCORRECT').length * 1);

    // 1. Submit to Firestore
    await TestOrchestrationService().submitAttempt(
      sourceId: widget.sourceId,
      assignmentCode: widget.assignmentCode,
      mode: widget.testMode == TestMode.test ? 'Test' : 'Practice',
      questions: widget.questions,
      score: score,
      timeTakenSeconds: widget.testMode == TestMode.test
          ? (Duration(minutes: widget.timeLimitInMinutes) - _overallTimeCounter)
          .inSeconds
          : _overallTimeCounter.inSeconds,
      responses: responses,
    );

    // 2. Fetch the ID of the attempt we just created
    // (This is necessary because submitAttempt returns void, but we need the ID for the next screen)
    String attemptId = '';
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      try {
        final latestSnap = await FirebaseFirestore.instance
            .collection('attempts')
            .where('userId', isEqualTo: user.uid)
            .orderBy('completedAt', descending: true)
            .limit(1)
            .get();

        if (latestSnap.docs.isNotEmpty) {
          attemptId = latestSnap.docs.first.id;
        }
      } catch (e) {
        print("Error fetching latest attempt ID: $e");
      }
    }

    if (mounted) {
      final result = TestResult(
        attemptId: attemptId, // FIXED: Now passing the generated/fetched ID
        questions: widget.questions,
        answerStates: _answerStates,
        timeTaken: widget.testMode == TestMode.test
            ? Duration(minutes: widget.timeLimitInMinutes) - _overallTimeCounter
            : _overallTimeCounter,
        totalMarks: widget.questions.length * 4,
        responses: responses,
      );
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (context) => ResultsScreen(result: result)),
      );
    }
  }

  Future<void> _showSubmitConfirmationDialog() async {
    return showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Submit Test'),
        content: const Text('Are you sure you want to finish the test?'),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(
            onPressed: () {
              Navigator.pop(ctx);
              _handleSubmit();
            },
            child: const Text('Submit'),
          ),
        ],
      ),
    );
  }

  // --- UI BUILDERS ---

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: _buildOverallTimerWidget(),
        centerTitle: true,
        automaticallyImplyLeading: false,
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
        actions: [
          TextButton(
            onPressed: _showSubmitConfirmationDialog,
            child: const Text('Submit',
                style: TextStyle(
                    color: Colors.white, fontWeight: FontWeight.bold)),
          ),
        ],
      ),
      body: Column(
        children: [
          _buildNTAQuestionPalette(),
          const Divider(height: 1),

          Expanded(
            child: PageView.builder(
              controller: _pageController,
              physics: _isPaused
                  ? const NeverScrollableScrollPhysics()
                  : const AlwaysScrollableScrollPhysics(),
              onPageChanged: (index) => _onPageChanged(index),
              itemCount: widget.questions.length,
              itemBuilder: (context, index) {
                final q = widget.questions[index];
                return SingleChildScrollView(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text('Q.${index + 1}',
                              style: const TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold)),
                          _buildQuestionTimerWidget(index),
                        ],
                      ),
                      const SizedBox(height: 10),

                      if (q.imageUrl.isNotEmpty)
                        Align(
                          alignment: Alignment.centerLeft,
                          child: ExpandableImage(imageUrl: q.imageUrl),
                        ),
                      const SizedBox(height: 20),

                      // =======================================================
                      // NEW: Unified Input Widget handles all types (SCQ, Num, Matrix)
                      // =======================================================
                      QuestionInputWidget(
                        question: q,
                        currentAnswer: _answerStates[index]?.userAnswer,
                        onAnswerChanged: (newAnswer) {
                          // Update state when widget reports a change
                          if (!_isPaused) {
                            setState(() {
                              _answerStates[index]?.userAnswer = newAnswer;
                              // Reset local feedback if in practice mode
                              if (widget.testMode == TestMode.practice) {
                                _isAnswerChecked = false;
                              }
                            });
                          }
                        },
                      ),

                      if (widget.testMode == TestMode.practice &&
                          _isAnswerChecked)
                        _buildFeedbackUI(q),
                    ],
                  ),
                );
              },
            ),
          ),
        ],
      ),
      bottomNavigationBar: _buildBottomNavBar(),
    );
  }

  Widget _buildOverallTimerWidget() {
    String twoDigits(int n) => n.toString().padLeft(2, "0");
    final minutes = twoDigits(_overallTimeCounter.inMinutes.remainder(60));
    final seconds = twoDigits(_overallTimeCounter.inSeconds.remainder(60));
    final hours = twoDigits(_overallTimeCounter.inHours);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
      decoration: BoxDecoration(
        color: Colors.deepPurple.shade700,
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        "$hours:$minutes:$seconds",
        style: const TextStyle(
            fontSize: 18, fontWeight: FontWeight.bold, letterSpacing: 1.2),
      ),
    );
  }

  Widget _buildQuestionTimerWidget(int index) {
    final duration = _timeTrackers[index]?.elapsed ?? Duration.zero;
    String twoDigits(int n) => n.toString().padLeft(2, "0");
    final minutes = twoDigits(duration.inMinutes.remainder(60));
    final seconds = twoDigits(duration.inSeconds.remainder(60));

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.access_time_filled, size: 16, color: Colors.black54),
          const SizedBox(width: 5),
          Text(
            "$minutes:$seconds",
            style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: Colors.black87),
          ),
        ],
      ),
    );
  }

  Widget _buildNTAQuestionPalette() {
    return Container(
      height: 70,
      padding: const EdgeInsets.symmetric(vertical: 10),
      color: Colors.grey.shade50,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        padding: const EdgeInsets.symmetric(horizontal: 10),
        itemCount: widget.questions.length,
        itemBuilder: (context, index) {
          final state = _answerStates[index]!;
          final isCurrent = index == _currentPage;

          BoxShape shape = BoxShape.rectangle;
          Color color = Colors.white;
          Border? border = Border.all(color: Colors.grey.shade300);
          Widget? badge;

          switch (state.status) {
            case AnswerStatus.notVisited:
              color = Colors.white;
              break;
            case AnswerStatus.notAnswered:
              color = Colors.red;
              border = null;
              break;
            case AnswerStatus.answered:
              color = Colors.green;
              border = null;
              break;
            case AnswerStatus.markedForReview:
              shape = BoxShape.circle;
              color = Colors.purple;
              border = null;
              break;
            case AnswerStatus.answeredAndMarked:
              shape = BoxShape.circle;
              color = Colors.purple;
              border = null;
              badge = const Positioned(
                bottom: 0,
                right: 0,
                child: Icon(Icons.check_circle, size: 14, color: Colors.green),
              );
              break;
          }

          return GestureDetector(
            onTap: () => _pageController.jumpToPage(index),
            child: Container(
              width: 50,
              margin: const EdgeInsets.symmetric(horizontal: 5),
              child: Stack(
                alignment: Alignment.center,
                children: [
                  Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: color,
                      shape: shape,
                      border: isCurrent
                          ? Border.all(color: Colors.blueAccent, width: 3)
                          : border,
                      borderRadius: shape == BoxShape.rectangle
                          ? BorderRadius.circular(4)
                          : null,
                    ),
                    child: Center(
                      child: Text(
                        "${index + 1}",
                        style: TextStyle(
                          color: (color == Colors.white)
                              ? Colors.black
                              : Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  if (badge != null) badge,
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildFeedbackUI(Question q) {
    // Use the robust equality check for feedback as well
    final isCorrect =
    _checkEquality(_answerStates[_currentPage]?.userAnswer, q.correctAnswer);

    return Container(
      margin: const EdgeInsets.only(top: 20),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: isCorrect ? Colors.green.shade50 : Colors.red.shade50,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: isCorrect ? Colors.green : Colors.red),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(children: [
            Icon(isCorrect ? Icons.check_circle : Icons.cancel,
                color: isCorrect ? Colors.green : Colors.red),
            const SizedBox(width: 10),
            Text(isCorrect ? "Correct!" : "Incorrect",
                style: TextStyle(
                    fontWeight: FontWeight.bold,
                    color: isCorrect ? Colors.green : Colors.red)),
          ]),
          const SizedBox(height: 10),
          ElevatedButton(
              onPressed: _showSolution, child: const Text("View Full Solution")),
        ],
      ),
    );
  }

  Widget _buildBottomNavBar() {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(color: Colors.white, boxShadow: [
        BoxShadow(
            color: Colors.grey.shade200,
            blurRadius: 4,
            offset: const Offset(0, -2))
      ]),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (widget.testMode == TestMode.practice)
            Padding(
              padding: const EdgeInsets.only(bottom: 12.0),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _checkAnswer,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.orange,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: const Text("Check Answer"),
                ),
              ),
            ),
          Row(
            children: [
              Expanded(
                child: ElevatedButton(
                  onPressed: _handleSaveAndMarkForReview,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white,
                    foregroundColor: Colors.purple,
                    side: const BorderSide(color: Colors.purple),
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    elevation: 0,
                  ),
                  child: const Text("Save & Mark Review",
                      textAlign: TextAlign.center,
                      style:
                      TextStyle(fontSize: 12, fontWeight: FontWeight.bold)),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: ElevatedButton(
                  onPressed: _handleMarkForReviewAndNext,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white,
                    foregroundColor: Colors.purple,
                    side: const BorderSide(color: Colors.purple),
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    elevation: 0,
                  ),
                  child: const Text("Mark Review & Next",
                      textAlign: TextAlign.center,
                      style:
                      TextStyle(fontSize: 12, fontWeight: FontWeight.bold)),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: _handleClearResponse,
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    foregroundColor: Colors.red,
                    side: const BorderSide(color: Colors.red),
                  ),
                  child: const Text("Clear",
                      style: TextStyle(fontWeight: FontWeight.bold)),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: ElevatedButton(
                  onPressed: _handleSaveAndNext,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: const Text("Save & Next",
                      style: TextStyle(fontWeight: FontWeight.bold)),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/models/attempt_item_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

class AttemptItemModel {
  final String userId;
  final DocumentReference attemptRef; // <--- The Fix: Stores reference to parent
  final String questionId;
  final String chapterId;
  final String topicId;
  final String status;
  final int timeSpent;
  final Timestamp attemptedAt;
  final String assignmentCode;
  final String mode;
  final String? mistakeCategory;
  final String? mistakeNote;

  AttemptItemModel({
    required this.userId,
    required this.attemptRef,
    required this.questionId,
    required this.chapterId,
    required this.topicId,
    required this.status,
    required this.timeSpent,
    required this.attemptedAt,
    required this.assignmentCode,
    required this.mode,
    this.mistakeCategory,
    this.mistakeNote,
  });

  factory AttemptItemModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    return AttemptItemModel(
      userId: data['userId'] ?? '',
      // Safe casting for the reference
      attemptRef: data['attemptRef'] is DocumentReference
          ? data['attemptRef']
          : FirebaseFirestore.instance.collection('attempts').doc('unknown'),
      questionId: data['questionId'] ?? '',
      chapterId: data['chapterId'] ?? '',
      topicId: data['topicId'] ?? '',
      status: data['status'] ?? 'SKIPPED',
      timeSpent: data['timeSpent'] ?? 0,
      attemptedAt: data['attemptedAt'] ?? Timestamp.now(),
      assignmentCode: data['assignmentCode'] ?? '',
      mode: data['mode'] ?? 'Test',
      mistakeCategory: data['mistakeCategory'],
      mistakeNote: data['mistakeNote'],
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'attemptRef': attemptRef,
      'questionId': questionId,
      'chapterId': chapterId,
      'topicId': topicId,
      'status': status,
      'timeSpent': timeSpent,
      'attemptedAt': attemptedAt,
      'assignmentCode': assignmentCode,
      'mode': mode,
      'mistakeCategory': mistakeCategory,
      'mistakeNote': mistakeNote,
    };
  }
}

================================================================================
FILE: lib/models/attempt_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

// --- 1. ResponseObject Class ---
class ResponseObject {
  final String status; // 'CORRECT', 'INCORRECT', 'SKIPPED'
  final dynamic selectedOption;
  final String correctOption;
  final int timeSpent;
  final int visitCount;
  final int q_no;

  // NEW: Manual categorization fields
  final String? mistakeCategory;
  final String? mistakeNote;

  ResponseObject({
    required this.status,
    this.selectedOption,
    required this.correctOption,
    required this.timeSpent,
    required this.visitCount,
    required this.q_no,
    this.mistakeCategory,
    this.mistakeNote,
  });

  factory ResponseObject.fromMap(Map<String, dynamic> map) {
    return ResponseObject(
      status: map['status'] ?? 'SKIPPED',
      selectedOption: map['selectedOption'],
      correctOption: map['correctOption'] ?? '',
      timeSpent: map['timeSpent'] ?? 0,
      visitCount: map['visitCount'] ?? 0,
      q_no: map['q_no'] ?? 0,
      mistakeCategory: map['mistakeCategory'],
      mistakeNote: map['mistakeNote'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'status': status,
      'selectedOption': selectedOption,
      'correctOption': correctOption,
      'timeSpent': timeSpent,
      'visitCount': visitCount,
      'q_no': q_no,
      'mistakeCategory': mistakeCategory,
      'mistakeNote': mistakeNote,
    };
  }
}

// --- 2. AttemptModel Class ---
class AttemptModel {
  final String id;
  final String sourceId;
  final String assignmentCode;
  final String mode;
  final String userId;
  final Timestamp startedAt;
  final Timestamp completedAt;
  final num score;
  final int totalQuestions;
  final int maxMarks;

  // Aggregates
  final int correctCount;
  final int incorrectCount;
  final int skippedCount;

  final int timeTakenSeconds;
  final Map<String, ResponseObject> responses;

  AttemptModel({
    required this.id,
    required this.sourceId,
    required this.assignmentCode,
    required this.mode,
    required this.userId,
    required this.startedAt,
    required this.completedAt,
    required this.score,
    required this.totalQuestions,
    required this.maxMarks,
    required this.correctCount,
    required this.incorrectCount,
    required this.skippedCount,
    required this.timeTakenSeconds,
    required this.responses,
  });

  factory AttemptModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    dynamic rawStartedAt = data['startedAt'];
    Timestamp startedAtTimestamp = (rawStartedAt is String)
        ? Timestamp.fromDate(DateTime.parse(rawStartedAt))
        : rawStartedAt ?? Timestamp.now();

    dynamic rawCompletedAt = data['completedAt'];
    Timestamp completedAtTimestamp = (rawCompletedAt is String)
        ? Timestamp.fromDate(DateTime.parse(rawCompletedAt))
        : rawCompletedAt ?? Timestamp.now();

    Map<String, ResponseObject> parsedResponses = {};
    if (data['responses'] is Map) {
      (data['responses'] as Map).forEach((key, value) {
        if (value is Map) {
          parsedResponses[key] = ResponseObject.fromMap(value as Map<String, dynamic>);
        }
      });
    }

    return AttemptModel(
      id: doc.id,
      sourceId: data['sourceId'] ?? data['testId'] ?? '',
      assignmentCode: data['assignmentCode'] ?? '----',
      mode: data['mode'] ?? 'Test',
      userId: data['userId'] ?? '',
      startedAt: startedAtTimestamp,
      completedAt: completedAtTimestamp,
      score: data['score'] ?? 0,
      totalQuestions: data['total_questions'] ?? 0,
      maxMarks: data['max_marks'] ?? 0,
      correctCount: data['correct_count'] ?? 0,
      incorrectCount: data['incorrect_count'] ?? 0,
      skippedCount: data['skipped_count'] ?? 0,
      timeTakenSeconds: data['timeTakenSeconds'] ?? 0,
      responses: parsedResponses,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'sourceId': sourceId,
      'assignmentCode': assignmentCode,
      'mode': mode,
      'userId': userId,
      'startedAt': startedAt,
      'completedAt': completedAt,
      'score': score,
      'total_questions': totalQuestions,
      'max_marks': maxMarks,
      'correct_count': correctCount,
      'incorrect_count': incorrectCount,
      'skipped_count': skippedCount,
      'timeTakenSeconds': timeTakenSeconds,
      'responses': responses.map((key, value) => MapEntry(key, value.toMap())),
    };
  }
}

================================================================================
FILE: lib/models/custom_test_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

// Represents a test that has been generated and potentially saved.
class CustomTest {
  final String id;
  final String userId;
  final String testName;
  final String status; // e.g., 'Not Attempted', 'Attempted'
  final List<String> questionIds;
  final int totalQuestions;
  final int timeLimitInMinutes;
  final Timestamp createdAt;
  final List<String> chapterNames;

  CustomTest({
    required this.id,
    required this.userId,
    required this.testName,
    required this.status,
    required this.questionIds,
    required this.totalQuestions,
    required this.timeLimitInMinutes,
    required this.createdAt,
    required this.chapterNames,
  });

  // Factory to create a CustomTest from a Firestore document.
  factory CustomTest.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    return CustomTest(
      id: doc.id,
      userId: data['userId'] ?? '',
      testName: data['testName'] ?? 'Custom Test',
      status: data['status'] ?? 'Not Attempted',
      questionIds: List<String>.from(data['questionIds'] ?? []),
      totalQuestions: data['totalQuestions'] ?? 0,
      timeLimitInMinutes: data['timeLimitInMinutes'] ?? 0,
      createdAt: data['createdAt'] ?? Timestamp.now(),
      chapterNames: List<String>.from(data['chapterNames'] ?? []),
    );
  }

  // Method to convert a CustomTest instance to a map for Firestore.
  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'testName': testName,
      'status': status,
      'questionIds': questionIds,
      'totalQuestions': totalQuestions,
      'timeLimitInMinutes': timeLimitInMinutes,
      'createdAt': createdAt,
      'chapterNames': chapterNames,
    };
  }
}


================================================================================
FILE: lib/models/nta_test_models.dart
================================================================================
import 'package:flutter/material.dart';

enum AnswerStatus {
  notVisited,
  notAnswered, // Visited but skipped
  answered,
  markedForReview, // Not answered, but marked
  answeredAndMarked, // Answered and marked for review
}

extension AnswerStatusExtension on AnswerStatus {
  Color get color {
    switch (this) {
      case AnswerStatus.answered:
        return Colors.green;
      case AnswerStatus.notAnswered:
        return Colors.red;
      case AnswerStatus.markedForReview:
        return Colors.purple;
      case AnswerStatus.answeredAndMarked:
        return Colors.blue;
      case AnswerStatus.notVisited:
      default:
        return Colors.grey.shade400;
    }
  }
}

class AnswerState {
  String? userAnswer;
  AnswerStatus status;

  AnswerState({this.userAnswer, this.status = AnswerStatus.notVisited});
}


================================================================================
FILE: lib/models/question_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

// 1. DEFINE THE ENUM HERE (Outside the class)
enum QuestionType {
  singleCorrect,   // Matches Firestore 'Single Correct'
  numerical,       // Matches Firestore 'Numerical type'
  multipleCorrect, // Matches Firestore 'One or more options correct'
  matrixSingle,    // Matches Firestore 'Single Matrix Match'
  matrixMulti,     // Matches Firestore 'Multi Matrix Match'
  unknown          // Safety fallback
}

class Question {
  final String id;
  final String chapterId;
  final String topicId;
  final QuestionType type; // Using the Enum
  final String imageUrl;
  final String? solutionUrl;
  final dynamic correctAnswer; // Dynamic (String, List, or Map)
  final String difficulty;
  final String source;

  Question({
    required this.id,
    required this.chapterId,
    required this.topicId,
    required this.type,
    required this.imageUrl,
    this.solutionUrl,
    required this.correctAnswer,
    required this.difficulty,
    required this.source,
  });

  factory Question.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    return Question(
      id: doc.id,
      chapterId: data['chapterId'] ?? '',
      topicId: data['topicId'] ?? '',
      type: _mapStringToType(data['Question type']), // Helper function
      imageUrl: data['image_url'] ?? '',
      solutionUrl: data['solution_url'],
      correctAnswer: data['Correct Answer'],
      difficulty: data['Difficulty_tag'] ?? 'Medium',
      source: data['Exam'] ?? '',
    );
  }

  // Helper to convert Firestore String -> Enum
  static QuestionType _mapStringToType(String? typeString) {
    switch (typeString) {
      case 'Single Correct':
        return QuestionType.singleCorrect;
      case 'Numerical type':
        return QuestionType.numerical;
      case 'One or more options correct':
        return QuestionType.multipleCorrect;
      case 'Single Matrix Match':
        return QuestionType.matrixSingle;
      case 'Multi Matrix Match':
        return QuestionType.matrixMulti;
      default:
        return QuestionType.unknown;
    }
  }
}

================================================================================
FILE: lib/models/test_enums.dart
================================================================================
// lib/models/test_enums.dart
enum TestMode {
  test,      // Timer counts down, no feedback, auto-submit
  practice,  // Timer counts up (or hidden), instant feedback, solution access, pause allowed
}

================================================================================
FILE: lib/models/test_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

class TestConfig {
  final int durationSeconds;
  final int totalQuestions;

  TestConfig({
    required this.durationSeconds,
    required this.totalQuestions,
  });

  factory TestConfig.fromMap(Map<String, dynamic> map) {
    return TestConfig(
      durationSeconds: map['durationSeconds'] ?? 0,
      totalQuestions: map['totalQuestions'] ?? 0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'durationSeconds': durationSeconds,
      'totalQuestions': totalQuestions,
    };
  }
}

class TestModel {
  final String id;
  final String createdBy;
  final Timestamp createdAt;
  final String status;
  final String testName;
  final TestConfig config;
  final List<String> questionIds;
  final List<String> chapters;
  final String? shareCode; // New field
  final List<String> uidsAttemptedTests; // New field

  TestModel({
    required this.id,
    required this.createdBy,
    required this.createdAt,
    required this.status,
    required this.testName,
    required this.config,
    required this.questionIds,
    required this.chapters,
    this.shareCode,
    required this.uidsAttemptedTests,
  });

  factory TestModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    dynamic rawTimestamp = data['createdAt'];
    Timestamp createdAtTimestamp;
    if (rawTimestamp is String) {
      createdAtTimestamp = Timestamp.fromDate(DateTime.parse(rawTimestamp));
    } else if (rawTimestamp is Timestamp) {
      createdAtTimestamp = rawTimestamp;
    } else {
      createdAtTimestamp = Timestamp.now();
    }

    return TestModel(
      id: doc.id,
      createdBy: data['createdBy'] ?? '',
      createdAt: createdAtTimestamp,
      status: data['status'] ?? 'GENERATED',
      testName: data['testName'] ?? 'Unnamed Test',
      config: TestConfig.fromMap(data['config'] ?? {}),
      questionIds: List<String>.from(data['questionIds'] ?? []),
      chapters: List<String>.from(data['chapters'] ?? []),
      shareCode: data['shareCode'],
      uidsAttemptedTests: List<String>.from(data['uidsAttemptedTests'] ?? []),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'createdBy': createdBy,
      'createdAt': createdAt,
      'status': status,
      'testName': testName,
      'config': config.toMap(),
      'questionIds': questionIds,
      'chapters': chapters,
      'shareCode': shareCode,
      'uidsAttemptedTests': uidsAttemptedTests,
    };
  }
}


================================================================================
FILE: lib/models/test_result.dart
================================================================================
// lib/models/test_result.dart

import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/question_model.dart';

class TestResult {
  final String attemptId; // Added: Unique ID of the attempt session
  final List<Question> questions;
  final Map<int, AnswerState> answerStates;
  final Duration timeTaken;
  final int totalMarks;
  final Map<String, ResponseObject> responses;

  TestResult({
    required this.attemptId, // Added
    required this.questions,
    required this.answerStates,
    required this.timeTaken,
    required this.totalMarks,
    required this.responses,
  });
}

================================================================================
FILE: lib/models/user_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

class UserStats {
  final int testsTaken;
  final int questionsSolved;
  final double averageAccuracy;

  UserStats({
    this.testsTaken = 0,
    this.questionsSolved = 0,
    this.averageAccuracy = 0.0,
  });

  factory UserStats.fromMap(Map<String, dynamic> map) {
    return UserStats(
      testsTaken: map['testsTaken'] ?? 0,
      questionsSolved: map['questionsSolved'] ?? 0,
      averageAccuracy: (map['averageAccuracy'] ?? 0.0).toDouble(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'testsTaken': testsTaken,
      'questionsSolved': questionsSolved,
      'averageAccuracy': averageAccuracy,
    };
  }
}

class UserModel {
  final String uid;
  final String email;
  final String displayName;
  final UserStats stats;
  final List<String> testIDsattempted;
  final Timestamp createdAt;

  // --- NEW ONBOARDING FIELDS ---
  final String role; // 'student' or 'teacher'
  final bool onboardingCompleted;

  // Student Specific
  final int? studentId;
  final String? targetExam;
  final String? currentClass;
  final int? targetYear;

  // Teacher Specific
  final List<String>? teachingExams;
  final List<String>? teachingSubjects;

  UserModel({
    required this.uid,
    required this.email,
    required this.displayName,
    required this.stats,
    required this.testIDsattempted,
    required this.createdAt,
    this.role = 'student', // Default to student
    this.onboardingCompleted = false, // Default to false
    this.studentId,
    this.targetExam,
    this.currentClass,
    this.targetYear,
    this.teachingExams,
    this.teachingSubjects,
  });

  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    return UserModel(
      uid: doc.id,
      email: data['email'] ?? '',
      displayName: data['displayName'] ?? '',
      stats: UserStats.fromMap(data['stats'] ?? {}),
      testIDsattempted: List<String>.from(data['testIDsattempted'] ?? []),
      createdAt: data['createdAt'] ?? Timestamp.now(),

      // Map New Fields
      role: data['role'] ?? 'student',
      onboardingCompleted: data['onboardingCompleted'] ?? false,
      studentId: data['studentId'],
      targetExam: data['targetExam'],
      currentClass: data['currentClass'],
      targetYear: data['targetYear'],
      teachingExams: data['teachingExams'] != null
          ? List<String>.from(data['teachingExams'])
          : null,
      teachingSubjects: data['teachingSubjects'] != null
          ? List<String>.from(data['teachingSubjects'])
          : null,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'email': email,
      'displayName': displayName,
      'stats': stats.toMap(),
      'testIDsattempted': testIDsattempted,
      'createdAt': createdAt,

      // Save New Fields
      'role': role,
      'onboardingCompleted': onboardingCompleted,
      'studentId': studentId,
      'targetExam': targetExam,
      'currentClass': currentClass,
      'targetYear': targetYear,
      'teachingExams': teachingExams,
      'teachingSubjects': teachingSubjects,
    };
  }
}

================================================================================
FILE: lib/services/auth_service.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:study_smart_qc/models/user_model.dart';

class AuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final GoogleSignIn _googleSignIn = GoogleSignIn();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  Stream<User?> get userStream {
    return _auth.authStateChanges().asyncMap((user) async {
      if (user != null) {
        await _createUserDocumentIfNotExist(user);
      }
      return user;
    });
  }

  Future<void> _createUserDocumentIfNotExist(
      User user, {
        String? displayName,
      }) async {
    final userRef = _firestore.collection('users').doc(user.uid);
    final doc = await userRef.get();

    if (!doc.exists) {
      final newUser = UserModel(
        uid: user.uid,
        email: user.email ?? '',
        displayName: displayName ?? user.displayName ?? '',
        stats: UserStats(),
        testIDsattempted: [],
        createdAt: Timestamp.now(),

        // --- NEW DEFAULTS FOR ONBOARDING ---
        role: 'student',
        onboardingCompleted: false,
      );
      await userRef.set(newUser.toFirestore());
    }
  }

  Future<UserCredential?> signInWithGoogle() async {
    try {
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      if (googleUser == null) return null;

      final GoogleSignInAuthentication googleAuth =
      await googleUser.authentication;
      final OAuthCredential credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );
      return await _auth.signInWithCredential(credential);
    } catch (e) {
      print("Error during Google Sign-In: $e");
      return null;
    }
  }

  Future<UserCredential?> signInWithEmailAndPassword(
      String email,
      String password,
      ) async {
    try {
      return await _auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
    } on FirebaseAuthException catch (e) {
      print("Error during Email Sign-In: ${e.message}");
      return null;
    }
  }

  Future<UserCredential?> signUpWithEmailAndPassword(
      String email,
      String password,
      String displayName,
      ) async {
    try {
      UserCredential userCredential = await _auth
          .createUserWithEmailAndPassword(email: email, password: password);

      User? user = userCredential.user;
      if (user != null) {
        await user.updateDisplayName(displayName);
        await _createUserDocumentIfNotExist(user, displayName: displayName);
      }
      return userCredential;
    } on FirebaseAuthException catch (e) {
      print("Error during Email Sign-Up: ${e.message}");
      return null;
    }
  }

  Future<void> signOut() async {
    await _googleSignIn.signOut();
    await _auth.signOut();
  }
}

================================================================================
FILE: lib/services/custom_test_service.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:study_smart_qc/models/custom_test_model.dart';

class CustomTestService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Get the current user's ID
  String? get _userId => _auth.currentUser?.uid;

  // Save a generated test to Firestore
  Future<void> saveTest(CustomTest test) async {
    if (_userId == null) return;

    final docRef = _firestore
        .collection('users')
        .doc(_userId)
        .collection('custom_tests')
        .doc(); // Auto-generate ID

    await docRef.set(test.toFirestore());
  }

  // Retrieve all tests for the current user
  Stream<List<CustomTest>> getCustomTests() {
    if (_userId == null) return Stream.value([]);

    return _firestore
        .collection('users')
        .doc(_userId)
        .collection('custom_tests')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => CustomTest.fromFirestore(doc))
              .toList();
        });
  }

  // Fetch the full Question objects for a saved test
  Future<List<Map<String, dynamic>>> getQuestionsForTest(
    List<String> questionIds,
  ) async {
    if (questionIds.isEmpty) return [];

    final querySnapshot = await _firestore
        .collection('questions')
        .where(FieldPath.documentId, whereIn: questionIds)
        .get();

    return querySnapshot.docs.map((doc) => doc.data()).toList();
  }
}


================================================================================
FILE: lib/services/onboarding_service.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

class OnboardingService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Completes the onboarding process.
  /// If the user is a STUDENT, this runs a Transaction to safely generate a unique Student ID.
  /// If the user is a TEACHER, this performs a simple update.
  Future<void> completeOnboarding({
    required String uid,
    required String role, // 'student' or 'teacher'
    required Map<String, dynamic> profileData,
  }) async {
    final userRef = _firestore.collection('users').doc(uid);

    if (role == 'student') {
      await _handleStudentOnboarding(userRef, uid, profileData);
    } else {
      await _handleTeacherOnboarding(userRef, profileData);
    }
  }

  /// Transactional logic for Students
  Future<void> _handleStudentOnboarding(
      DocumentReference userRef,
      String uid,
      Map<String, dynamic> profileData,
      ) async {
    final optionSetsRef =
    _firestore.collection('static_data').doc('option_sets');
    final trackerRef =
    _firestore.collection('student_question_tracker').doc(uid);

    return _firestore.runTransaction((transaction) async {
      // 1. READ: Get the current ID counter
      // This read locks the document until the transaction completes
      DocumentSnapshot optionSetsSnapshot = await transaction.get(optionSetsRef);

      if (!optionSetsSnapshot.exists) {
        throw Exception("System Error: 'static_data/option_sets' not found.");
      }

      int currentId = optionSetsSnapshot.get('last_assigned_student_id') ?? 0;
      int newId = currentId + 1;

      // 2. WRITE: Update the counter
      transaction.update(optionSetsRef, {
        'last_assigned_student_id': newId,
      });

      // 3. WRITE: Update the User Profile
      transaction.update(userRef, {
        'role': 'student',
        'onboardingCompleted': true,
        'studentId': newId,
        'targetExam': profileData['targetExam'],
        'currentClass': profileData['currentClass'],
        'targetYear': profileData['targetYear'],
        // Clear teacher fields if they existed by mistake
        'teachingExams': FieldValue.delete(),
        'teachingSubjects': FieldValue.delete(),
      });

      // 4. WRITE: Create the Question Tracker
      transaction.set(trackerRef, {
        'student_id': newId,
        'assigned_history': [],
        'buckets': {
          'unattempted': [],
          'skipped': [],
          'incorrect': [],
          'correct': [],
        }
      });
    });
  }

  /// Simple update logic for Teachers
  Future<void> _handleTeacherOnboarding(
      DocumentReference userRef,
      Map<String, dynamic> profileData,
      ) async {
    await userRef.update({
      'role': 'teacher',
      'onboardingCompleted': true,
      'teachingExams': profileData['teachingExams'],
      'teachingSubjects': profileData['teachingSubjects'],
      // Clear student fields
      'studentId': FieldValue.delete(),
      'targetExam': FieldValue.delete(),
      'currentClass': FieldValue.delete(),
      'targetYear': FieldValue.delete(),
    });
  }
}

================================================================================
FILE: lib/services/teacher_service.dart
================================================================================
import 'dart:math'; // For random code generation
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:study_smart_qc/models/question_model.dart';

class TeacherService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // --- 1. STATS DASHBOARD (For Step 1) ---

  Future<Map<String, int>> getStudentStats(int studentId) async {
    final uid = await _findUidByStudentId(studentId);
    if (uid == null) return {};

    final doc = await _firestore.collection('student_question_tracker').doc(uid).get();
    if (!doc.exists) return {};

    final data = doc.data()!;
    final buckets = data['buckets'] as Map<String, dynamic>;
    final assigned = (data['assigned_history'] as List?)?.length ?? 0;

    return {
      'Assigned': assigned,
      'Unattempted': (buckets['unattempted'] as List?)?.length ?? 0,
      'Incorrect': (buckets['incorrect'] as List?)?.length ?? 0,
      'Correct': (buckets['correct'] as List?)?.length ?? 0,
      'Skipped': (buckets['skipped'] as List?)?.length ?? 0,
    };
  }

  // --- 2. ADVANCED SEARCH (For Step 2) ---

  Future<List<Question>> fetchQuestions({
    required String audienceType, // 'General', 'Particular Student'
    int? studentId,
    String? smartFilter, // 'New Questions', 'Incorrect', etc.
    String? subject,
    List<String>? chapterIds,
    List<String>? topicIds,
    int limit = 50,
  }) async {
    List<Question> candidates = [];

    // STRATEGY:
    // If Smart Filter is active (e.g., 'Incorrect'), source is the Tracker (Question IDs).
    // If General/New, source is the Questions Collection (filtered by Syllabus).

    if (audienceType == 'Particular Student' && smartFilter != null && smartFilter != 'New Questions') {
      // CASE A: Fetch from Tracker History (Incorrect, Unattempted, etc.)
      candidates = await _fetchFromTracker(studentId!, smartFilter);
    } else {
      // CASE B: Fetch from General Pool (and optionally filter out 'seen' questions)
      candidates = await _fetchFromGeneralPool(subject, chapterIds, limit);

      // If 'New Questions' for a student, exclude their history
      if (audienceType == 'Particular Student' && studentId != null) {
        final historyIds = await _getStudentHistory(studentId);
        candidates = candidates.where((q) => !historyIds.contains(q.id)).toList();
      }
    }

    // --- APPLY CLIENT-SIDE FILTERS ---
    // Firestore is limited, so we refine results here (Topic, Subject check)
    return candidates.where((q) {
      if (chapterIds != null && chapterIds.isNotEmpty && !chapterIds.contains(q.chapterId)) return false;
      if (topicIds != null && topicIds.isNotEmpty && !topicIds.contains(q.topicId)) return false;
      return true;
    }).take(limit).toList();
  }

  // --- INTERNAL HELPERS ---

  Future<List<Question>> _fetchFromTracker(int studentId, String bucketKey) async {
    final uid = await _findUidByStudentId(studentId);
    if (uid == null) return [];

    final doc = await _firestore.collection('student_question_tracker').doc(uid).get();
    if (!doc.exists) return [];

    final buckets = doc.data()!['buckets'] as Map<String, dynamic>;

    // Map UI string to DB key
    String dbKey = bucketKey.toLowerCase();
    if (bucketKey.contains('Incorrect')) dbKey = 'incorrect';
    if (bucketKey.contains('Unattempted')) dbKey = 'unattempted';
    if (bucketKey.contains('Correct')) dbKey = 'correct';
    if (bucketKey.contains('Skipped')) dbKey = 'skipped';

    final ids = List<String>.from(buckets[dbKey] ?? []);
    if (ids.isEmpty) return [];

    // Fetch actual docs (batched if > 10, but taking top 10 for MVP safety)
    final safeIds = ids.take(10).toList();
    final query = await _firestore.collection('questions').where(FieldPath.documentId, whereIn: safeIds).get();
    return query.docs.map((d) => Question.fromFirestore(d)).toList();
  }

  Future<List<Question>> _fetchFromGeneralPool(String? subject, List<String>? chapterIds, int limit) async {
    Query query = _firestore.collection('questions');

    // Optimization: If specific chapters selected, use them (max 10 for 'whereIn')
    if (chapterIds != null && chapterIds.isNotEmpty && chapterIds.length <= 10) {
      query = query.where('chapterId', whereIn: chapterIds);
    } else {
      // Fallback to purely limit-based if no chapters or too many chapters
      // In a real app, you'd filter by Subject string if it exists on the doc
    }

    final snap = await query.limit(limit * 2).get(); // Fetch extra to allow for local filtering
    return snap.docs.map((d) => Question.fromFirestore(d)).toList();
  }

  Future<Set<String>> _getStudentHistory(int studentId) async {
    final uid = await _findUidByStudentId(studentId);
    if (uid == null) return {};
    final doc = await _firestore.collection('student_question_tracker').doc(uid).get();
    if (!doc.exists) return {};
    return Set<String>.from(doc.data()!['assigned_history'] ?? []);
  }

  Future<String?> _findUidByStudentId(int studentId) async {
    final query = await _firestore.collection('users').where('studentId', isEqualTo: studentId).limit(1).get();
    if (query.docs.isEmpty) return null;
    return query.docs.first.id;
  }

  /// UPDATED ASSIGNMENT LOGIC
  Future<void> assignQuestionsToStudent({
    required int studentId,
    required List<Question> questions, // Pass full objects for metadata
    required String teacherUid,
    required String targetAudience,
    String assignmentTitle = "Teacher Assignment",
  }) async {
    final studentUid = await _findUidByStudentId(studentId);
    if (studentUid == null) throw Exception("Student not found");

    final newAssignmentRef = _firestore.collection('questions_curation').doc();
    final trackerRef = _firestore.collection('student_question_tracker').doc(studentUid);
    final batch = _firestore.batch();

    // 1. Generate Metadata
    final assignmentCode = _generateAssignmentCode();
    final questionIds = questions.map((q) => q.id).toList();

    // Note: Assuming Question model implicitly has a subject via source or chapter,
    // otherwise we rely on what's available. We will aggregate subjects here.
    // Ideally add 'subjectId' to Question model if needed explicitly.
    // For now we will try to infer or group based on existing data.
    final subjects = questions.map((q) => q.chapterId.split('_').first).toSet().toList(); // Basic inference if subjectId missing

    final hierarchy = _buildHierarchy(questions);

    // 2. Create Assignment Document
    batch.set(newAssignmentRef, {
      'assignmentId': newAssignmentRef.id,
      'assignmentCode': assignmentCode, // Unique 4-digit code
      'targetAudience': targetAudience,
      'studentUid': studentUid,
      'teacherUid': teacherUid,
      'title': assignmentTitle,
      'questionIds': questionIds,
      'createdAt': FieldValue.serverTimestamp(),
      'status': 'assigned',
      'subjects': subjects, // List of subjects involved
      'meta_hierarchy': hierarchy, // Detailed breakdown
    });

    // 3. Update Student Tracker
    batch.update(trackerRef, {
      'assigned_history': FieldValue.arrayUnion(questionIds),
      'buckets.unattempted': FieldValue.arrayUnion(questionIds),
    });

    await batch.commit();
  }

  // --- NEW HELPERS ---

  String _generateAssignmentCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final rnd = Random();
    return String.fromCharCodes(Iterable.generate(
        4, (_) => chars.codeUnitAt(rnd.nextInt(chars.length))));
  }

  Map<String, dynamic> _buildHierarchy(List<Question> questions) {
    // Structure: Exam -> Subject -> Chapter -> Topic -> Count
    Map<String, dynamic> hierarchy = {};

    for (var q in questions) {
      final exam = q.source.isEmpty ? 'Unknown Exam' : q.source;
      // If subjectId is missing in Question model, use placeholder or extract from chapter
      final subject = 'Physics'; // Hardcoded based on context, or q.subjectId if added
      final chapter = q.chapterId.isEmpty ? 'Unknown Chapter' : q.chapterId;
      final topic = q.topicId.isEmpty ? 'Unknown Topic' : q.topicId;

      hierarchy.putIfAbsent(exam, () => <String, dynamic>{});
      hierarchy[exam].putIfAbsent(subject, () => <String, dynamic>{});
      hierarchy[exam][subject].putIfAbsent(chapter, () => <String, dynamic>{});

      final currentCount = hierarchy[exam][subject][chapter][topic] ?? 0;
      hierarchy[exam][subject][chapter][topic] = currentCount + 1;
    }
    return hierarchy;
  }
}

================================================================================
FILE: lib/services/test_orchestration_service.dart
================================================================================
import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:study_smart_qc/models/attempt_item_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/models/attempt_model.dart';

class TestOrchestrationService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  String? get _userId => _auth.currentUser?.uid;

  // ===========================================================================
  // 1. HISTORY FETCH LOGIC
  // ===========================================================================

  /// Fetch attempts for a user. If [targetUserId] is provided (Mentor Mode),
  /// it fetches for that specific student. Otherwise, it defaults to the current user.
  Future<List<AttemptModel>> getUserAttempts({String? targetUserId}) async {
    final String? idToQuery = targetUserId ?? _userId;
    if (idToQuery == null) return [];

    try {
      // NOTE: Requires a Composite Index for 'userId' (Asc) and 'completedAt' (Desc)
      final snapshot = await _firestore
          .collection('attempts')
          .where('userId', isEqualTo: idToQuery)
          .orderBy('completedAt', descending: true)
          .get();

      return snapshot.docs
          .map((doc) => AttemptModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      print("Error fetching user attempts: $e");
      return [];
    }
  }

  // ===========================================================================
  // 2. UNIVERSAL SUBMISSION LOGIC (With Aggregates & Behavioral Fields)
  // ===========================================================================

  Future<void> submitAttempt({
    required String sourceId,
    required String assignmentCode,
    required String mode,
    required List<Question> questions,
    required num score,
    required int timeTakenSeconds,
    required Map<String, ResponseObject> responses,
  }) async {
    if (_userId == null) return;

    final batch = _firestore.batch();
    final timestamp = Timestamp.now();

    // 1. Calculate Aggregates
    int correctCount = 0;
    int incorrectCount = 0;
    int skippedCount = 0;

    responses.forEach((qid, response) {
      if (response.status == 'CORRECT') {
        correctCount++;
      } else if (response.status == 'INCORRECT') {
        incorrectCount++;
      } else {
        skippedCount++;
      }
    });

    final int totalQuestionsCount = questions.length;
    final int maxMarksValue = totalQuestionsCount * 4;

    // A. Create Attempt Record (The "Session" summary)
    final attemptRef = _firestore.collection('attempts').doc();
    final newAttempt = AttemptModel(
      id: attemptRef.id,
      sourceId: sourceId,
      assignmentCode: assignmentCode,
      mode: mode,
      userId: _userId!,
      startedAt: timestamp,
      completedAt: timestamp,
      score: score,
      totalQuestions: totalQuestionsCount,
      maxMarks: maxMarksValue,
      correctCount: correctCount,     // SAVED: New Aggregate
      incorrectCount: incorrectCount, // SAVED: New Aggregate
      skippedCount: skippedCount,     // SAVED: New Aggregate
      timeTakenSeconds: timeTakenSeconds,
      responses: responses,
    );
    batch.set(attemptRef, newAttempt.toFirestore());

    // B. Create Attempt Items (Question-level history)
    for (final question in questions) {
      final response = responses[question.id];
      if (response != null) {
        final attemptItemRef = _firestore.collection('attempt_items').doc(); //

        final attemptItem = AttemptItemModel(
          userId: _userId!,
          attemptRef: attemptRef, // <--- FIXED: Passing parent reference here
          questionId: question.id,
          chapterId: question.chapterId,
          topicId: question.topicId,
          status: response.status,
          timeSpent: response.timeSpent,
          attemptedAt: timestamp,
          assignmentCode: assignmentCode,
          mode: mode,
          // NEW: Support for manual categorization
          mistakeCategory: response.mistakeCategory,
          mistakeNote: response.mistakeNote,
        );

        batch.set(attemptItemRef, attemptItem.toFirestore()); //
      }
    }

    // C. Update Student Tracker (Latest Status Logic)
    final trackerRef = _firestore.collection('student_question_tracker').doc(_userId);
    final trackerDoc = await trackerRef.get();

    if (trackerDoc.exists) {
      final data = trackerDoc.data()!;
      final buckets = data['buckets'] as Map<String, dynamic>;

      List<String> unattempted = List<String>.from(buckets['unattempted'] ?? []);
      List<String> correct = List<String>.from(buckets['correct'] ?? []);
      List<String> incorrect = List<String>.from(buckets['incorrect'] ?? []);
      List<String> skipped = List<String>.from(buckets['skipped'] ?? []);
      List<String> history = List<String>.from(data['attempted_history'] ?? []);

      responses.forEach((qid, response) {
        unattempted.remove(qid);
        correct.remove(qid);
        incorrect.remove(qid);
        skipped.remove(qid);

        if (response.status == 'CORRECT') {
          correct.add(qid);
        } else if (response.status == 'INCORRECT') {
          incorrect.add(qid);
        } else {
          skipped.add(qid);
        }

        if (!history.contains(qid)) history.add(qid);
      });

      batch.update(trackerRef, {
        'buckets.unattempted': unattempted,
        'buckets.correct': correct,
        'buckets.incorrect': incorrect,
        'buckets.skipped': skipped,
        'attempted_history': history,
      });
    }

    // D. Update Assignment Status (FIXED)
    // We check 'questions_curation' instead of the legacy 'tests' collection.
    if (sourceId.isNotEmpty) {
      try {
        // First check if it's an assignment (curation)
        final assignmentRef = _firestore.collection('questions_curation').doc(sourceId);
        final assignmentDoc = await assignmentRef.get();

        if (assignmentDoc.exists) {
          // Mark as 'submitted' so it drops off the Pending list
          batch.update(assignmentRef, {'status': 'submitted'});
        } else {
          // Fallback: Check if it's a custom test (legacy support)
          final testRef = _firestore.collection('tests').doc(sourceId);
          final testDoc = await testRef.get();
          if(testDoc.exists) {
            batch.update(testRef, {'status': 'Attempted'});
          }
        }
      } catch (e) {
        print("Error updating status: $e");
      }
    }

    await batch.commit();
  }

  // ===========================================================================
  // 3. CUSTOM TEST & HELPER METHODS
  // ===========================================================================

  String _generateShareCode() {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    final rnd = Random();
    return String.fromCharCodes(
      Iterable.generate(4, (_) => chars.codeUnitAt(rnd.nextInt(chars.length))),
    );
  }

  Future<TestModel?> createAndSaveTestBlueprint({
    required List<Question> questions,
    required int durationSeconds,
    required List<String> chapterNames,
    required String testName,
  }) async {
    if (_userId == null) return null;

    String shareCode;
    bool isUnique = false;
    do {
      shareCode = _generateShareCode();
      final existing = await _firestore
          .collection('tests')
          .where('shareCode', isEqualTo: shareCode)
          .limit(1)
          .get();
      if (existing.docs.isEmpty) isUnique = true;
    } while (!isUnique);

    final testRef = _firestore.collection('tests').doc();

    final newTest = TestModel(
      id: testRef.id,
      createdBy: _userId!,
      createdAt: Timestamp.now(),
      status: 'Not Attempted',
      testName: testName,
      config: TestConfig(
        durationSeconds: durationSeconds,
        totalQuestions: questions.length,
      ),
      questionIds: questions.map((q) => q.id).toList(),
      chapters: chapterNames,
      shareCode: shareCode,
      uidsAttemptedTests: [],
    );

    await testRef.set(newTest.toFirestore());
    return newTest;
  }

  Future<void> recordTestAttempt(String testId) async {
    if (_userId == null) return;
    final batch = _firestore.batch();

    final testRef = _firestore.collection('tests').doc(testId);
    batch.update(testRef, {
      'uidsAttemptedTests': FieldValue.arrayUnion([_userId]),
    });

    final userRef = _firestore.collection('users').doc(_userId);
    batch.update(userRef, {
      'testIDsattempted': FieldValue.arrayUnion([testId]),
    });

    await batch.commit();
  }

  Future<AttemptModel?> getAttemptForTest(String testId) async {
    if (_userId == null) return null;

    final querySnapshot = await _firestore
        .collection('attempts')
        .where('sourceId', isEqualTo: testId)
        .where('userId', isEqualTo: _userId)
        .orderBy('completedAt', descending: true)
        .limit(1)
        .get();

    if (querySnapshot.docs.isNotEmpty) {
      return AttemptModel.fromFirestore(querySnapshot.docs.first);
    }

    final oldQuerySnapshot = await _firestore
        .collection('attempts')
        .where('testId', isEqualTo: testId)
        .where('userId', isEqualTo: _userId)
        .limit(1)
        .get();

    if (oldQuerySnapshot.docs.isNotEmpty) {
      return AttemptModel.fromFirestore(oldQuerySnapshot.docs.first);
    }

    return null;
  }

  Stream<List<TestModel>> getSavedTestsStream() {
    if (_userId == null) return Stream.value([]);
    return _firestore
        .collection('tests')
        .where('createdBy', isEqualTo: _userId)
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => TestModel.fromFirestore(doc)).toList());
  }

  Future<TestModel?> getTestByShareCode(String shareCode) async {
    final querySnapshot = await _firestore
        .collection('tests')
        .where('shareCode', isEqualTo: shareCode)
        .limit(1)
        .get();
    if (querySnapshot.docs.isNotEmpty) {
      return TestModel.fromFirestore(querySnapshot.docs.first);
    }
    return null;
  }

  Future<List<Question>> getQuestionsByIds(List<String> questionIds) async {
    if (questionIds.isEmpty) return [];
    final List<Question> questions = [];
    final chunks = [];
    for (var i = 0; i < questionIds.length; i += 10) {
      chunks.add(
        questionIds.sublist(
          i,
          i + 10 > questionIds.length ? questionIds.length : i + 10,
        ),
      );
    }
    for (final chunk in chunks) {
      final querySnapshot = await _firestore
          .collection('questions')
          .where(FieldPath.documentId, whereIn: chunk)
          .get();
      questions.addAll(
        querySnapshot.docs.map((doc) => Question.fromFirestore(doc)),
      );
    }
    return questions;
  }

  // ===========================================================================
  // 4. MISTAKE UPDATE LOGIC (NEW)
  // ===========================================================================

  /// Updates the mistake category and note for a specific question in an existing attempt.
  /// This updates BOTH the main 'attempts' document (nested map) AND the individual 'attempt_items' document.
  Future<void> updateQuestionMistake({
    required String attemptId,
    required String questionId,
    required String mistakeCategory,
    String? mistakeNote,
  }) async {
    if (_userId == null) return;

    try {
      final attemptRef = _firestore.collection('attempts').doc(attemptId);

      // 1. Fetch the attempt to get context (assignmentCode) needed to find the item
      final attemptSnapshot = await attemptRef.get();
      if (!attemptSnapshot.exists) return;

      final data = attemptSnapshot.data();
      // Ensure we safeguard against nulls, though assignmentCode should exist
      final String? assignmentCode = data?['assignmentCode'];

      // 2. Update the parent Attempt document (Nested Map Update)
      // Note: We use dot notation to update just the specific fields inside the responses map
      await attemptRef.update({
        'responses.$questionId.mistakeCategory': mistakeCategory,
        'responses.$questionId.mistakeNote': mistakeNote ?? '',
      });

      // 3. Update the specific Attempt Item document
      // We use assignmentCode + questionId + userId to target the specific item
      if (assignmentCode != null) {
        final itemQuery = await _firestore
            .collection('attempt_items')
            .where('userId', isEqualTo: _userId)
            .where('questionId', isEqualTo: questionId)
            .where('assignmentCode', isEqualTo: assignmentCode)
            .limit(1)
            .get();

        if (itemQuery.docs.isNotEmpty) {
          await itemQuery.docs.first.reference.update({
            'mistakeCategory': mistakeCategory,
            'mistakeNote': mistakeNote ?? '',
          });
        }
      }
    } catch (e) {
      print("Error updating mistake category: $e");
      rethrow;
    }
  }
}

================================================================================
FILE: lib/services/test_service.dart
================================================================================
import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:study_smart_qc/models/question_model.dart';

class TestService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  Future<List<Question>> generateTest({
    required Set<String> chapterIds,
    required Set<String> topicIds,
    required int questionCount,
  }) async {
    if (chapterIds.isEmpty || topicIds.isEmpty) {
      return [];
    }

    // Step 1: Fetch all questions from the selected CHAPTERS.
    QuerySnapshot querySnapshot = await _firestore
        .collection('questions')
        .where('chapterId', whereIn: chapterIds.toList())
        .get();

    List<Question> fetchedQuestions = querySnapshot.docs
        .map((doc) => Question.fromFirestore(doc))
        .toList();

    // Step 2: Locally filter those questions by the selected TOPICS.
    List<Question> filteredByTopic = fetchedQuestions
        .where((q) => topicIds.contains(q.topicId))
        .toList();

    // Step 3: Ensure questions have a valid image URL.
    List<Question> validQuestions = filteredByTopic.where((q) {
      final url = q.imageUrl;
      return url.isNotEmpty &&
          (url.startsWith('http') || url.startsWith('https'));
    }).toList();

    // Step 4: Apply 80/20 split for question types
    // CHANGED: Using Enum Comparison instead of String trim()
    final scqQuestions = validQuestions
        .where((q) => q.type == QuestionType.singleCorrect)
        .toList();

    final numericalQuestions = validQuestions
        .where((q) => q.type == QuestionType.numerical)
        .toList();

    scqQuestions.shuffle();
    numericalQuestions.shuffle();

    final numNumerical = (questionCount * 0.2).round();
    final numScq = questionCount - numNumerical;

    final finalScq = scqQuestions
        .take(min(numScq, scqQuestions.length))
        .toList();
    final finalNumerical = numericalQuestions
        .take(min(numNumerical, numericalQuestions.length))
        .toList();

    final finalTestQuestions = [...finalScq, ...finalNumerical];
    finalTestQuestions.shuffle();

    return finalTestQuestions;
  }
}

================================================================================
FILE: lib/widgets/expandable_image.dart
================================================================================
import 'package:flutter/material.dart';

class ExpandableImage extends StatelessWidget {
  final String imageUrl;

  const ExpandableImage({Key? key, required this.imageUrl}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (_) => Scaffold(
              backgroundColor: Colors.black,
              appBar: AppBar(
                backgroundColor: Colors.transparent,
                elevation: 0,
                iconTheme: const IconThemeData(color: Colors.white),
              ),
              body: Center(
                // This widget allows pinch-to-zoom
                child: InteractiveViewer(
                  panEnabled: true,
                  minScale: 0.5,
                  maxScale: 4.0,
                  child: Image.network(imageUrl), // Switch to Image.asset if local
                ),
              ),
            ),
          ),
        );
      },
      child: Image.network(imageUrl), // The thumbnail view in the question
    );
  }
}

================================================================================
FILE: lib/widgets/question_input_widget.dart
================================================================================
import 'package:flutter/material.dart';
import '../models/question_model.dart';

class QuestionInputWidget extends StatefulWidget {
  final Question question;
  final dynamic currentAnswer;
  final Function(dynamic) onAnswerChanged;

  const QuestionInputWidget({
    Key? key,
    required this.question,
    required this.currentAnswer,
    required this.onAnswerChanged,
  }) : super(key: key);

  @override
  State<QuestionInputWidget> createState() => _QuestionInputWidgetState();
}

class _QuestionInputWidgetState extends State<QuestionInputWidget> {
  late TextEditingController _textController;

  @override
  void initState() {
    super.initState();
    _textController = TextEditingController();
  }

  @override
  void didUpdateWidget(QuestionInputWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Refresh text field if the question changes or answer is externally reset
    if (widget.question.id != oldWidget.question.id || widget.currentAnswer == null) {
      _textController.text = widget.currentAnswer?.toString() ?? '';
    }
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    switch (widget.question.type) {
      case QuestionType.singleCorrect:
        return _buildSingleCorrectUI();
      case QuestionType.numerical:
        return _buildNumericalUI();
      case QuestionType.multipleCorrect:
        return _buildMultiCorrectUI();
      case QuestionType.matrixSingle:
      case QuestionType.matrixMulti:
        return _buildMatrixUI();
      default:
        return const Center(child: Text("Unknown Question Type"));
    }
  }

  // =========================================================
  // TYPE 1: SINGLE CORRECT (Radio Tiles)
  // =========================================================
  Widget _buildSingleCorrectUI() {
    final options = ['A', 'B', 'C', 'D'];
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: options.map((option) {
        final isSelected = widget.currentAnswer == option;
        return Expanded(
          child: GestureDetector(
            onTap: () => widget.onAnswerChanged(option),
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 4),
              padding: const EdgeInsets.symmetric(vertical: 16),
              decoration: BoxDecoration(
                color: isSelected ? Colors.blue : Colors.white,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                    color: isSelected ? Colors.blue : Colors.grey.shade300
                ),
              ),
              child: Center(
                child: Text(
                  option,
                  style: TextStyle(
                    color: isSelected ? Colors.white : Colors.black,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
        );
      }).toList(),
    );
  }

  // =========================================================
  // TYPE 2: NUMERICAL (Text Field)
  // =========================================================
  Widget _buildNumericalUI() {
    return TextField(
      controller: _textController,
      keyboardType: const TextInputType.numberWithOptions(decimal: true),
      decoration: const InputDecoration(
        border: OutlineInputBorder(),
        hintText: 'Enter numerical answer (e.g. 5.5)',
      ),
      onChanged: (val) => widget.onAnswerChanged(val),
    );
  }

  // =========================================================
  // TYPE 3: MULTIPLE CORRECT (Checkboxes)
  // =========================================================
  Widget _buildMultiCorrectUI() {
    final options = ['A', 'B', 'C', 'D'];
    final List<dynamic> currentSelection = (widget.currentAnswer is List)
        ? widget.currentAnswer
        : [];

    return Row(
      children: options.map((option) {
        final isSelected = currentSelection.contains(option);
        return Expanded(
          child: GestureDetector(
            onTap: () {
              List<dynamic> newSel = List.from(currentSelection);
              if (isSelected) {
                newSel.remove(option);
              } else {
                newSel.add(option);
              }
              widget.onAnswerChanged(newSel);
            },
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 4),
              padding: const EdgeInsets.symmetric(vertical: 16),
              decoration: BoxDecoration(
                color: isSelected ? Colors.green.shade100 : Colors.white,
                borderRadius: BorderRadius.circular(4),
                border: Border.all(
                    color: isSelected ? Colors.green : Colors.grey.shade300,
                    width: 2
                ),
              ),
              child: Center(child: Text(option)),
            ),
          ),
        );
      }).toList(),
    );
  }

  // =========================================================
  // TYPE 4: MATRIX MATCH (The Grid)
  // =========================================================
  Widget _buildMatrixUI() {
    // Standard JEE Matrix setup
    final rows = ['A', 'B', 'C', 'D'];
    final cols = ['P', 'Q', 'R', 'S', 'T'];

    // Safe Cast: Ensure answer is a Map. If null/wrong type, start empty.
    Map<String, List<String>> matrixAns = {};
    if (widget.currentAnswer is Map) {
      (widget.currentAnswer as Map).forEach((key, value) {
        if (value is List) {
          matrixAns[key.toString()] = List<String>.from(value);
        }
      });
    }

    return Column(
      children: [
        // 1. Header Row (Labels P, Q, R, S, T)
        Row(
          children: [
            const SizedBox(width: 40), // Empty space for row labels column
            ...cols.map((col) => Expanded(
              child: Center(
                child: Text(col, style: const TextStyle(fontWeight: FontWeight.bold)),
              ),
            )),
          ],
        ),
        const Divider(),

        // 2. The Data Rows (A, B, C, D)
        ...rows.map((rowLabel) {
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: Row(
              children: [
                // Row Label
                SizedBox(
                  width: 40,
                  child: Center(
                    child: Text(
                      rowLabel,
                      style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                    ),
                  ),
                ),

                // The Interactive Bubbles
                ...cols.map((colLabel) {
                  final rowSelections = matrixAns[rowLabel] ?? [];
                  final isSelected = rowSelections.contains(colLabel);

                  return Expanded(
                    child: GestureDetector(
                      onTap: () {
                        // Create a copy of the current row's selection to modify
                        List<String> newRowSel = List.from(rowSelections);

                        if (widget.question.type == QuestionType.matrixSingle) {
                          // LOGIC: Single Matrix (One choice per row)
                          newRowSel.clear();
                          if (!isSelected) {
                            newRowSel.add(colLabel);
                          }
                        } else {
                          // LOGIC: Multi Matrix (Multiple choices per row)
                          if (isSelected) {
                            newRowSel.remove(colLabel);
                          } else {
                            newRowSel.add(colLabel);
                          }
                        }

                        // Update the Main Map
                        Map<String, List<String>> newMatrixAns = Map.from(matrixAns);
                        newMatrixAns[rowLabel] = newRowSel;

                        // Send back to Controller
                        widget.onAnswerChanged(newMatrixAns);
                      },
                      child: Container(
                        height: 36, // Tap target size
                        margin: const EdgeInsets.all(2),
                        decoration: BoxDecoration(
                          color: isSelected ? Colors.deepPurple : Colors.grey.shade100,
                          shape: BoxShape.circle,
                          border: Border.all(
                              color: isSelected ? Colors.deepPurple : Colors.grey.shade400
                          ),
                        ),
                        child: isSelected
                            ? const Icon(Icons.check, size: 20, color: Colors.white)
                            : null,
                      ),
                    ),
                  );
                }),
              ],
            ),
          );
        }).toList(),
      ],
    );
  }
}

================================================================================
FILE: lib/widgets/question_palette.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';

class QuestionPalette extends StatelessWidget {
  final int questionCount;
  final Map<int, AnswerState> answerStates;
  final int currentQuestionIndex;
  final Function(int) onQuestionTapped;

  const QuestionPalette({
    super.key,
    required this.questionCount,
    required this.answerStates,
    required this.currentQuestionIndex,
    required this.onQuestionTapped,
  });

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      itemCount: questionCount,
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 5,
        crossAxisSpacing: 8,
        mainAxisSpacing: 8,
      ),
      itemBuilder: (context, index) {
        final state = answerStates[index] ?? AnswerState();
        final isCurrent = index == currentQuestionIndex;

        return GestureDetector(
          onTap: () => onQuestionTapped(index),
          child: Container(
            decoration: BoxDecoration(
              color: state.status.color,
              borderRadius: BorderRadius.circular(4),
              border: isCurrent ? Border.all(color: Colors.black, width: 2) : null,
            ),
            child: Center(
              child: Text(
                '${index + 1}',
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


================================================================================
FILE: lib/widgets/solution_detail_sheet.dart
================================================================================
// lib/widgets/solution_detail_sheet.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/widgets/expandable_image.dart';

class SolutionDetailSheet extends StatefulWidget {
  final TestResult result;
  final int initialIndex;
  const SolutionDetailSheet({
    super.key,
    required this.result,
    required this.initialIndex,
  });
  @override
  State<SolutionDetailSheet> createState() => _SolutionDetailSheetState();
}

class _SolutionDetailSheetState extends State<SolutionDetailSheet> {
  late final PageController _pageController;
  int _currentIndex = 0;

  @override
  void initState() {
    super.initState();
    _currentIndex = widget.initialIndex;
    _pageController = PageController(initialPage: _currentIndex);
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  String _formatDuration(int seconds) {
    if (seconds < 60) return '${seconds}s';
    final m = seconds ~/ 60;
    final s = seconds % 60;
    return '${m}m ${s}s';
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // --- HEADER ---
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: const Icon(Icons.arrow_back_ios),
                onPressed: _currentIndex > 0
                    ? () => _pageController.previousPage(
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeIn,
                )
                    : null,
              ),
              Text(
                'Solution ${_currentIndex + 1} / ${widget.result.questions.length}',
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.arrow_forward_ios),
                onPressed: _currentIndex < widget.result.questions.length - 1
                    ? () => _pageController.nextPage(
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeIn,
                )
                    : null,
              ),
            ],
          ),
        ),
        const Divider(height: 1),

        // --- BODY ---
        Expanded(
          child: PageView.builder(
            controller: _pageController,
            itemCount: widget.result.questions.length,
            onPageChanged: (index) => setState(() => _currentIndex = index),
            itemBuilder: (context, index) {
              final question = widget.result.questions[index];
              final answerState = widget.result.answerStates[index]!;
              final isCorrect = answerState.userAnswer?.trim().toLowerCase() ==
                  question.correctAnswer.trim().toLowerCase();

              final responseObj = widget.result.responses[question.id];
              final timeSpentSec = responseObj?.timeSpent ?? 0;

              return SingleChildScrollView(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // 1. Question Text
                    Text(
                      'Question ${index + 1}',
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 10),

                    // 2. Question Image
                    if (question.imageUrl.isNotEmpty)
                      Center(
                        child: Container(
                          constraints: const BoxConstraints(maxHeight: 250),
                          child: ExpandableImage(imageUrl: question.imageUrl),
                        ),
                      ),
                    const SizedBox(height: 20),

                    // 3. Time Spent
                    Container(
                      margin: const EdgeInsets.only(bottom: 12),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 10, vertical: 6),
                      decoration: BoxDecoration(
                        color: Colors.blue.shade50,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(color: Colors.blue.shade100),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.timer, size: 16, color: Colors.blue),
                          const SizedBox(width: 8),
                          const Text("Time Spent: ",
                              style: TextStyle(
                                  fontSize: 14, color: Colors.black54)),
                          Text(
                            _formatDuration(timeSpentSec),
                            style: TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                                color: Colors.blue.shade900),
                          ),
                        ],
                      ),
                    ),

                    // 4. Your Answer
                    _buildAnswerStatus(
                      'Your Answer: ${answerState.userAnswer ?? "Not Answered"}',
                      isCorrect,
                      answerState.status,
                    ),
                    const SizedBox(height: 8),

                    // 5. Correct Answer
                    _buildAnswerStatus(
                      'Correct Answer: ${question.correctAnswer}',
                      true,
                      AnswerStatus.answered,
                    ),
                    const SizedBox(height: 20),

                    // --- MOVED: Mistake Analysis Section (Step 2) ---
                    if (responseObj?.status == 'INCORRECT') ...[
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade100),
                        ),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Self Analysis',
                              style: TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                                color: Colors.red[800],
                              ),
                            ),
                            const SizedBox(height: 8),
                            _MistakeForm(
                              attemptId: widget.result.attemptId,
                              questionId: question.id,
                              initialCategory: responseObj?.mistakeCategory,
                              initialNote: responseObj?.mistakeNote,
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 20),
                    ],

                    const Divider(),
                    const SizedBox(height: 10),

                    // 6. Solution Image
                    if (question.solutionUrl != null &&
                        question.solutionUrl!.isNotEmpty)
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'Solution',
                            style: TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const SizedBox(height: 10),
                          Center(
                            child: Container(
                              constraints: const BoxConstraints(maxHeight: 300),
                              child: ExpandableImage(
                                  imageUrl: question.solutionUrl!),
                            ),
                          ),
                        ],
                      )
                    else
                      const Text("No detailed solution available.",
                          style: TextStyle(
                              fontStyle: FontStyle.italic, color: Colors.grey)),

                    const SizedBox(height: 40),
                  ],
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildAnswerStatus(String text, bool isCorrect, AnswerStatus status) {
    Color color = Colors.grey;
    IconData icon = Icons.help_outline;

    if (status == AnswerStatus.notAnswered ||
        status == AnswerStatus.notVisited) {
      color = Colors.orange;
      icon = Icons.warning_amber_rounded;
    } else if (status == AnswerStatus.answered ||
        status == AnswerStatus.answeredAndMarked) {
      color = isCorrect ? Colors.green : Colors.red;
      icon = isCorrect ? Icons.check_circle : Icons.cancel;
    }

    return Row(
      children: [
        Icon(icon, color: color, size: 20),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            text,
            style: TextStyle(color: color, fontWeight: FontWeight.bold),
          ),
        ),
      ],
    );
  }
}

// =============================================================================
// INTERNAL WIDGET: Mistake Form (Refined)
// =============================================================================
class _MistakeForm extends StatefulWidget {
  final String attemptId;
  final String questionId;
  final String? initialCategory;
  final String? initialNote;

  const _MistakeForm({
    required this.attemptId,
    required this.questionId,
    this.initialCategory,
    this.initialNote,
  });

  @override
  State<_MistakeForm> createState() => _MistakeFormState();
}

class _MistakeFormState extends State<_MistakeForm> {
  final TestOrchestrationService _service = TestOrchestrationService();
  final TextEditingController _noteController = TextEditingController();
  String? _selectedCategory;

  // REMOVED 'Other' (Step 1)
  final List<String> _categories = [
    'Conceptual Error',
    'Calculation Error',
    'Silly Mistake',
    'Time Pressure',
    'Did not understand question',
    'Guessed',
  ];

  @override
  void initState() {
    super.initState();
    _selectedCategory = widget.initialCategory;
    _noteController.text = widget.initialNote ?? '';
  }

  @override
  void dispose() {
    _noteController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          value: _categories.contains(_selectedCategory)
              ? _selectedCategory
              : null,
          hint: const Text("Why did you get this wrong?"),
          isExpanded: true,
          decoration: InputDecoration(
            contentPadding:
            const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
            filled: true,
            fillColor: Colors.white,
          ),
          items: _categories.map((cat) {
            return DropdownMenuItem(
              value: cat,
              child: Text(cat, style: const TextStyle(fontSize: 14)),
            );
          }).toList(),
          onChanged: (value) {
            setState(() {
              _selectedCategory = value;
            });
            // Update Service with Note (even if empty, passed as '')
            _service.updateQuestionMistake(
              attemptId: widget.attemptId,
              questionId: widget.questionId,
              mistakeCategory: value ?? '',
              mistakeNote: _noteController.text, // Passed directly, 'Other' field removed
            );
          },
        ),
      ],
    );
  }
}

================================================================================
FILE: lib/widgets/test_configuration_bottom_sheet.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_preview_screen.dart';
import 'package:study_smart_qc/services/test_service.dart';

class TestConfigurationBottomSheet extends StatefulWidget {
  final Set<String> chapterIds;
  final Map<String, String> chapterIdToNameMap;
  final Set<String> topicIds;
  final Map<String, String> topicIdToNameMap;
  final Map<String, Map<String, String>> chapterIdToTopicsMap;

  const TestConfigurationBottomSheet({
    super.key,
    required this.chapterIds,
    required this.topicIds,
    required this.chapterIdToNameMap,
    required this.topicIdToNameMap,
    required this.chapterIdToTopicsMap, // FIX: Added required parameter
  });

  @override
  State<TestConfigurationBottomSheet> createState() =>
      _TestConfigurationBottomSheetState();
}

class _TestConfigurationBottomSheetState
    extends State<TestConfigurationBottomSheet> {
  int _selectedQuestionCount = 15;
  late int _timeInMinutes;
  final List<int> _questionCountOptions = [10, 15, 20, 30];
  bool _isCustom = false;
  final TextEditingController _customCountController = TextEditingController();
  late final TextEditingController _testNameController;
  bool _isGeneratingTest = false;

  @override
  void initState() {
    super.initState();
    _timeInMinutes = _selectedQuestionCount * 2;
    _customCountController.text = '45';
    final defaultChapterName = widget.chapterIds.isNotEmpty
        ? widget.chapterIdToNameMap[widget.chapterIds.first]
        : 'Custom';
    _testNameController = TextEditingController(
      text: 'P - $defaultChapterName Test',
    );
  }

  @override
  void dispose() {
    _customCountController.dispose();
    _testNameController.dispose();
    super.dispose();
  }

  void _updateQuestionCount(int? count) {
    setState(() {
      _isCustom = count == null;
      if (!_isCustom) {
        _selectedQuestionCount = count!;
      } else {
        _selectedQuestionCount =
            int.tryParse(_customCountController.text) ?? 45;
      }
      _timeInMinutes = _selectedQuestionCount * 2;
    });
  }

  void _onCustomCountChanged(String value) {
    setState(() {
      _selectedQuestionCount = int.tryParse(value) ?? _selectedQuestionCount;
      _timeInMinutes = _selectedQuestionCount * 2;
    });
  }

  void _adjustTime(int delta) {
    setState(() {
      _timeInMinutes = (_timeInMinutes + delta).clamp(5, 180);
    });
  }

  Future<void> _generateAndPreviewTest() async {
    setState(() => _isGeneratingTest = true);

    final service = TestService();
    final questions = await service.generateTest(
      chapterIds: widget.chapterIds,
      topicIds: widget.topicIds,
      questionCount: _selectedQuestionCount,
    );

    if (!mounted) return;
    setState(() => _isGeneratingTest = false);

    if (questions.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No questions found for the selected topics.'),
          backgroundColor: Colors.red,
        ),
      );
      Navigator.pop(context);
      return;
    }

    final Map<String, List<String>> selectedSyllabus = {};
    for (String chapId in widget.chapterIds) {
      final chapterName = widget.chapterIdToNameMap[chapId]!;
      final List<String> selectedTopicsInChapter = [];

      final questionTopicIdsForThisChapter = questions
          .where((q) => q.chapterId == chapId)
          .map((q) => q.topicId)
          .toSet();

      for (var topicId in questionTopicIdsForThisChapter) {
        final topicName = widget.topicIdToNameMap[topicId];
        if (topicName != null && !selectedTopicsInChapter.contains(topicName)) {
          selectedTopicsInChapter.add(topicName);
        }
      }

      if (selectedTopicsInChapter.isNotEmpty) {
        selectedSyllabus[chapterName] = selectedTopicsInChapter;
      }
    }

    Navigator.pop(context);
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TestPreviewScreen(
          questions: questions,
          timeLimitInMinutes: _timeInMinutes,
          selectedSyllabus: selectedSyllabus,
          testName: _testNameController.text,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      child: Container(
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Configure Your Test',
              style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            TextField(
              controller: _testNameController,
              decoration: const InputDecoration(
                labelText: 'Test Name',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 20),
            const Text(
              'Number of Questions:',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 10),
            Wrap(
              spacing: 10,
              children: [
                ..._questionCountOptions.map((count) {
                  return ChoiceChip(
                    label: Text('$count'),
                    selected: !_isCustom && _selectedQuestionCount == count,
                    onSelected: (_) => _updateQuestionCount(count),
                  );
                }).toList(),
                ChoiceChip(
                  label: const Text('Custom'),
                  selected: _isCustom,
                  onSelected: (_) => _updateQuestionCount(null),
                ),
              ],
            ),
            if (_isCustom)
              Padding(
                padding: const EdgeInsets.only(top: 10.0),
                child: TextField(
                  controller: _customCountController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                    labelText: 'Enter number of questions',
                    border: OutlineInputBorder(),
                  ),
                  onChanged: _onCustomCountChanged,
                ),
              ),
            const SizedBox(height: 20),
            const Text(
              'Time Limit:',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 10),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  icon: const Icon(Icons.remove_circle_outline),
                  onPressed: () => _adjustTime(-5),
                ),
                Text(
                  '$_timeInMinutes mins',
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.add_circle_outline),
                  onPressed: () => _adjustTime(5),
                ),
              ],
            ),
            const SizedBox(height: 20),
            SizedBox(
              width: double.infinity,
              child: _isGeneratingTest
                  ? const Center(child: CircularProgressIndicator())
                  : ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurple,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 16),
                      ),
                      onPressed: _generateAndPreviewTest,
                      child: const Text(
                        'Generate Test',
                        style: TextStyle(fontSize: 18),
                      ),
                    ),
            ),
          ],
        ),
      ),
    );
  }
}


