--- PROJECT STRUCTURE SUMMARY ---
ðŸ“‚ (Root Config Files)
   ðŸ“„ pubspec.yaml
   ðŸ“„ ios/Runner/Info.plist

ðŸ“‚ lib/
   ðŸ“„ main.dart

ðŸ“‚ lib/features/analytics/screens/
   ðŸ“„ analysis_screen.dart
   ðŸ“„ results_screen.dart
   ðŸ“„ test_history_screen.dart

ðŸ“‚ lib/features/analytics/widgets/
   ðŸ“„ attempt_display_card.dart
   ðŸ“„ attempt_list_widget.dart

ðŸ“‚ lib/features/auth/screens/
   ðŸ“„ auth_page.dart
   ðŸ“„ auth_wrapper.dart
   ðŸ“„ login_screen.dart
   ðŸ“„ onboarding_screen.dart
   ðŸ“„ register_screen.dart

ðŸ“‚ lib/features/common/widgets/
   ðŸ“„ question_preview_card.dart

ðŸ“‚ lib/features/home/screens/
   ðŸ“„ home_screen.dart

ðŸ“‚ lib/features/student/widgets/
   ðŸ“„ student_assignments_list.dart

ðŸ“‚ lib/features/teacher/screens/
   ðŸ“„ curation_management_screen.dart
   ðŸ“„ teacher_curation_screen.dart
   ðŸ“„ teacher_filter_screen.dart
   ðŸ“„ teacher_history_screen.dart

ðŸ“‚ lib/features/test_creation/screens/
   ðŸ“„ custom_test_history_screen.dart
   ðŸ“„ syllabus_screen.dart

ðŸ“‚ lib/features/test_taking/screens/
   ðŸ“„ enter_code_screen.dart
   ðŸ“„ test_preview_screen.dart
   ðŸ“„ test_screen.dart

ðŸ“‚ lib/models/
   ðŸ“„ attempt_item_model.dart
   ðŸ“„ attempt_model.dart
   ðŸ“„ custom_test_model.dart
   ðŸ“„ nta_test_models.dart
   ðŸ“„ question_model.dart
   ðŸ“„ test_enums.dart
   ðŸ“„ test_model.dart
   ðŸ“„ test_result.dart
   ðŸ“„ user_model.dart

ðŸ“‚ lib/Screens/teacher/
   ðŸ“„ curation_management_screen.dart

ðŸ“‚ lib/services/
   ðŸ“„ auth_service.dart
   ðŸ“„ custom_test_service.dart
   ðŸ“„ local_session_service.dart
   ðŸ“„ onboarding_service.dart
   ðŸ“„ teacher_service.dart
   ðŸ“„ test_orchestration_service.dart
   ðŸ“„ test_service.dart

ðŸ“‚ lib/utils/
   ðŸ“„ performance_analysis_utils.dart

ðŸ“‚ lib/widgets/
   ðŸ“„ expandable_image.dart
   ðŸ“„ question_input_widget.dart
   ðŸ“„ question_palette.dart
   ðŸ“„ solution_detail_sheet.dart
   ðŸ“„ student_lookup_sheet.dart
   ðŸ“„ test_configuration_bottom_sheet.dart
   ðŸ“„ timer_hms.dart

Total Source Files: 50
--------------------------------------------------
--- FILE CONTENTS ---

================================================================================
FILE: pubspec.yaml
================================================================================
name: study_smart_qc
description: "A new Flutter project."
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^1.0.8
  shared_preferences: ^2.2.2
  firebase_core: ^4.3.0
  cloud_firestore: ^6.1.1
  firebase_auth: ^6.1.3
  google_sign_in: 6.2.1
  fl_chart: ^0.68.0
  intl: ^0.19.0
  provider: ^6.1.5+1

dev_dependencies:
  flutter_test:
    sdk: flutter

  flutter_lints: ^6.0.0
  flutter_native_splash: "^2.3.10"
  flutter_launcher_icons: "^0.13.1"

flutter_native_splash:
  color: "#FFFFFF"
  image: assets/splash_bg.png
  android_12:
    image: assets/splash_bg.png

flutter_launcher_icons:
  android: "launcher_icon"
  ios: true
  image_path: "assets/app_icon.png"
  adaptive_icon_background: "#FFFFFF"

flutter:
  uses-material-design: true

  assets:
    - assets/google_logo.png
    - assets/app_icon.png
    - assets/splash_bg.png

================================================================================
FILE: ios/Runner/Info.plist
================================================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>CFBundleDevelopmentRegion</key>
		<string>$(DEVELOPMENT_LANGUAGE)</string>
		<key>CFBundleDisplayName</key>
		<string>Study Smart Qc</string>
		<key>CFBundleExecutable</key>
		<string>$(EXECUTABLE_NAME)</string>
		<key>CFBundleIdentifier</key>
		<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
		<key>CFBundleInfoDictionaryVersion</key>
		<string>6.0</string>
		<key>CFBundleName</key>
		<string>study_smart_qc</string>
		<key>CFBundlePackageType</key>
		<string>APPL</string>
		<key>CFBundleShortVersionString</key>
		<string>$(FLUTTER_BUILD_NAME)</string>
		<key>CFBundleSignature</key>
		<string>????</string>
		<key>CFBundleVersion</key>
		<string>$(FLUTTER_BUILD_NUMBER)</string>
		<key>LSRequiresIPhoneOS</key>
		<true/>
		<key>UILaunchStoryboardName</key>
		<string>LaunchScreen</string>
		<key>UIMainStoryboardFile</key>
		<string>Main</string>
		<key>UISupportedInterfaceOrientations</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>UISupportedInterfaceOrientations~ipad</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationPortraitUpsideDown</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>CADisableMinimumFrameDurationOnPhone</key>
		<true/>
		<key>UIApplicationSupportsIndirectInputEvents</key>
		<true/>
		<key>UIStatusBarHidden</key>
		<false/>
	</dict>
</plist>


================================================================================
FILE: lib/main.dart
================================================================================
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/auth/screens/auth_page.dart';
import 'package:study_smart_qc/features/auth/screens/auth_wrapper.dart';
import 'firebase_options.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'StudySmart',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      // DIAGNOSTIC: We access FirebaseAuth directly here to ensure the stream is valid.
      home: StreamBuilder<User?>(
        stream: FirebaseAuth.instance.authStateChanges(),
        builder: (context, snapshot) {

          // DIAGNOSTIC LOGS: Check your Debug Console for these lines
          if (snapshot.connectionState == ConnectionState.waiting) {
            print("--- AUTH STREAM: WAITING ---");
            return const Scaffold(body: Center(child: CircularProgressIndicator()));
          }

          if (snapshot.hasError) {
            print("--- AUTH STREAM: ERROR: ${snapshot.error} ---");
            return Scaffold(
              body: Center(child: Text("Auth Error: ${snapshot.error}")),
            );
          }

          if (snapshot.hasData && snapshot.data != null) {
            print("--- AUTH STREAM: USER LOGGED IN (${snapshot.data!.uid}) ---");
            print("--- NAVIGATING TO AUTH WRAPPER ---");
            // Successful Login -> Switch to Wrapper
            return AuthWrapper(firebaseUser: snapshot.data!);
          }

          print("--- AUTH STREAM: NO USER (Showing AuthPage) ---");
          // No User -> Show Login/Register
          return const AuthPage();
        },
      ),
    );
  }
}

================================================================================
FILE: lib/features/analytics/screens/analysis_screen.dart
================================================================================
// lib/features/analytics/screens/analysis_screen.dart

import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/analytics/widgets/attempt_list_widget.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class AnalysisScreen extends StatefulWidget {
  final String? targetStudentUid; // The specific student to view (optional)

  const AnalysisScreen({super.key, this.targetStudentUid});

  @override
  State<AnalysisScreen> createState() => _AnalysisScreenState();
}

class _AnalysisScreenState extends State<AnalysisScreen> {
  bool _isTeacher = false;
  bool _isLoadingRole = true;

  @override
  void initState() {
    super.initState();
    _checkRole();
  }

  Future<void> _checkRole() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      try {
        final doc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
        if (mounted) {
          setState(() {
            _isTeacher = doc.data()?['role'] == 'teacher';
            _isLoadingRole = false;
          });
        }
      } catch (e) {
        if (mounted) setState(() => _isLoadingRole = false);
      }
    } else {
      if (mounted) setState(() => _isLoadingRole = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoadingRole) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    // --- TEACHER GUARD ---
    // Condition: I am a Teacher AND I did not come from the Drawer (targetStudentUid is null)
    if (_isTeacher && widget.targetStudentUid == null) {
      return Scaffold(
        appBar: AppBar(
          title: const Text("Analysis"),
          automaticallyImplyLeading: false, // Hide back button on main tab
        ),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(32.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.admin_panel_settings_outlined, size: 80, color: Colors.grey[400]),
                const SizedBox(height: 24),
                const Text(
                  "Teacher Mode",
                  style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 12),
                const Text(
                  "To view student analytics, please open the Side Drawer and select 'Check Student Performance'.",
                  textAlign: TextAlign.center,
                  style: TextStyle(fontSize: 16, color: Colors.grey),
                ),
              ],
            ),
          ),
        ),
      );
    }

    // --- NORMAL VIEW ---
    // (For Students OR Teachers who passed the Guard)
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: Text(
            widget.targetStudentUid != null ? "Student Analysis" : "Performance Analysis",
            style: const TextStyle(fontWeight: FontWeight.bold),
          ),
          centerTitle: false,
          elevation: 0,
          bottom: const TabBar(
            labelColor: Colors.deepPurple,
            unselectedLabelColor: Colors.grey,
            indicatorColor: Colors.deepPurple,
            tabs: [
              Tab(icon: Icon(Icons.school_outlined), text: "Assignments"),
              Tab(icon: Icon(Icons.timer_outlined), text: "Tests"),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            // Tab 1: Practice
            AttemptListWidget(
              filterMode: 'Practice',
              targetUserId: widget.targetStudentUid, // Pass the ID down
            ),
            // Tab 2: Tests
            AttemptListWidget(
              filterMode: 'Test',
              targetUserId: widget.targetStudentUid, // Pass the ID down
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/analytics/screens/results_screen.dart
================================================================================
// lib/features/analytics/screens/results_screen.dart

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/widgets/solution_detail_sheet.dart';

class ResultsScreen extends StatefulWidget {
  final TestResult result;

  const ResultsScreen({super.key, required this.result});

  @override
  State<ResultsScreen> createState() => _ResultsScreenState();
}

class _ResultsScreenState extends State<ResultsScreen> {
  // Stats
  int marksObtained = 0;
  double accuracy = 0.0;
  double attemptPercentage = 0.0;

  // Consistent ordering for behavioral analysis
  final List<String> _behavioralOrder = [
    "Perfect Attempt",
    "Overtime Correct",
    "Careless Mistake",
    "Wasted Attempt",
    "Good Skip",
    "Time Wasted"
  ];

  // Basic Categories
  List<int> correctIndices = [];
  List<int> incorrectIndices = [];
  List<int> skippedIndices = [];
  List<int> reviewIndices = [];

  // Smart Analysis Categories
  final Map<String, List<int>> _smartAnalysisGroups = {
    "Perfect Attempt": [],
    "Overtime Correct": [],
    "Careless Mistake": [],
    "Wasted Attempt": [],
    "Good Skip": [],
    "Time Wasted": [],
  };

  // Friendly coaching descriptions
  final Map<String, String> _categoryDescriptions = {
    "Perfect Attempt": "You nailed it! Correct answer within ideal time.",
    "Overtime Correct": "Correct, but took longer than ideal.",
    "Careless Mistake": "Answered quickly but incorrect. Slow down!",
    "Wasted Attempt": "Spent too much time and still got it wrong.",
    "Good Skip": "Smart move. Skipped a tough one quickly.",
    "Time Wasted": "Spent too long before deciding to skip.",
  };

  @override
  void initState() {
    super.initState();
    _calculateResults();
  }

  void _calculateResults() {
    correctIndices.clear();
    incorrectIndices.clear();
    skippedIndices.clear();
    reviewIndices.clear();

    for (var key in _smartAnalysisGroups.keys) {
      _smartAnalysisGroups[key] = [];
    }

    int tempCorrectCount = 0;
    int tempIncorrectCount = 0;

    for (int i = 0; i < widget.result.questions.length; i++) {
      final question = widget.result.questions[i];
      final qId = question.id;

      String basicStatus = 'SKIPPED';

      if (widget.result.responses.containsKey(qId)) {
        basicStatus = widget.result.responses[qId]!.status;
      } else {
        final state = widget.result.answerStates[i];
        if (state?.status == AnswerStatus.answered || state?.status == AnswerStatus.answeredAndMarked) {
          final isCorrect = state?.userAnswer?.trim().toLowerCase() == question.correctAnswer.trim().toLowerCase();
          basicStatus = isCorrect ? 'CORRECT' : 'INCORRECT';
        } else if (state?.status == AnswerStatus.markedForReview) {
          basicStatus = 'REVIEW';
        }
      }

      switch (basicStatus) {
        case 'CORRECT':
          correctIndices.add(i);
          tempCorrectCount++;
          break;
        case 'INCORRECT':
          incorrectIndices.add(i);
          tempIncorrectCount++;
          break;
        case 'REVIEW':
          reviewIndices.add(i);
          skippedIndices.add(i);
          break;
        default:
          skippedIndices.add(i);
          break;
      }

      if (widget.result.responses.containsKey(qId)) {
        final response = widget.result.responses[qId]!;
        final tag = response.smartTimeAnalysis;

        for (var key in _behavioralOrder) {
          if (tag.contains(key)) {
            _smartAnalysisGroups[key]!.add(i);
            break;
          }
        }
      }
    }

    setState(() {
      int totalAttempted = tempCorrectCount + tempIncorrectCount;
      marksObtained = (tempCorrectCount * 4) - (tempIncorrectCount * 1);
      accuracy = (totalAttempted > 0) ? (tempCorrectCount / totalAttempted) * 100 : 0.0;
      attemptPercentage = (widget.result.questions.isNotEmpty)
          ? (totalAttempted / widget.result.questions.length) * 100
          : 0.0;
    });
  }

  void _showSolutionSheet(int initialIndex) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        return SizedBox(
          height: MediaQuery.of(context).size.height * 0.9,
          child: SolutionDetailSheet(
            result: widget.result,
            initialIndex: initialIndex,
          ),
        );
      },
    );
  }

  // --- HELPERS ---

  /// Standard Card Decoration (Grey Border)
  BoxDecoration get _standardCardDecoration => BoxDecoration(
    color: Colors.white,
    borderRadius: BorderRadius.circular(16),
    border: Border.all(color: Colors.grey.shade300, width: 1.5),
    boxShadow: [
      BoxShadow(
        color: Colors.black.withOpacity(0.05),
        blurRadius: 10,
        offset: const Offset(0, 4),
      ),
    ],
  );

  String _formatDurationCompact(int totalSeconds) {
    if (totalSeconds == 0) return "0s";
    final duration = Duration(seconds: totalSeconds);
    if (totalSeconds < 60) {
      return "${totalSeconds}s";
    } else if (totalSeconds < 3600) {
      int m = duration.inMinutes;
      int s = totalSeconds % 60;
      return s > 0 ? "${m}m ${s}s" : "${m}m";
    } else {
      int h = duration.inHours;
      int m = duration.inMinutes % 60;
      return m > 0 ? "${h}h ${m}m" : "${h}h";
    }
  }

  String _formatSecondsDetailed(int totalSeconds) {
    if (totalSeconds < 60) return "${totalSeconds}s";
    int m = totalSeconds ~/ 60;
    int s = totalSeconds % 60;
    return '${m}m ${s}s';
  }

  Color _getSmartColor(String category) {
    switch (category) {
      case "Perfect Attempt": return Colors.green.shade700;
      case "Overtime Correct": return Colors.green.shade400;
      case "Careless Mistake": return Colors.red.shade300;
      case "Wasted Attempt": return Colors.red.shade800;
      case "Good Skip": return Colors.grey.shade400;
      case "Time Wasted": return Colors.grey.shade600;
      default: return Colors.blue;
    }
  }

  ({Color bar, Color text}) _getDynamicColors(double score, double max) {
    if (score < 0) return (bar: const Color(0xFFD32F2F), text: const Color(0xFFB71C1C));
    if (max == 0) return (bar: Colors.grey, text: Colors.grey.shade700);

    final double percentage = (score / max).clamp(0.0, 1.0);
    Color color;

    if (percentage < 0.4) {
      final t = percentage / 0.4;
      color = Color.lerp(Colors.deepOrange, Colors.orange, t)!;
    } else if (percentage < 0.75) {
      final t = (percentage - 0.4) / 0.35;
      color = Color.lerp(Colors.orange, Colors.lightGreen.shade600, t)!;
    } else {
      final t = (percentage - 0.75) / 0.25;
      color = Color.lerp(Colors.green, const Color(0xFF1B5E20), t)!;
    }

    final HSLColor hsl = HSLColor.fromColor(color);
    final Color textColor = hsl.withLightness((hsl.lightness - 0.15).clamp(0.0, 1.0)).toColor();
    return (bar: color, text: textColor);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFFAFAFA),
      appBar: AppBar(
        title: const Text('Test Analysis'),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.of(context).popUntil((route) => route.isFirst),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Score Card
            _buildScoreCard(),
            const SizedBox(height: 24),

            // Stats Row
            _buildStatsRow(),
            const SizedBox(height: 32),

            // Charts
            _buildHeader("# Questions by Result"),
            _buildPerformanceDistributionChart(),
            const SizedBox(height: 32),

            _buildHeader("Time spent by Result"),
            _buildTimeSpentByResultChart(),
            const SizedBox(height: 32),

            _buildHeader("# Questions by Behavior"),
            _buildSmartAnalysisChart(),
            const SizedBox(height: 32),

            _buildHeader("Time spent by Behavior"),
            _buildTimeSpentByBehaviorChart(),
            const SizedBox(height: 32),

            // Detailed List
            _buildHeader("Questions Breakdown"),
            _buildSmartAnalysisList(),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: Text(
        title,
        textAlign: TextAlign.center,
        style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.deepPurple),
      ),
    );
  }

  // --- SCORE CARD ---
  Widget _buildScoreCard() {
    final double maxScore = widget.result.totalMarks.toDouble();
    final double score = marksObtained.toDouble();
    final themeColors = _getDynamicColors(score, maxScore);
    double scorePercentage = (maxScore == 0) ? 0 : (score.abs() / maxScore).clamp(0.0, 1.0);

    return Container(
      decoration: _standardCardDecoration,
      padding: const EdgeInsets.all(24.0),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text('Score', style: TextStyle(fontSize: 24, fontWeight: FontWeight.w800, color: Colors.black)),
              Text('$marksObtained / ${widget.result.totalMarks}', style: TextStyle(fontSize: 28, fontWeight: FontWeight.w800, color: themeColors.text)),
            ],
          ),
          const SizedBox(height: 16),
          ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: LinearProgressIndicator(
              value: scorePercentage,
              backgroundColor: Colors.grey.shade100,
              color: themeColors.bar,
              minHeight: 12,
            ),
          ),
        ],
      ),
    );
  }

  // --- STATS ROW ---
  Widget _buildStatsRow() {
    return Row(
      children: [
        _buildStatCard(
          title: 'Accuracy',
          value: '${accuracy.toStringAsFixed(0)}%',
          percentage: accuracy / 100,
          color: Colors.blue,
          icon: Icons.gps_fixed,
        ),
        const SizedBox(width: 16),
        _buildStatCard(
          title: 'Attempt %',
          value: '${attemptPercentage.toStringAsFixed(0)}%',
          percentage: attemptPercentage / 100,
          color: Colors.orange,
          icon: Icons.checklist,
        ),
        const SizedBox(width: 16),
        _buildStatCard(
          title: 'Time Taken',
          value: _formatDurationCompact(widget.result.timeTaken.inSeconds),
          percentage: 1.0,
          color: Colors.purple,
          icon: Icons.timer_outlined,
        ),
      ],
    );
  }

  Widget _buildStatCard({
    required String title,
    required String value,
    required double percentage,
    required Color color,
    required IconData icon,
  }) {
    return Expanded(
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 24.0, horizontal: 16.0),
        decoration: _standardCardDecoration,
        child: Column(
          children: [
            Icon(icon, size: 32, color: color),
            const SizedBox(height: 16),
            Text(title, style: TextStyle(fontSize: 12, color: Colors.grey[500], fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            FittedBox(
              fit: BoxFit.scaleDown,
              child: Text(value, style: const TextStyle(fontWeight: FontWeight.w800, fontSize: 20)),
            ),
            const SizedBox(height: 16),
            ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: LinearProgressIndicator(
                value: percentage.clamp(0.0, 1.0),
                backgroundColor: color.withOpacity(0.1),
                color: color,
                minHeight: 6,
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- CHARTS ---

  Widget _buildPerformanceDistributionChart() {
    int total = widget.result.questions.length;
    return Container(
      decoration: _standardCardDecoration,
      padding: const EdgeInsets.all(24.0),
      child: Column(
        children: [
          SizedBox(
            height: 200,
            child: Stack(
              alignment: Alignment.center,
              children: [
                PieChart(
                  PieChartData(
                    sectionsSpace: 2,
                    centerSpaceRadius: 40,
                    startDegreeOffset: 270,
                    sections: [
                      _buildSection(correctIndices.length.toDouble(), '${correctIndices.length}', Colors.green),
                      _buildSection(incorrectIndices.length.toDouble(), '${incorrectIndices.length}', Colors.red),
                      _buildSection(skippedIndices.length.toDouble(), '${skippedIndices.length}', Colors.grey.shade300, textColor: Colors.black54),
                    ],
                  ),
                ),
                FittedBox(
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text(
                        "$total",
                        style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.black87)
                    ),
                  ),
                )
              ],
            ),
          ),
          const SizedBox(height: 24),
          Wrap(
            spacing: 16, runSpacing: 8, alignment: WrapAlignment.center,
            children: [
              _buildLegendItem(Colors.green, 'Correct'),
              _buildLegendItem(Colors.red, 'Incorrect'),
              _buildLegendItem(Colors.grey.shade300, 'Unattempted'),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTimeSpentByResultChart() {
    final Map<String, int> timeMap = {"CORRECT": 0, "INCORRECT": 0, "SKIPPED": 0};
    for (var resp in widget.result.responses.values) {
      String status = (resp.status == "REVIEW") ? "SKIPPED" : resp.status;
      timeMap[status] = (timeMap[status] ?? 0) + resp.timeSpent;
    }
    final total = timeMap.values.fold(0, (sum, item) => sum + item);

    return Container(
      decoration: _standardCardDecoration,
      padding: const EdgeInsets.all(24.0),
      child: Column(
        children: [
          SizedBox(
            height: 200,
            child: total == 0 ? const Center(child: Text("No data")) : Stack(
              alignment: Alignment.center,
              children: [
                PieChart(
                  PieChartData(
                    sectionsSpace: 2, centerSpaceRadius: 40, startDegreeOffset: 270,
                    sections: [
                      _buildTimeSection(timeMap["CORRECT"]!, total, Colors.green),
                      _buildTimeSection(timeMap["INCORRECT"]!, total, Colors.red),
                      _buildTimeSection(timeMap["SKIPPED"]!, total, Colors.grey.shade300, textColor: Colors.black54),
                    ],
                  ),
                ),
                FittedBox(
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text(
                        _formatDurationCompact(total),
                        style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Colors.black87)
                    ),
                  ),
                )
              ],
            ),
          ),
          const SizedBox(height: 24),
          Wrap(
            spacing: 16, runSpacing: 8, alignment: WrapAlignment.center,
            children: [
              _buildLegendItem(Colors.green, 'Correct (${_formatSecondsDetailed(timeMap["CORRECT"]!)})'),
              _buildLegendItem(Colors.red, 'Incorrect (${_formatSecondsDetailed(timeMap["INCORRECT"]!)})'),
              _buildLegendItem(Colors.grey.shade300, 'Skipped (${_formatSecondsDetailed(timeMap["SKIPPED"]!)})'),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSmartAnalysisChart() {
    List<PieChartSectionData> sections = [];
    int totalCount = 0;
    for (var key in _behavioralOrder) {
      final count = _smartAnalysisGroups[key]!.length;
      if (count > 0) {
        sections.add(_buildSection(count.toDouble(), '$count', _getSmartColor(key)));
        totalCount += count;
      }
    }

    if (sections.isEmpty) return Container(decoration: _standardCardDecoration, padding: const EdgeInsets.all(20), child: const Center(child: Text("No behavioral data")));

    return Container(
      decoration: _standardCardDecoration,
      padding: const EdgeInsets.all(24.0),
      child: Column(
        children: [
          SizedBox(
            height: 200,
            child: Stack(
              alignment: Alignment.center,
              children: [
                PieChart(
                  PieChartData(
                    sectionsSpace: 2, centerSpaceRadius: 40, startDegreeOffset: 270,
                    sections: sections,
                  ),
                ),
                FittedBox(
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text(
                        "$totalCount",
                        style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.black87)
                    ),
                  ),
                )
              ],
            ),
          ),
          const SizedBox(height: 24),
          Wrap(
            spacing: 12, runSpacing: 8, alignment: WrapAlignment.center,
            children: _behavioralOrder
                .where((key) => _smartAnalysisGroups[key]!.isNotEmpty)
                .map((key) => _buildLegendItem(_getSmartColor(key), key))
                .toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildTimeSpentByBehaviorChart() {
    Map<String, int> timeMap = {};
    for (var resp in widget.result.responses.values) {
      String tag = resp.smartTimeAnalysis.split(' (').first.trim();
      if (tag.isNotEmpty) timeMap[tag] = (timeMap[tag] ?? 0) + resp.timeSpent;
    }

    final total = timeMap.values.fold(0, (sum, item) => sum + item);
    List<PieChartSectionData> sections = [];

    for (var key in _behavioralOrder) {
      final time = timeMap[key] ?? 0;
      if (time > 0) {
        sections.add(_buildTimeSection(time, total, _getSmartColor(key)));
      }
    }

    return Container(
      decoration: _standardCardDecoration,
      padding: const EdgeInsets.all(24.0),
      child: Column(
        children: [
          SizedBox(
            height: 200,
            child: total == 0 ? const Center(child: Text("No data")) : Stack(
              alignment: Alignment.center,
              children: [
                PieChart(
                  PieChartData(
                    sectionsSpace: 2, centerSpaceRadius: 40, startDegreeOffset: 270,
                    sections: sections,
                  ),
                ),
                FittedBox(
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text(
                        _formatDurationCompact(total),
                        style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Colors.black87)
                    ),
                  ),
                )
              ],
            ),
          ),
          const SizedBox(height: 24),
          Wrap(
            spacing: 12, runSpacing: 8, alignment: WrapAlignment.center,
            children: _behavioralOrder
                .where((key) => (timeMap[key] ?? 0) > 0)
                .map((key) => _buildLegendItem(_getSmartColor(key), '$key (${_formatSecondsDetailed(timeMap[key] ?? 0)})'))
                .toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildSmartAnalysisList() {
    return Column(
      children: _behavioralOrder.map((key) {
        final indices = _smartAnalysisGroups[key] ?? [];
        if (indices.isEmpty) return const SizedBox.shrink();
        final color = _getSmartColor(key);

        return Container(
          margin: const EdgeInsets.only(bottom: 16),
          // SPECIFIC DECORATION FOR LIST ITEMS
          // White background, Colored Border (2.0 width), Soft Shadow
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: color, width: 2.0),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: const EdgeInsets.all(20.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(Icons.label, size: 20, color: color), // COLORED ICON
                  const SizedBox(width: 12),
                  Text(key, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: Colors.black87)),
                  const Spacer(),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                    decoration: BoxDecoration(color: color.withOpacity(0.1), borderRadius: BorderRadius.circular(12)),
                    child: Text("${indices.length}", style: TextStyle(color: color, fontWeight: FontWeight.bold, fontSize: 12)),
                  )
                ],
              ),
              const SizedBox(height: 12),
              Text(
                  _categoryDescriptions[key] ?? "",
                  style: TextStyle(fontSize: 13, color: Colors.grey.shade600, height: 1.5)
              ),
              const SizedBox(height: 16),
              Wrap(
                spacing: 8, runSpacing: 8,
                children: indices.map((idx) => GestureDetector(
                  onTap: () => _showSolutionSheet(idx),
                  child: Container(
                    width: 44, height: 34, alignment: Alignment.center,
                    decoration: BoxDecoration(
                        color: Colors.white,
                        border: Border.all(color: color.withOpacity(0.5)),
                        borderRadius: BorderRadius.circular(8),
                        boxShadow: [BoxShadow(color: color.withOpacity(0.05), blurRadius: 2, offset: const Offset(0, 1))]
                    ),
                    child: Text("Q${idx + 1}", style: TextStyle(color: color, fontWeight: FontWeight.bold, fontSize: 12)),
                  ),
                )).toList(),
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  // --- CHART HELPERS ---
  PieChartSectionData _buildSection(double value, String title, Color color, {Color textColor = Colors.white}) {
    return PieChartSectionData(
      value: value, title: title, color: color, radius: 50,
      titleStyle: TextStyle(color: textColor, fontWeight: FontWeight.bold, fontSize: 14),
    );
  }

  PieChartSectionData _buildTimeSection(int value, int total, Color color, {Color textColor = Colors.white}) {
    final percent = total > 0 ? (value / total * 100).toStringAsFixed(0) : '0';
    return PieChartSectionData(
      value: value.toDouble(), title: '$percent%', color: color, radius: 50,
      titleStyle: TextStyle(color: textColor, fontWeight: FontWeight.bold, fontSize: 12),
    );
  }

  Widget _buildLegendItem(Color color, String text) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(width: 10, height: 10, decoration: BoxDecoration(color: color, shape: BoxShape.circle)),
        const SizedBox(width: 6),
        Text(text, style: const TextStyle(fontSize: 12, color: Colors.black87)),
      ],
    );
  }
}

================================================================================
FILE: lib/features/analytics/screens/test_history_screen.dart
================================================================================
// lib/features/analytics/screens/test_history_screen.dart

import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/test_enums.dart';
// Import the new reusable widget
import 'package:study_smart_qc/features/analytics/widgets/attempt_display_card.dart';

class TestHistoryScreen extends StatefulWidget {
  const TestHistoryScreen({Key? key}) : super(key: key);

  @override
  State<TestHistoryScreen> createState() => _TestHistoryScreenState();
}

class _TestHistoryScreenState extends State<TestHistoryScreen> {
  late Future<List<AttemptModel>> _attemptsFuture;
  final TestOrchestrationService _service = TestOrchestrationService();

  @override
  void initState() {
    super.initState();
    // Fetch attempts from Firestore via the orchestration service
    _attemptsFuture = _service.getUserAttempts();
  }

  Future<void> _refresh() async {
    setState(() {
      _attemptsFuture = _service.getUserAttempts();
    });
  }

  void _navigateToAnalysis(AttemptModel attempt) async {
    // 1. Show Loading UI while fetching question details
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      // 2. Extract Question IDs from the attempt responses
      List<String> questionIds = attempt.responses.keys.toList();

      // 3. Fetch Full Question Objects from Firestore to render the UI
      List<Question> questions = await _service.getQuestionsByIds(questionIds);

      // 4. Reconstruct AnswerStates from the history data for the ResultsScreen
      Map<int, AnswerState> answerStates = {};

      for (int i = 0; i < questions.length; i++) {
        final q = questions[i];
        final response = attempt.responses[q.id];

        AnswerStatus status = AnswerStatus.notVisited;
        if (response != null) {
          if (response.status == 'CORRECT' || response.status == 'INCORRECT') {
            status = AnswerStatus.answered;
          } else if (response.status == 'SKIPPED') {
            status = AnswerStatus.notAnswered;
          }
        }

        answerStates[i] = AnswerState(
          status: status,
          userAnswer: response?.selectedOption, // Supports String, List, or Map
        );
      }

      // 5. Create a TestResult object to pass to the ResultsScreen
      final result = TestResult(
        attemptId: attempt.id, // FIXED: Added attemptId here
        questions: questions,
        answerStates: answerStates,
        timeTaken: Duration(seconds: attempt.timeTakenSeconds),
        totalMarks: questions.length * 4,
        responses: attempt.responses,
      );

      // 6. Navigate to Analysis
      if (mounted) {
        Navigator.pop(context); // Close loader
        Navigator.push(
          context,
          MaterialPageRoute(builder: (context) => ResultsScreen(result: result)),
        );
      }
    } catch (e) {
      if (mounted) Navigator.pop(context); // Close loader on error
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Error loading analysis: $e")),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("History & Analysis"),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 0,
        actions: [
          IconButton(onPressed: _refresh, icon: const Icon(Icons.refresh))
        ],
      ),
      body: FutureBuilder<List<AttemptModel>>(
        future: _attemptsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (!snapshot.hasData || snapshot.data!.isEmpty) {
            return _buildEmptyState();
          }

          final attempts = snapshot.data!;

          return ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: attempts.length,
            itemBuilder: (context, index) {
              // Using the reusable AttemptDisplayCard for consistent UI
              return AttemptDisplayCard(
                attempt: attempts[index],
                onTap: () => _navigateToAnalysis(attempts[index]),
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.assignment_outlined, size: 64, color: Colors.grey.shade300),
          const SizedBox(height: 16),
          const Text("No tests taken yet!", style: TextStyle(color: Colors.grey)),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/features/analytics/widgets/attempt_display_card.dart
================================================================================
// lib/features/analytics/widgets/attempt_display_card.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:study_smart_qc/models/attempt_model.dart';

class AttemptDisplayCard extends StatelessWidget {
  final AttemptModel attempt;
  final VoidCallback onTap;

  const AttemptDisplayCard({
    super.key,
    required this.attempt,
    required this.onTap,
  });

  String _formatDurationClean(int seconds) {
    if (seconds < 60) return "${seconds}s";
    final int m = seconds ~/ 60;
    final int s = seconds % 60;
    if (s == 0) return "${m}m";
    return "${m}m ${s}s";
  }

  /// Returns a record containing the [BarColor] and a darker [TextColor]
  ({Color bar, Color text}) _getDynamicColors(double score, double max) {
    // 1. Handle Negative (Red)
    if (score < 0) {
      return (bar: const Color(0xFFD32F2F), text: const Color(0xFFB71C1C));
    }

    // 2. Handle Zero divide
    if (max == 0) {
      return (bar: Colors.grey, text: Colors.grey.shade700);
    }

    final double percentage = (score / max).clamp(0.0, 1.0);

    // 3. Define Spectrum (Orange -> Amber -> Green -> Dark Green)
    // We break the 0.0 to 1.0 range into segments for cleaner colors

    Color color;

    if (percentage < 0.4) {
      // 0% to 40%: Deep Orange to Amber (Low Score)
      // Normalizing percentage to 0.0-1.0 range for this segment
      final t = percentage / 0.4;
      color = Color.lerp(Colors.deepOrange, Colors.orange, t)!;

    } else if (percentage < 0.75) {
      // 40% to 75%: Amber to Light Green (Average Score)
      final t = (percentage - 0.4) / 0.35;
      color = Color.lerp(Colors.orange, Colors.lightGreen.shade600, t)!;

    } else {
      // 75% to 100%: Green to Dark Emerald (High Score)
      final t = (percentage - 0.75) / 0.25;
      color = Color.lerp(Colors.green, const Color(0xFF1B5E20), t)!;
    }

    // To ensure text is readable, we darken the bar color slightly for text
    final HSLColor hsl = HSLColor.fromColor(color);
    final Color textColor = hsl.withLightness((hsl.lightness - 0.15).clamp(0.0, 1.0)).toColor();

    return (bar: color, text: textColor);
  }

  @override
  Widget build(BuildContext context) {
    // --- Data Prep ---
    final date = attempt.completedAt.toDate();
    final dateStr = DateFormat('d MMM, h:mm a').format(date);

    final int timeTakenSec = attempt.timeTakenSeconds;
    final int timeLimitMin = attempt.timeLimitMinutes ?? 0;
    final int timeLimitSec = timeLimitMin * 60;

    String timeDisplay = _formatDurationClean(timeTakenSec);
    if (timeLimitMin > 0) timeDisplay += " / ${timeLimitMin}m";

    // Percentages
    double timePercentage = (timeLimitSec > 0)
        ? (timeTakenSec / timeLimitSec).clamp(0.0, 1.0)
        : 0.0;

    final double maxScore = attempt.maxMarks.toDouble();
    final double score = attempt.score.toDouble();
    final bool isPositive = score >= 0;

    double scorePercentage = (maxScore == 0)
        ? 0
        : (score.abs() / maxScore).clamp(0.0, 1.0);

    // --- Dynamic Colors ---
    final themeColors = _getDynamicColors(score, maxScore);
    final Color statusColor = themeColors.bar;
    final Color statusTextColor = themeColors.text;

    final Color timeColor = const Color(0xFFFF9800); // Consistent Orange for Time
    final Color trackColor = Colors.grey.shade100;

    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(bottom: 16, left: 4, right: 4),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey.shade300, width: 1.5),
          boxShadow: [
            BoxShadow(
              color: const Color(0xFF2D2F45).withOpacity(0.08),
              blurRadius: 12,
              offset: const Offset(0, 6),
            ),
          ],
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(16),
          child: IntrinsicHeight(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // --- 1. DYNAMIC COLORED STRIP ---
                Container(
                  width: 6,
                  color: statusColor, // Uses the gradient color
                ),

                // --- 2. MAIN CONTENT ---
                Expanded(
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Header
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
                              decoration: BoxDecoration(
                                color: const Color(0xFFF3E5F5),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: Text(
                                "CODE: ${attempt.assignmentCode}",
                                style: const TextStyle(
                                  fontSize: 11,
                                  fontWeight: FontWeight.w700,
                                  color: Color(0xFF7B1FA2),
                                  letterSpacing: 0.5,
                                ),
                              ),
                            ),
                            Text(
                              dateStr,
                              style: TextStyle(
                                fontSize: 13,
                                fontWeight: FontWeight.w600,
                                color: Colors.grey.shade500,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),

                        // Title
                        Text(
                          attempt.title,
                          style: const TextStyle(
                            fontSize: 17,
                            fontWeight: FontWeight.w800,
                            color: Color(0xFF2D2D2D),
                            height: 1.2,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 20),

                        // Stats: Time
                        if (timeLimitSec > 0) ...[
                          _buildStatRow(
                            icon: Icons.access_time_rounded,
                            label: "Time Taken",
                            value: timeDisplay,
                            color: timeColor,
                            percent: timePercentage,
                            trackColor: trackColor,
                          ),
                          const SizedBox(height: 16),
                        ] else ...[
                          Row(
                            children: [
                              Icon(Icons.access_time_rounded, size: 16, color: Colors.grey.shade600),
                              const SizedBox(width: 6),
                              Text(timeDisplay, style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.black87)),
                            ],
                          ),
                          const SizedBox(height: 16),
                        ],

                        // Stats: Score (With Dynamic Colors)
                        _buildStatRow(
                          icon: isPositive ? Icons.analytics_outlined : Icons.warning_amber_rounded,
                          label: isPositive ? "Score" : "Negative Score",
                          value: "${attempt.score} / ${attempt.maxMarks}",
                          color: statusColor,     // Bar color
                          valueColor: statusTextColor, // Text color (darker)
                          percent: scorePercentage,
                          trackColor: trackColor,
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    required Color color,
    Color? valueColor, // Optional override for text color
    required double percent,
    required Color trackColor,
  }) {
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Row(
              children: [
                Icon(icon, size: 16, color: Colors.grey.shade600),
                const SizedBox(width: 6),
                Text(
                  label,
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey.shade700,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            Text(
              value,
              style: TextStyle(
                fontSize: 13,
                fontWeight: FontWeight.w800,
                color: valueColor ?? color,
              ),
            ),
          ],
        ),
        const SizedBox(height: 6),
        ClipRRect(
          borderRadius: BorderRadius.circular(6),
          child: LinearProgressIndicator(
            value: percent,
            backgroundColor: trackColor,
            color: color,
            minHeight: 8,
          ),
        ),
      ],
    );
  }
}

================================================================================
FILE: lib/features/analytics/widgets/attempt_list_widget.dart
================================================================================
// lib/features/analytics/widgets/attempt_list_widget.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/analytics/widgets/attempt_display_card.dart';
import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';

class AttemptListWidget extends StatelessWidget {
  final String? filterMode; // 'Practice', 'Test', or null (for all)
  final String? targetUserId; // Optional: If provided (by Teacher), fetches specific student data

  // NEW PARAMETER: To distinguish between "Strict Tests" and "Assignments taken as Test"
  final bool onlySingleAttempt;

  const AttemptListWidget({
    super.key,
    this.filterMode,
    this.targetUserId,
    // Default to false so existing calls elsewhere don't break
    this.onlySingleAttempt = false,
  });

  // --- NAVIGATION LOGIC ---
  // This helper function fetches the full question data needed for the ResultsScreen
  Future<void> _navigateToAnalysis(BuildContext context, AttemptModel attempt) async {
    // 1. Show Loading Indicator
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final service = TestOrchestrationService();

      // 2. Extract Question IDs from the attempt responses
      List<String> questionIds = attempt.responses.keys.toList();

      // 3. Fetch Full Question Objects from Firestore
      List<Question> questions = await service.getQuestionsByIds(questionIds);

      // 4. Reconstruct AnswerStates for the UI
      Map<int, AnswerState> answerStates = {};
      for (int i = 0; i < questions.length; i++) {
        final q = questions[i];
        final response = attempt.responses[q.id];

        AnswerStatus status = AnswerStatus.notVisited;
        if (response != null) {
          if (response.status == 'CORRECT' || response.status == 'INCORRECT') {
            status = AnswerStatus.answered;
          } else if (response.status == 'SKIPPED') {
            status = AnswerStatus.notAnswered;
          }
        }

        answerStates[i] = AnswerState(
          status: status,
          userAnswer: response?.selectedOption,
        );
      }

      // 5. Create TestResult object
      final result = TestResult(
        attemptId: attempt.id,
        questions: questions,
        answerStates: answerStates,
        timeTaken: Duration(seconds: attempt.timeTakenSeconds),
        totalMarks: questions.length * 4,
        responses: attempt.responses,
      );

      // 6. Navigate
      if (context.mounted) {
        Navigator.pop(context); // Close loader
        Navigator.push(
          context,
          MaterialPageRoute(builder: (context) => ResultsScreen(result: result)),
        );
      }
    } catch (e) {
      if (context.mounted) {
        Navigator.pop(context); // Close loader on error
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Error loading analysis: $e")),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // 1. Determine which User ID to fetch
    final currentUser = FirebaseAuth.instance.currentUser;
    // If targetUserId is passed (by Teacher via Drawer), use it. Otherwise use logged-in user.
    final String? uidToQuery = targetUserId ?? currentUser?.uid;

    if (uidToQuery == null) return const SizedBox.shrink();

    return StreamBuilder<QuerySnapshot>(
      // Fetch all attempts for the specific user (Student or Teacher Target), ordered by most recent
      stream: FirebaseFirestore.instance
          .collection('attempts')
          .where('userId', isEqualTo: uidToQuery)
          .orderBy('completedAt', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          return Center(child: Text("Error: ${snapshot.error}"));
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return _buildEmptyState();
        }

        // --- CLIENT SIDE FILTERING ---
        // We filter here instead of in the query to avoid complex composite index requirements
        final docs = snapshot.data!.docs.where((doc) {
          final data = doc.data() as Map<String, dynamic>;

          // 1. Filter by Mode (Practice vs Test)
          if (filterMode != null) {
            final String mode = data['mode'] ?? '';
            if (mode.toLowerCase() != filterMode!.toLowerCase()) return false;
          }

          // 2. Filter by Strictness (onlySingleAttempt)
          // We check if the attempt document has this flag matching what we want
          final bool docSingleAttempt = data['onlySingleAttempt'] ?? false;

          if (docSingleAttempt != onlySingleAttempt) return false;

          return true;
        }).toList();

        if (docs.isEmpty) {
          return _buildEmptyState();
        }

        return ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: docs.length,
          itemBuilder: (context, index) {
            final attempt = AttemptModel.fromFirestore(docs[index]);

            return AttemptDisplayCard(
              attempt: attempt,
              onTap: () => _navigateToAnalysis(context, attempt),
            );
          },
        );
      },
    );
  }

  Widget _buildEmptyState() {
    String message = "No attempts found.";
    IconData icon = Icons.history;

    if (filterMode == 'Test') {
      if (onlySingleAttempt) {
        message = "No strict tests attempted yet.";
        icon = Icons.timer_off;
      } else {
        message = "No assignments taken in Test Mode yet.";
        icon = Icons.timer_outlined;
      }
    } else if (filterMode == 'Practice') {
      message = "No practice assignments completed yet.";
      icon = Icons.assignment_late_outlined;
    }

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 64, color: Colors.grey.shade300),
          const SizedBox(height: 16),
          Text(
            message,
            style: const TextStyle(color: Colors.grey),
          ),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/features/auth/screens/auth_page.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/auth/screens/login_screen.dart';
import 'package:study_smart_qc/features/auth/screens/register_screen.dart';

class AuthPage extends StatefulWidget {
  const AuthPage({super.key});

  @override
  State<AuthPage> createState() => _AuthPageState();
}

class _AuthPageState extends State<AuthPage> {
  bool _showLoginScreen = true;

  void toggleScreens() {
    setState(() {
      _showLoginScreen = !_showLoginScreen;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_showLoginScreen) {
      return LoginScreen(showRegisterScreen: toggleScreens);
    } else {
      return RegisterScreen(showLoginScreen: toggleScreens);
    }
  }
}


================================================================================
FILE: lib/features/auth/screens/auth_wrapper.dart
================================================================================
// lib/features/auth/screens/auth_wrapper.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/auth/screens/onboarding_screen.dart';
import 'package:study_smart_qc/features/home/screens/home_screen.dart';
import 'package:study_smart_qc/models/user_model.dart';
import 'package:study_smart_qc/services/auth_service.dart';

class AuthWrapper extends StatelessWidget {
  final User firebaseUser;
  const AuthWrapper({super.key, required this.firebaseUser});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<DocumentSnapshot>(
      stream: FirebaseFirestore.instance
          .collection('users')
          .doc(firebaseUser.uid)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return _buildErrorScreen("Error: ${snapshot.error}");
        }

        // 1. Loading State (Including if doc is null/not exist yet)
        if (snapshot.connectionState == ConnectionState.waiting ||
            !snapshot.hasData ||
            !snapshot.data!.exists) {
          return const Scaffold(
            body: Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text("Setting up your profile..."),
                ],
              ),
            ),
          );
        }

        // 2. Data Ready
        try {
          UserModel user = UserModel.fromFirestore(snapshot.data!);
          if (user.onboardingCompleted) {
            return const HomeScreen();
          } else {
            return const OnboardingScreen();
          }
        } catch (e) {
          return _buildErrorScreen("Profile Error: $e");
        }
      },
    );
  }

  Widget _buildErrorScreen(String msg) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error, color: Colors.red, size: 48),
            const SizedBox(height: 16),
            Text(msg, textAlign: TextAlign.center),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => AuthService().signOut(),
              child: const Text("Sign Out"),
            )
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/auth/screens/login_screen.dart
================================================================================
// lib/features/auth/screens/login_screen.dart

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/auth_service.dart';
import 'package:study_smart_qc/features/auth/screens/auth_wrapper.dart';

class LoginScreen extends StatefulWidget {
  final VoidCallback showRegisterScreen;
  const LoginScreen({super.key, required this.showRegisterScreen});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  // UI States
  bool _isLoading = false;
  bool _isPasswordVisible = false;

  Future<void> _signIn() async {
    // 1. Dismiss Keyboard immediately
    FocusScope.of(context).unfocus();

    if (_formKey.currentState!.validate()) {
      setState(() => _isLoading = true);

      try {
        // 2. Attempt Login
        UserCredential? cred = await AuthService().signInWithEmailAndPassword(
          _emailController.text.trim(),
          _passwordController.text.trim(),
        );

        if (mounted && cred != null && cred.user != null) {
          // Success Navigation
          Navigator.of(context).pushReplacement(
            MaterialPageRoute(
              builder: (_) => AuthWrapper(firebaseUser: cred.user!),
            ),
          );
        }
      } on FirebaseAuthException catch (e) {
        // 3. Handle Firebase Errors nicely
        String message = "Login failed. Please try again.";
        if (e.code == 'user-not-found' || e.code == 'invalid-credential') {
          message = "No account found with these credentials.";
        } else if (e.code == 'wrong-password') {
          message = "Incorrect password. Please try again.";
        } else if (e.code == 'invalid-email') {
          message = "The email address is badly formatted.";
        } else if (e.code == 'too-many-requests') {
          message = "Too many failed attempts. Try again later.";
        }
        _showSnackBar(message, isError: true);
      } catch (e) {
        // 4. Handle Generic Errors
        _showSnackBar("An unexpected error occurred: $e", isError: true);
      } finally {
        if (mounted) setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _signInGoogle() async {
    setState(() => _isLoading = true);
    try {
      UserCredential? cred = await AuthService().signInWithGoogle();
      if (mounted && cred != null && cred.user != null) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => AuthWrapper(firebaseUser: cred.user!)),
        );
      }
    } catch (e) {
      _showSnackBar("Google Sign-In failed. Please try again.", isError: true);
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  void _showSnackBar(String message, {bool isError = false}) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: isError ? Colors.red.shade600 : Colors.green,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // "Tap to Dismiss" Keyboard wrapper
    return GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      child: Scaffold(
        backgroundColor: Colors.deepPurple[50],
        body: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.school_rounded, size: 80, color: Colors.deepPurple),
                  const SizedBox(height: 16),
                  const Text('ModX by Anup Sir',
                      style: TextStyle(
                          fontSize: 32,
                          fontWeight: FontWeight.bold,
                          color: Colors.deepPurple)),
                  const SizedBox(height: 8),
                  Text('Welcome back! Please login to continue.',
                      style: TextStyle(color: Colors.grey[600], fontSize: 16)),
                  const SizedBox(height: 40),

                  // EMAIL FIELD
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    decoration: InputDecoration(
                      labelText: 'Email',
                      prefixIcon: const Icon(Icons.email_outlined),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                      filled: true,
                      fillColor: Colors.white,
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) return 'Please enter an email';
                      if (!value.contains('@') || !value.contains('.')) return 'Please enter a valid email';
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // PASSWORD FIELD (With Eye Icon)
                  TextFormField(
                    controller: _passwordController,
                    obscureText: !_isPasswordVisible,
                    decoration: InputDecoration(
                      labelText: 'Password',
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _isPasswordVisible ? Icons.visibility : Icons.visibility_off,
                          color: Colors.grey,
                        ),
                        onPressed: () => setState(() => _isPasswordVisible = !_isPasswordVisible),
                      ),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                      filled: true,
                      fillColor: Colors.white,
                    ),
                    validator: (value) => value!.isEmpty ? 'Please enter a password' : null,
                  ),
                  const SizedBox(height: 24),

                  // LOGIN BUTTON
                  ElevatedButton(
                    onPressed: _isLoading ? null : _signIn,
                    style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 55),
                      backgroundColor: Colors.deepPurple,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      elevation: 2,
                    ),
                    child: _isLoading
                        ? const SizedBox(
                      height: 24,
                      width: 24,
                      child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2.5),
                    )
                        : const Text('Sign In', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                  ),
                  const SizedBox(height: 16),

                  // GOOGLE BUTTON
                  ElevatedButton.icon(
                    icon: Image.asset('assets/google_logo.png', height: 24.0),
                    label: const Text('Sign in with Google', style: TextStyle(fontSize: 16)),
                    style: ElevatedButton.styleFrom(
                      foregroundColor: Colors.black87,
                      backgroundColor: Colors.white,
                      minimumSize: const Size(double.infinity, 55),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                          side: BorderSide(color: Colors.grey.shade300)
                      ),
                      elevation: 0,
                    ),
                    onPressed: _isLoading ? null : _signInGoogle,
                  ),
                  const SizedBox(height: 24),

                  // TOGGLE LINK
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text("Not a member? ", style: TextStyle(color: Colors.grey[700])),
                      GestureDetector(
                        onTap: widget.showRegisterScreen,
                        child: const Text('Register now',
                            style: TextStyle(
                                color: Colors.deepPurple, fontWeight: FontWeight.bold)),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/auth/screens/onboarding_screen.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/onboarding_service.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final OnboardingService _onboardingService = OnboardingService();
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Loading States
  bool _isFetchingOptions = true;
  bool _isSubmitting = false;

  // Data Options (Fetched from Firestore)
  List<String> _examsList = [];
  List<String> _classesList = [];
  List<String> _subjectsList = [];
  List<int> _targetYears = [];

  // Form State - Student
  String? _selectedExam;
  String? _selectedClass;
  int? _selectedYear;

  // Form State - Teacher
  final List<String> _teacherSelectedExams = [];
  final List<String> _teacherSelectedSubjects = [];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _fetchOptions();
  }

  Future<void> _fetchOptions() async {
    try {
      final doc = await FirebaseFirestore.instance
          .collection('static_data')
          .doc('option_sets')
          .get();

      if (doc.exists) {
        final data = doc.data()!;
        setState(() {
          _examsList = List<String>.from(data['exams_list'] ?? []);
          _classesList = List<String>.from(data['classes_list'] ?? []);
          _subjectsList = List<String>.from(data['subjects_list'] ?? []);
          _targetYears = List<int>.from(data['target_years'] ?? []);
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading options: $e')),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isFetchingOptions = false);
      }
    }
  }

  Future<void> _handleSubmit() async {
    final user = _auth.currentUser;
    if (user == null) return;

    setState(() => _isSubmitting = true);

    try {
      final isStudent = _tabController.index == 0;
      final role = isStudent ? 'student' : 'teacher';
      Map<String, dynamic> profileData = {};

      if (isStudent) {
        // Validate Student Form
        if (_selectedExam == null ||
            _selectedClass == null ||
            _selectedYear == null) {
          throw Exception("Please fill all fields.");
        }
        profileData = {
          'targetExam': _selectedExam,
          'currentClass': _selectedClass,
          'targetYear': _selectedYear,
        };
      } else {
        // Validate Teacher Form
        if (_teacherSelectedExams.isEmpty ||
            _teacherSelectedSubjects.isEmpty) {
          throw Exception("Please select at least one exam and one subject.");
        }
        profileData = {
          'teachingExams': _teacherSelectedExams,
          'teachingSubjects': _teacherSelectedSubjects,
        };
      }

      // Call Service
      await _onboardingService.completeOnboarding(
        uid: user.uid,
        role: role,
        profileData: profileData,
      );

      // No manual navigation needed here; AuthWrapper will react to the data change.
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(e.toString().replaceAll('Exception: ', '')),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isFetchingOptions) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text("Welcome to StudySmart"),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: "I'm a Student", icon: Icon(Icons.school)),
            Tab(text: "I'm a Teacher", icon: Icon(Icons.person_outline)),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildStudentForm(),
          _buildTeacherForm(),
        ],
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.all(20.0),
        child: ElevatedButton(
          style: ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(vertical: 15),
            backgroundColor: Colors.deepPurple,
            foregroundColor: Colors.white,
          ),
          onPressed: _isSubmitting ? null : _handleSubmit,
          child: _isSubmitting
              ? const SizedBox(
            height: 20,
            width: 20,
            child: CircularProgressIndicator(
                color: Colors.white, strokeWidth: 2),
          )
              : const Text("Complete Profile", style: TextStyle(fontSize: 18)),
        ),
      ),
    );
  }

  Widget _buildStudentForm() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("Help us personalize your learning path.",
              style: TextStyle(fontSize: 16, color: Colors.grey)),
          const SizedBox(height: 30),
          _buildDropdown(
            label: "Target Exam",
            value: _selectedExam,
            items: _examsList,
            onChanged: (val) => setState(() => _selectedExam = val),
          ),
          const SizedBox(height: 20),
          _buildDropdown(
            label: "Current Class",
            value: _selectedClass,
            items: _classesList,
            onChanged: (val) => setState(() => _selectedClass = val),
          ),
          const SizedBox(height: 20),
          DropdownButtonFormField<int>(
            // FIX: Using initialValue instead of value
            initialValue: _selectedYear,
            decoration: const InputDecoration(
              labelText: "Target Exam Year",
              border: OutlineInputBorder(),
            ),
            items: _targetYears
                .map((year) => DropdownMenuItem(
              value: year,
              child: Text(year.toString()),
            ))
                .toList(),
            onChanged: (val) => setState(() => _selectedYear = val),
          ),
        ],
      ),
    );
  }

  Widget _buildTeacherForm() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("Tell us about your teaching expertise.",
              style: TextStyle(fontSize: 16, color: Colors.grey)),
          const SizedBox(height: 30),
          const Text("Exams you teach:",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
          const SizedBox(height: 10),
          Wrap(
            spacing: 8.0,
            children: _examsList.map((exam) {
              final isSelected = _teacherSelectedExams.contains(exam);
              return FilterChip(
                label: Text(exam),
                selected: isSelected,
                onSelected: (selected) {
                  setState(() {
                    selected
                        ? _teacherSelectedExams.add(exam)
                        : _teacherSelectedExams.remove(exam);
                  });
                },
              );
            }).toList(),
          ),
          const SizedBox(height: 30),
          const Text("Subjects:",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
          const SizedBox(height: 10),
          Wrap(
            spacing: 8.0,
            children: _subjectsList.map((subject) {
              final isSelected = _teacherSelectedSubjects.contains(subject);
              return FilterChip(
                label: Text(subject),
                selected: isSelected,
                onSelected: (selected) {
                  setState(() {
                    selected
                        ? _teacherSelectedSubjects.add(subject)
                        : _teacherSelectedSubjects.remove(subject);
                  });
                },
              );
            }).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildDropdown({
    required String label,
    required String? value,
    required List<String> items,
    required Function(String?) onChanged,
  }) {
    return DropdownButtonFormField<String>(
      // FIX: Using initialValue instead of value
      initialValue: value,
      decoration: InputDecoration(
        labelText: label,
        border: const OutlineInputBorder(),
      ),
      items: items
          .map((item) => DropdownMenuItem(
        value: item,
        child: Text(item),
      ))
          .toList(),
      onChanged: onChanged,
    );
  }
}

================================================================================
FILE: lib/features/auth/screens/register_screen.dart
================================================================================
// lib/features/auth/screens/register_screen.dart

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/auth_service.dart';
import 'package:study_smart_qc/features/auth/screens/auth_wrapper.dart';

class RegisterScreen extends StatefulWidget {
  final VoidCallback showLoginScreen;
  const RegisterScreen({super.key, required this.showLoginScreen});

  @override
  State<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends State<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _displayNameController = TextEditingController();

  // UI States
  bool _isLoading = false;
  bool _isPasswordVisible = false;

  Future<void> _signUp() async {
    FocusScope.of(context).unfocus();

    if (_formKey.currentState!.validate()) {
      setState(() => _isLoading = true);

      try {
        UserCredential? cred = await AuthService().signUpWithEmailAndPassword(
          _emailController.text.trim(),
          _passwordController.text.trim(),
          _displayNameController.text.trim(),
        );

        if (mounted && cred != null && cred.user != null) {
          Navigator.of(context).pushReplacement(
            MaterialPageRoute(
              builder: (_) => AuthWrapper(firebaseUser: cred.user!),
            ),
          );
        }
      } on FirebaseAuthException catch (e) {
        String message = "Registration failed.";
        if (e.code == 'weak-password') {
          message = "The password provided is too weak.";
        } else if (e.code == 'email-already-in-use') {
          message = "The account already exists for that email.";
        } else if (e.code == 'invalid-email') {
          message = "The email address is invalid.";
        }
        _showSnackBar(message, isError: true);
      } catch (e) {
        _showSnackBar("An error occurred: $e", isError: true);
      } finally {
        if (mounted) setState(() => _isLoading = false);
      }
    }
  }

  void _showSnackBar(String message, {bool isError = false}) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: isError ? Colors.red.shade600 : Colors.green,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _displayNameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      child: Scaffold(
        backgroundColor: Colors.deepPurple[50],
        appBar: AppBar(
          title: const Text('Create Account'),
          backgroundColor: Colors.deepPurple[50],
          elevation: 0,
        ),
        body: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Text('Get Started',
                      style: TextStyle(
                          fontSize: 32,
                          fontWeight: FontWeight.bold,
                          color: Colors.deepPurple)),
                  const SizedBox(height: 8),
                  Text('Create your account to start learning.',
                      style: TextStyle(color: Colors.grey[600], fontSize: 16)),
                  const SizedBox(height: 30),

                  // NAME FIELD
                  TextFormField(
                    controller: _displayNameController,
                    textCapitalization: TextCapitalization.words,
                    decoration: InputDecoration(
                      labelText: 'Full Name',
                      prefixIcon: const Icon(Icons.person_outline),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                      filled: true,
                      fillColor: Colors.white,
                    ),
                    validator: (value) => value!.isEmpty ? 'Please enter your name' : null,
                  ),
                  const SizedBox(height: 16),

                  // EMAIL FIELD
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    decoration: InputDecoration(
                      labelText: 'Email',
                      prefixIcon: const Icon(Icons.email_outlined),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                      filled: true,
                      fillColor: Colors.white,
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) return 'Please enter an email';
                      if (!value.contains('@') || !value.contains('.')) return 'Please enter a valid email';
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // PASSWORD FIELD
                  TextFormField(
                    controller: _passwordController,
                    obscureText: !_isPasswordVisible,
                    decoration: InputDecoration(
                      labelText: 'Password',
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _isPasswordVisible ? Icons.visibility : Icons.visibility_off,
                          color: Colors.grey,
                        ),
                        onPressed: () => setState(() => _isPasswordVisible = !_isPasswordVisible),
                      ),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                      filled: true,
                      fillColor: Colors.white,
                    ),
                    validator: (value) => (value != null && value.length < 6)
                        ? 'Password must be at least 6 characters'
                        : null,
                  ),
                  const SizedBox(height: 24),

                  // SIGN UP BUTTON
                  ElevatedButton(
                    onPressed: _isLoading ? null : _signUp,
                    style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 55),
                      backgroundColor: Colors.deepPurple,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      elevation: 2,
                    ),
                    child: _isLoading
                        ? const SizedBox(
                      height: 24,
                      width: 24,
                      child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2.5),
                    )
                        : const Text('Sign Up', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                  ),
                  const SizedBox(height: 24),

                  // TOGGLE LINK
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text("Already have an account? ", style: TextStyle(color: Colors.grey[700])),
                      GestureDetector(
                        onTap: widget.showLoginScreen,
                        child: const Text('Login',
                            style: TextStyle(
                                color: Colors.deepPurple, fontWeight: FontWeight.bold)),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/common/widgets/question_preview_card.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/question_model.dart';

class QuestionPreviewCard extends StatefulWidget {
  final Question question;
  final bool isExpanded; // If true, shows full details initially

  const QuestionPreviewCard({
    super.key,
    required this.question,
    this.isExpanded = false,
  });

  @override
  State<QuestionPreviewCard> createState() => _QuestionPreviewCardState();
}

class _QuestionPreviewCardState extends State<QuestionPreviewCard> {
  bool _showAnswer = false;

  @override
  Widget build(BuildContext context) {
    final q = widget.question;

    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // HEADER: ID + Tags
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.deepPurple.shade50,
              borderRadius: const BorderRadius.vertical(top: Radius.circular(12)),
            ),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Colors.deepPurple,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    "QID: ${q.id}",
                    style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 12),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      children: [
                        // UPDATED TAGS: Source -> Chapter -> Topic -> Difficulty
                        if (q.exam.isNotEmpty) ...[
                          _buildTag(q.exam, Colors.blue.shade50, Colors.blue.shade700),
                          const SizedBox(width: 5),
                        ],
                        if (q.chapterId.isNotEmpty) ...[
                          _buildTag(_formatTag(q.chapterId), Colors.orange.shade50, Colors.orange.shade800),
                          const SizedBox(width: 5),
                        ],
                        _buildTag(_formatTag(q.topicId), Colors.grey.shade100, Colors.grey.shade700),
                        const SizedBox(width: 5),
                        _buildTag(q.difficulty, _getDifficultyColor(q.difficulty), Colors.black87),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),

          // BODY: Question Image
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text("Question:", style: TextStyle(fontWeight: FontWeight.bold, color: Colors.grey)),
                const SizedBox(height: 8),
                Center(
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxHeight: 250),
                    child: Image.network(
                      q.imageUrl,
                      loadingBuilder: (ctx, child, p) => p == null ? child : const CircularProgressIndicator(),
                      errorBuilder: (ctx, err, stack) => const Icon(Icons.broken_image, size: 50, color: Colors.grey),
                    ),
                  ),
                ),
              ],
            ),
          ),

          // FOOTER: Show Answer Toggle
          const Divider(height: 1),
          if (!_showAnswer)
            SizedBox(
              width: double.infinity,
              child: TextButton.icon(
                icon: const Icon(Icons.visibility),
                label: const Text("Show Answer & Solution"),
                onPressed: () => setState(() => _showAnswer = true),
              ),
            ),

          // ANSWER SECTION (Conditional)
          if (_showAnswer)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.green.shade50,
                borderRadius: const BorderRadius.vertical(bottom: Radius.circular(12)),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text("Solution:", style: TextStyle(fontWeight: FontWeight.bold, color: Colors.green)),
                      IconButton(
                        icon: const Icon(Icons.close, size: 16),
                        onPressed: () => setState(() => _showAnswer = false),
                      )
                    ],
                  ),
                  const SizedBox(height: 8),

                  // CORRECT ANSWER TEXT
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      border: Border.all(color: Colors.green.shade200),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Text("Correct Option: ", style: TextStyle(fontWeight: FontWeight.bold)),
                        Text(q.correctAnswer, style: const TextStyle(color: Colors.green, fontWeight: FontWeight.bold, fontSize: 16)),
                      ],
                    ),
                  ),

                  const SizedBox(height: 10),

                  // SOLUTION IMAGE
                  if (q.solutionUrl != null && q.solutionUrl!.isNotEmpty)
                    Center(
                      child: Image.network(
                        q.solutionUrl!,
                        errorBuilder: (ctx, err, stack) => const Text("Solution image not available"),
                      ),
                    )
                  else
                    const Text("No detailed solution image available.", style: TextStyle(fontStyle: FontStyle.italic, color: Colors.grey)),
                ],
              ),
            ),
        ],
      ),
    );
  }

  // Helper to clean up ID strings (e.g., "ray_optics" -> "Ray Optics")
  String _formatTag(String text) {
    if (text.isEmpty) return "";
    return text.split('_').map((str) => str.isNotEmpty ? str[0].toUpperCase() + str.substring(1) : '').join(' ');
  }

  Color _getDifficultyColor(String diff) {
    switch (diff.toLowerCase()) {
      case 'easy': return Colors.green.shade100;
      case 'medium': return Colors.yellow.shade100;
      case 'hard': return Colors.red.shade100;
      default: return Colors.grey.shade200;
    }
  }

  Widget _buildTag(String text, Color bg, Color fg) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: bg.withOpacity(0.5)),
      ),
      child: Text(text, style: TextStyle(fontSize: 10, color: fg, fontWeight: FontWeight.w500)),
    );
  }
}

================================================================================
FILE: lib/features/home/screens/home_screen.dart
================================================================================
// lib/features/home/screens/home_screen.dart

import 'dart:convert';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

// MODELS
import 'package:study_smart_qc/models/user_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_enums.dart';

// SCREENS & WIDGETS
import 'package:study_smart_qc/features/auth/screens/auth_page.dart';
import 'package:study_smart_qc/features/auth/screens/auth_wrapper.dart';
import 'package:study_smart_qc/features/student/widgets/student_assignments_list.dart';
import 'package:study_smart_qc/features/teacher/screens/teacher_curation_screen.dart';
import 'package:study_smart_qc/features/teacher/screens/teacher_history_screen.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';
import 'package:study_smart_qc/features/analytics/widgets/attempt_list_widget.dart';
import 'package:study_smart_qc/widgets/student_lookup_sheet.dart';

// SERVICES
import 'package:study_smart_qc/services/auth_service.dart';
import 'package:study_smart_qc/services/onboarding_service.dart';
import 'package:study_smart_qc/services/local_session_service.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  int _currentTabIndex = 0;
  UserModel? _userModel;
  bool _isLoading = true;

  // --- RESUME SESSION STATE ---
  final LocalSessionService _localSessionService = LocalSessionService();
  bool _hasPendingSession = false;
  Map<String, dynamic>? _pendingSessionData;

  @override
  void initState() {
    super.initState();
    _fetchUserData();
    _checkPendingSession();
  }

  Future<void> _fetchUserData() async {
    final user = await OnboardingService().getCurrentUserModel();
    if (mounted) {
      setState(() {
        _userModel = user;
        _isLoading = false;
      });
    }
  }

  // Helper to extract pending code safely
  String? get _pendingAssignmentCode {
    if (!_hasPendingSession || _pendingSessionData == null) return null;
    return _pendingSessionData!['meta']['assignmentCode'];
  }

  // ---------------------------------------------------------------------------
  //  RESUME LOGIC
  // ---------------------------------------------------------------------------

  Future<void> _checkPendingSession() async {
    final hasSession = await _localSessionService.hasPendingSession();
    if (hasSession) {
      final data = await _localSessionService.getSessionData();
      setState(() {
        _hasPendingSession = true;
        _pendingSessionData = data;
      });
      if (mounted) _showResumeDialog();
    }
  }

  void _showResumeDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => AlertDialog(
        title: const Text("Resume Session?"),
        content: const Text(
            "You have an unfinished session saved on this device. Would you like to continue?"),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(ctx);
              _handleSubmitPending();
            },
            style: TextButton.styleFrom(foregroundColor: Colors.grey),
            child: const Text("Discard & Submit"),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(ctx);
              _handleResumePending();
            },
            style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF6200EA), // Brand Color
                foregroundColor: Colors.white),
            child: const Text("Resume"),
          ),
        ],
      ),
    );
  }

  Future<void> _handleResumePending() async {
    if (_pendingSessionData == null) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final meta = _pendingSessionData!['meta'];
      final timestamps = _pendingSessionData!['timestamps'];
      final state = _pendingSessionData!['state'];

      final String mode = meta['mode'] ?? 'Test';
      final String assignmentCode = meta['assignmentCode'];
      final int savedTimer = timestamps['quitTimeTimerValue'];
      final String quitTimestamp = timestamps['quitTimeTimestamp'];

      // RECONCILE TIMER
      final newTime = _localSessionService.calculateResumeTime(
        mode: mode,
        savedTimerValue: savedTimer,
        savedTimestampIso: quitTimestamp,
      );

      if (newTime == null) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
          content: Text("Time expired while you were away. Submitting..."),
          backgroundColor: Colors.red,
        ));
        _handleSubmitPending();
        return;
      }

      // FETCH DATA
      List<Question> questions = [];
      List<String> qIds = [];
      bool isSingleAttempt = false;

      final curationQuery = await FirebaseFirestore.instance
          .collection('questions_curation')
          .where('assignmentCode', isEqualTo: assignmentCode)
          .limit(1)
          .get();

      if (curationQuery.docs.isNotEmpty) {
        final data = curationQuery.docs.first.data();
        qIds = List<String>.from(data['questionIds'] ?? []);
        isSingleAttempt = data['onlySingleAttempt'] ?? false;
      } else {
        final testQuery = await FirebaseFirestore.instance
            .collection('tests')
            .where('assignmentCode', isEqualTo: assignmentCode)
            .limit(1)
            .get();

        if (testQuery.docs.isNotEmpty) {
          qIds = List<String>.from(
              testQuery.docs.first.data()['questionIds'] ?? []);
        }
      }

      if (qIds.isNotEmpty) {
        questions = await TestOrchestrationService().getQuestionsByIds(qIds);
      }

      if (questions.isEmpty) {
        throw Exception("Could not retrieve questions.");
      }

      final responseMap = _localSessionService.parseResponses(
          Map<String, dynamic>.from(state['responses']));

      if (mounted) {
        Navigator.pop(context);
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => TestScreen(
              sourceId: curationQuery.docs.isNotEmpty
                  ? curationQuery.docs.first.id
                  : '',
              assignmentCode: assignmentCode,
              questions: questions,
              timeLimitInMinutes: 0,
              testMode: mode == 'Test' ? TestMode.test : TestMode.practice,
              resumedTimerSeconds: newTime,
              resumedPageIndex: state['currentQuestionIndex'],
              resumedResponses: responseMap,
              title: meta['title'] ?? 'Resumed Session',
              onlySingleAttempt: isSingleAttempt,
            ),
          ),
        ).then((_) {
          _checkPendingSession();
          _fetchUserData();
        });
      }
    } catch (e) {
      if (mounted) Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Error resuming: $e")),
      );
    }
  }

  Future<void> _handleSubmitPending() async {
    if (_pendingSessionData == null) return;

    final meta = _pendingSessionData!['meta'];
    final state = _pendingSessionData!['state'];
    final metaMode = meta['mode'] ?? 'Test';

    final responseMap = _localSessionService.parseResponses(
        Map<String, dynamic>.from(state['responses']));

    int correct = 0;
    int incorrect = 0;
    responseMap.forEach((k, v) {
      if (v.status == 'CORRECT') correct++;
      if (v.status == 'INCORRECT') incorrect++;
    });
    final score = (correct * 4) - incorrect;

    await TestOrchestrationService().submitAttempt(
      sourceId: meta['testId'] ?? '',
      assignmentCode: meta['assignmentCode'],
      mode: metaMode,
      title: meta['title'] ?? 'Untitled Test',
      onlySingleAttempt: false,
      questions: [],
      score: score,
      timeTakenSeconds: 0,
      responses: responseMap,
    );

    await _localSessionService.clearSession();

    setState(() {
      _hasPendingSession = false;
      _pendingSessionData = null;
    });

    if (mounted) {
      _fetchUserData();
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Session submitted successfully.")));
    }
  }

  // ---------------------------------------------------------------------------
  //  UI BUILD
  // ---------------------------------------------------------------------------

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    if (_userModel == null) {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser != null) {
        return AuthWrapper(firebaseUser: currentUser);
      } else {
        return const AuthPage();
      }
    }

    // --- TEACHER DASHBOARD ---
    if (_userModel!.role == 'teacher') {
      return Scaffold(
        appBar: AppBar(title: const Text("Teacher Dashboard")),
        drawer: _buildDrawer(context),
        body: const TeacherCurationScreen(),
      );
    }

    // --- STUDENT DASHBOARD ---
    final List<String> submitted = _userModel!.assignmentCodesSubmitted;
    final String? resumeCode = _pendingAssignmentCode;
    final VoidCallback navToAnalysis = () => setState(() => _currentTabIndex = 2);

    return Scaffold(
      backgroundColor: const Color(0xFFF9F9F9), // Clean off-white background
      appBar: AppBar(
        title: Text(
          _getAppBarTitle(),
          style: const TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        elevation: 0,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black87,
        centerTitle: false,
      ),
      drawer: _buildDrawer(context),
      body: IndexedStack(
        index: _currentTabIndex,
        children: [
          // Tab 0: Assignments
          _AssignmentTabContainer(
            isStrict: false,
            submittedCodes: submitted,
            resumableAssignmentCode: resumeCode,
            onResumeTap: _handleResumePending,
            onViewAnalysisTap: navToAnalysis,
            onRefreshNeeded: _fetchUserData, // PASS CALLBACK HERE
          ),

          // Tab 1: Tests
          _AssignmentTabContainer(
            isStrict: true,
            submittedCodes: submitted,
            resumableAssignmentCode: resumeCode,
            onResumeTap: _handleResumePending,
            onViewAnalysisTap: navToAnalysis,
            onRefreshNeeded: _fetchUserData, // PASS CALLBACK HERE
          ),

          // Tab 2: Analysis (Redesigned)
          const _AnalysisView(),
        ],
      ),
      bottomNavigationBar: NavigationBar(
        selectedIndex: _currentTabIndex,
        onDestinationSelected: (index) =>
            setState(() => _currentTabIndex = index),
        backgroundColor: Colors.white,
        indicatorColor: const Color(0xFFEADBFF), // Brand light purple
        destinations: const [
          NavigationDestination(
            icon: Icon(Icons.assignment_outlined),
            selectedIcon: Icon(Icons.assignment, color: Color(0xFF6200EA)),
            label: 'Assignments',
          ),
          NavigationDestination(
            icon: Icon(Icons.timer_outlined),
            selectedIcon: Icon(Icons.timer, color: Color(0xFF6200EA)),
            label: 'Tests',
          ),
          NavigationDestination(
            icon: Icon(Icons.analytics_outlined),
            selectedIcon: Icon(Icons.analytics, color: Color(0xFF6200EA)),
            label: 'Analysis',
          ),
        ],
      ),
    );
  }

  String _getAppBarTitle() {
    switch (_currentTabIndex) {
      case 0:
        return "Assignments";
      case 1:
        return "Tests";
      case 2:
        return "Analysis";
      default:
        return "ModX by Anup Sir";
    }
  }

  Widget _buildDrawer(BuildContext context) {
    final isTeacher = _userModel?.role == 'teacher';
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          UserAccountsDrawerHeader(
            accountName: Text(
              _userModel?.displayName ?? "User",
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
            accountEmail: Text(_userModel?.email ?? ""),
            currentAccountPicture: CircleAvatar(
              backgroundColor: Colors.white,
              child: Text(
                (_userModel?.displayName ?? "U")[0].toUpperCase(),
                style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Color(0xFF6200EA)),
              ),
            ),
            decoration: const BoxDecoration(
              color: Color(0xFF6200EA),
            ),
          ),
          if (!isTeacher && _userModel?.studentId != null) ...[
            ListTile(
              leading: const Icon(Icons.badge_outlined),
              title: Text("Student ID: ${_userModel!.studentId}"),
              tileColor: Colors.grey.shade50,
            ),
            const Divider(),
          ],
          if (isTeacher) ...[
            const Padding(
              padding: EdgeInsets.only(left: 16, top: 16, bottom: 8),
              child: Text("Teacher Tools",
                  style: TextStyle(
                      color: Colors.grey, fontWeight: FontWeight.bold)),
            ),
            ListTile(
              leading: const Icon(Icons.history_edu),
              title: const Text('My Curations'),
              onTap: () {
                Navigator.pop(context);
                Navigator.push(
                  context,
                  MaterialPageRoute(
                      builder: (_) => const TeacherHistoryScreen()),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.edit_note),
              title: const Text('Curate Questions'),
              onTap: () {
                Navigator.pop(context);
                if (ModalRoute.of(context)?.settings.name != '/') {
                  Navigator.popUntil(context, (route) => route.isFirst);
                }
              },
            ),
            ListTile(
              leading: const Icon(Icons.analytics),
              title: const Text("Check Student Performance"),
              onTap: () {
                Navigator.pop(context);
                showModalBottomSheet(
                  context: context,
                  isScrollControlled: true,
                  builder: (_) => const StudentLookupSheet(),
                );
              },
            ),
            const Divider(),
          ],
          ListTile(
            leading: const Icon(Icons.person),
            title: const Text('Profile'),
            onTap: () {
              Navigator.pop(context);
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.logout, color: Colors.red),
            title: const Text('Logout', style: TextStyle(color: Colors.red)),
            onTap: () async {
              await AuthService().signOut();
              if (context.mounted) {
                Navigator.of(context).pushAndRemoveUntil(
                  MaterialPageRoute(builder: (context) => const AuthPage()),
                      (route) => false,
                );
              }
            },
          ),
        ],
      ),
    );
  }
}

// ---------------------------------------------------------------------------
//  HELPER 1: TAB CONTAINER (Assignments/Tests)
// ---------------------------------------------------------------------------

class _AssignmentTabContainer extends StatefulWidget {
  final bool isStrict;
  final List<String> submittedCodes;
  final String? resumableAssignmentCode;
  final Future<void> Function() onResumeTap;
  final VoidCallback onViewAnalysisTap;
  final VoidCallback? onRefreshNeeded;

  const _AssignmentTabContainer({
    required this.isStrict,
    required this.submittedCodes,
    required this.resumableAssignmentCode,
    required this.onResumeTap,
    required this.onViewAnalysisTap,
    this.onRefreshNeeded,
  });

  @override
  State<_AssignmentTabContainer> createState() => _AssignmentTabContainerState();
}

class _AssignmentTabContainerState extends State<_AssignmentTabContainer>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Clean Segmented Tab Bar
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          height: 48,
          decoration: BoxDecoration(
            color: Colors.grey.shade200,
            borderRadius: BorderRadius.circular(12),
          ),
          child: TabBar(
            controller: _tabController,
            indicator: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(10),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.08),
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            labelColor: const Color(0xFF6200EA), // Brand Color
            unselectedLabelColor: Colors.grey.shade600,
            labelStyle:
            const TextStyle(fontWeight: FontWeight.w700, fontSize: 14),
            indicatorSize: TabBarIndicatorSize.tab,
            dividerColor: Colors.transparent,
            indicatorPadding: const EdgeInsets.all(4),
            tabs: const [
              Tab(text: "Pending"),
              Tab(text: "Completed"),
            ],
          ),
        ),

        // Lists
        Expanded(
          child: TabBarView(
            controller: _tabController,
            children: [
              StudentAssignmentsList(
                isStrict: widget.isStrict,
                submittedCodes: widget.submittedCodes,
                resumableAssignmentCode: widget.resumableAssignmentCode,
                onResumeTap: widget.onResumeTap,
                onViewAnalysisTap: widget.onViewAnalysisTap,
                showOnlySubmitted: false, // Pending Tab
                onRefreshNeeded: widget.onRefreshNeeded, // PASS DOWN
              ),
              StudentAssignmentsList(
                isStrict: widget.isStrict,
                submittedCodes: widget.submittedCodes,
                resumableAssignmentCode: widget.resumableAssignmentCode,
                onResumeTap: widget.onResumeTap,
                onViewAnalysisTap: widget.onViewAnalysisTap,
                showOnlySubmitted: true, // Completed Tab
                onRefreshNeeded: widget.onRefreshNeeded, // PASS DOWN
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// ---------------------------------------------------------------------------
//  HELPER 2: ANALYSIS VIEW (Redesigned)
// ---------------------------------------------------------------------------

class _AnalysisView extends StatefulWidget {
  const _AnalysisView();

  @override
  State<_AnalysisView> createState() => _AnalysisViewState();
}

class _AnalysisViewState extends State<_AnalysisView> with SingleTickerProviderStateMixin {
  late TabController _mainTabController;

  @override
  void initState() {
    super.initState();
    _mainTabController = TabController(length: 2, vsync: this);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // 1. MAIN TAB BAR (Assignments vs Tests)
        Container(
          margin: const EdgeInsets.fromLTRB(16, 12, 16, 0),
          height: 48,
          decoration: BoxDecoration(
            color: Colors.grey.shade200,
            borderRadius: BorderRadius.circular(12),
          ),
          child: TabBar(
            controller: _mainTabController,
            indicator: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(10),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.08),
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            labelColor: const Color(0xFF6200EA),
            unselectedLabelColor: Colors.grey.shade600,
            labelStyle: const TextStyle(fontWeight: FontWeight.w700, fontSize: 14),
            indicatorSize: TabBarIndicatorSize.tab,
            dividerColor: Colors.transparent,
            indicatorPadding: const EdgeInsets.all(4),
            tabs: const [
              Tab(text: "Assignments"),
              Tab(text: "Tests"),
            ],
          ),
        ),

        // 2. TAB VIEW
        Expanded(
          child: TabBarView(
            controller: _mainTabController,
            children: [
              // TAB A: ASSIGNMENTS (Nested Tabs)
              _buildAssignmentsAnalysisTab(),

              // TAB B: TESTS (Single List)
              // Strict tests are always 'Test' mode and onlySingleAttempt = true
              const AttemptListWidget(filterMode: 'Test', onlySingleAttempt: true),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildAssignmentsAnalysisTab() {
    // Nested DefaultTabController for the sub-tabs
    return DefaultTabController(
      length: 2,
      child: Column(
        children: [
          // Sub-Tabs
          Container(
            margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            height: 36,
            child: const TabBar(
              isScrollable: false,
              labelColor: Colors.deepPurple,
              unselectedLabelColor: Colors.grey,
              indicatorColor: Colors.deepPurple,
              labelStyle: TextStyle(fontWeight: FontWeight.bold, fontSize: 13),
              tabs: [
                Tab(text: "Practice Mode"),
                Tab(text: "Test Mode"),
              ],
            ),
          ),
          // Sub-Tab Views
          const Expanded(
            child: TabBarView(
              children: [
                // Assignments taken in Practice Mode
                AttemptListWidget(filterMode: 'Practice', onlySingleAttempt: false),
                // Assignments taken in Test Mode
                AttemptListWidget(filterMode: 'Test', onlySingleAttempt: false),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/features/student/widgets/student_assignments_list.dart
================================================================================
// lib/features/student/widgets/student_assignments_list.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import 'package:study_smart_qc/models/test_enums.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';

class StudentAssignmentsList extends StatelessWidget {
  final bool isStrict;
  final String? resumableAssignmentCode;
  final VoidCallback? onResumeTap;
  final List<String> submittedCodes;
  final VoidCallback? onViewAnalysisTap;

  // Refresh Callback to update parent UI state
  final VoidCallback? onRefreshNeeded;

  final bool showOnlySubmitted;

  const StudentAssignmentsList({
    super.key,
    required this.isStrict,
    this.resumableAssignmentCode,
    this.onResumeTap,
    this.submittedCodes = const [],
    this.onViewAnalysisTap,
    this.onRefreshNeeded,
    this.showOnlySubmitted = false,
  });

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return const SizedBox.shrink();

    return StreamBuilder<QuerySnapshot>(
      // We removed the .where('status', isEqualTo: 'assigned') filter.
      // We now rely on local logic + the user's submittedCodes list for filtering.
      stream: FirebaseFirestore.instance
          .collection('questions_curation')
          .where('studentUid', isEqualTo: user.uid)
          .orderBy('createdAt', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          return Center(child: Text("Error: ${snapshot.error}"));
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return _buildEmptyState();
        }

        final allDocs = snapshot.data!.docs;

        // LOCAL FILTERING LOGIC
        final filteredDocs = allDocs.where((doc) {
          final data = doc.data() as Map<String, dynamic>;

          // Filter A: Is it a Strict Test (Test) or Homework (Assignment)?
          final bool docIsStrict = data['onlySingleAttempt'] ?? false;
          if (docIsStrict != isStrict) return false;

          // Filter B: Determine bucket based on submittedCodes array from User document
          final String code = data['assignmentCode'] ?? '';
          final bool isSubmitted = submittedCodes.contains(code);

          if (showOnlySubmitted) {
            return isSubmitted; // Show in Completed Tab
          } else {
            return !isSubmitted; // Show in Pending Tab
          }
        }).toList();

        if (filteredDocs.isEmpty) {
          return _buildEmptyState();
        }

        return ListView.builder(
          physics: const AlwaysScrollableScrollPhysics(),
          padding: const EdgeInsets.all(16),
          itemCount: filteredDocs.length,
          itemBuilder: (context, index) {
            final data = filteredDocs[index].data() as Map<String, dynamic>;
            final docId = filteredDocs[index].id;

            final String currentCode = data['assignmentCode'] ?? '----';
            final bool isResumable = (resumableAssignmentCode != null && resumableAssignmentCode == currentCode);
            final bool isSubmitted = submittedCodes.contains(currentCode);

            return Column(
              children: [
                _buildAssignmentCard(context, data, docId, isResumable, isSubmitted),

                // Resumable Session Banner (Pending View Only)
                if (isResumable && !isSubmitted)
                  _buildResumeBanner()

                // Completed/Analysis Banner (Completed View Only)
                else if (isSubmitted)
                  _buildCompletedBanner(context, docId, data)

                else
                  const SizedBox(height: 12),
              ],
            );
          },
        );
      },
    );
  }

  // --- HELPER BANNERS ---

  Widget _buildResumeBanner() {
    return Container(
      margin: const EdgeInsets.only(bottom: 16, left: 4, right: 4),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.deepPurple.shade50,
        borderRadius: const BorderRadius.only(
          bottomLeft: Radius.circular(12),
          bottomRight: Radius.circular(12),
        ),
        border: Border.all(color: Colors.deepPurple.shade200),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Text("Unfinished Session Found",
              style: TextStyle(fontWeight: FontWeight.bold, color: Colors.deepPurple, fontSize: 13)),
          ElevatedButton.icon(
            onPressed: onResumeTap,
            icon: const Icon(Icons.restore, size: 16),
            label: const Text("Resume"),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.deepPurple,
              foregroundColor: Colors.white,
              visualDensity: VisualDensity.compact,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCompletedBanner(BuildContext context, String docId, Map<String, dynamic> data) {
    return Container(
      margin: const EdgeInsets.only(bottom: 16, left: 4, right: 4),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.teal.shade50,
        borderRadius: const BorderRadius.only(
          bottomLeft: Radius.circular(12),
          bottomRight: Radius.circular(12),
        ),
        border: Border.all(color: Colors.teal.shade200),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Text("Completed",
              style: TextStyle(fontWeight: FontWeight.bold, color: Colors.teal, fontSize: 13)),
          Row(
            children: [
              if (!isStrict) // Only assignments allow re-attempts
                Padding(
                  padding: const EdgeInsets.only(right: 8.0),
                  child: TextButton(
                    onPressed: () => _showModeSelectionDialog(context, docId, data),
                    child: const Text("Attempt Again",
                        style: TextStyle(fontWeight: FontWeight.bold, fontSize: 12, color: Colors.teal)),
                  ),
                ),
              ElevatedButton.icon(
                onPressed: onViewAnalysisTap,
                icon: const Icon(Icons.analytics, size: 16),
                label: const Text("Analysis"),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.teal,
                  foregroundColor: Colors.white,
                  visualDensity: VisualDensity.compact,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    String message = showOnlySubmitted ? "No submission history yet" : (isStrict ? "No pending tests!" : "No pending assignments!");
    IconData icon = showOnlySubmitted ? Icons.history_edu : (isStrict ? Icons.timer_off_outlined : Icons.assignment_turned_in_outlined);

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 64, color: Colors.grey.shade300),
          const SizedBox(height: 16),
          Text(message, style: const TextStyle(color: Colors.grey)),
        ],
      ),
    );
  }

  Widget _buildAssignmentCard(BuildContext context, Map<String, dynamic> data, String docId, bool isResumable, bool isSubmitted) {
    final Timestamp? ts = data['createdAt'];
    final dateStr = ts != null ? DateFormat('MMM d, yyyy').format(ts.toDate()) : 'Unknown Date';
    final int questionCount = (data['questionIds'] as List?)?.length ?? 0;
    final String code = data['assignmentCode'] ?? '----';
    final int? storedTime = data['timeLimitMinutes'];
    final String timeDisplay = storedTime != null ? "${storedTime}m" : "${questionCount * 2}m (Est)";

    Color codeBgColor = isSubmitted ? Colors.teal.shade50 : (isStrict ? Colors.red.shade50 : Colors.deepPurple.shade50);
    Color codeTextColor = isSubmitted ? Colors.teal.shade900 : (isStrict ? Colors.red.shade900 : Colors.deepPurple.shade900);
    Color borderColor = isSubmitted ? Colors.teal.shade300 : (isStrict ? Colors.red.shade200 : Colors.deepPurple.shade200);

    return Card(
      elevation: (isResumable || isSubmitted) ? 4 : 2,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: (isResumable || isSubmitted)
            ? const BorderRadius.only(topLeft: Radius.circular(12), topRight: Radius.circular(12))
            : BorderRadius.circular(12),
        side: isResumable ? BorderSide(color: Colors.deepPurple.shade300, width: 1.5) : BorderSide.none,
      ),
      child: InkWell(
        borderRadius: (isResumable || isSubmitted)
            ? const BorderRadius.only(topLeft: Radius.circular(12), topRight: Radius.circular(12))
            : BorderRadius.circular(12),
        onTap: () => _showModeSelectionDialog(context, docId, data),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                    decoration: BoxDecoration(color: codeBgColor, borderRadius: BorderRadius.circular(4), border: Border.all(color: borderColor)),
                    child: Text("CODE: $code", style: TextStyle(fontSize: 10, fontWeight: FontWeight.bold, color: codeTextColor)),
                  ),
                  Text(dateStr, style: const TextStyle(fontSize: 12, color: Colors.grey)),
                ],
              ),
              const SizedBox(height: 10),
              Text(data['title'] ?? "Untitled Assignment", style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
              const SizedBox(height: 5),
              Row(
                children: [
                  Icon(Icons.quiz, size: 14, color: Colors.grey.shade600),
                  const SizedBox(width: 4),
                  Text("$questionCount Qs", style: TextStyle(fontSize: 13, color: Colors.grey.shade700)),
                  const SizedBox(width: 15),
                  Icon(Icons.timer, size: 14, color: Colors.grey.shade600),
                  const SizedBox(width: 4),
                  Text(timeDisplay, style: TextStyle(fontSize: 13, color: Colors.grey.shade700)),
                  if (isSubmitted) ...[
                    const Spacer(),
                    const Icon(Icons.check_circle, size: 18, color: Colors.teal),
                    const SizedBox(width: 4),
                    Text("Done", style: TextStyle(color: Colors.teal.shade700, fontWeight: FontWeight.bold, fontSize: 12)),
                  ]
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showModeSelectionDialog(BuildContext context, String docId, Map<String, dynamic> data) {
    final questionIds = List<String>.from(data['questionIds'] ?? []);
    final String code = data['assignmentCode'] ?? '----';
    final String title = data['title'] ?? "Untitled Assignment";
    final bool isStrictAssignment = data['onlySingleAttempt'] ?? false;
    final int timeLimit = data['timeLimitMinutes'] ?? (questionIds.length * 2);

    showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text("Start Session"),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text("Title: $title"),
              const SizedBox(height: 10),
              Text("Questions: ${questionIds.length}"),
              Text("Time Limit: $timeLimit mins"),
              const SizedBox(height: 10),
              if (isStrictAssignment)
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(color: Colors.red.shade50, borderRadius: BorderRadius.circular(4), border: Border.all(color: Colors.red.shade200)),
                  child: const Row(
                    children: [
                      Icon(Icons.warning_amber_rounded, size: 16, color: Colors.red),
                      SizedBox(width: 8),
                      Expanded(
                        child: Text("Single Attempt Only.", style: TextStyle(fontSize: 12, color: Colors.red, fontWeight: FontWeight.bold)),
                      ),
                    ],
                  ),
                ),
            ],
          ),
          actions: [
            if (!isStrictAssignment)
              OutlinedButton(
                onPressed: () {
                  Navigator.pop(ctx);
                  _launchTest(context, docId, code, title, questionIds, TestMode.practice, timeLimit, isStrictAssignment);
                },
                child: const Text("Practice Mode"),
              ),
            ElevatedButton(
              onPressed: () {
                Navigator.pop(ctx);
                _launchTest(context, docId, code, title, questionIds, TestMode.test, timeLimit, isStrictAssignment);
              },
              style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple, foregroundColor: Colors.white),
              child: const Text("Test Mode"),
            ),
          ],
        )
    );
  }

  Future<void> _launchTest(
      BuildContext context,
      String assignmentId,
      String assignmentCode,
      String title,
      List<String> questionIds,
      TestMode mode,
      int timeLimit,
      bool onlySingleAttempt,
      ) async {
    showDialog(context: context, barrierDismissible: false, builder: (ctx) => const Center(child: CircularProgressIndicator()));

    try {
      final questions = await TestOrchestrationService().getQuestionsByIds(questionIds);
      if (!context.mounted) return;
      Navigator.pop(context);

      if (questions.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Error: Questions not found.")));
        return;
      }

      await Navigator.push(
          context,
          MaterialPageRoute(
              builder: (_) => TestScreen(
                sourceId: assignmentId,
                assignmentCode: assignmentCode,
                title: title,
                questions: questions,
                timeLimitInMinutes: timeLimit,
                testMode: mode,
                onlySingleAttempt: onlySingleAttempt,
              )
          )
      );

      if (onRefreshNeeded != null) {
        onRefreshNeeded!();
      }

    } catch (e) {
      if (context.mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    }
  }
}

================================================================================
FILE: lib/features/teacher/screens/curation_management_screen.dart
================================================================================
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

// MODELS
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';

// SERVICES
import 'package:study_smart_qc/services/teacher_service.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';

// WIDGETS
import 'package:study_smart_qc/features/common/widgets/question_preview_card.dart';
import 'package:study_smart_qc/features/analytics/widgets/attempt_display_card.dart';
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';

class CurationManagementScreen extends StatefulWidget {
  final String curationId;
  final String title;

  const CurationManagementScreen({
    Key? key,
    required this.curationId,
    required this.title,
  }) : super(key: key);

  @override
  State<CurationManagementScreen> createState() =>
      _CurationManagementScreenState();
}

class _CurationManagementScreenState extends State<CurationManagementScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final TeacherService _teacherService = TeacherService();

  // --- DATA STATE (Content Tab) ---
  StreamSubscription<DocumentSnapshot>? _curationSubscription;
  List<String> _questionIds = [];
  bool _isLoaded = false;

  // --- CACHE (Content Tab) ---
  final Map<String, Question> _questionCache = {};
  final Set<String> _attemptedFetches = {};
  bool _isLoadingQuestions = false;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _setupFirestoreListener();
  }

  @override
  void dispose() {
    _curationSubscription?.cancel();
    _tabController.dispose();
    super.dispose();
  }

  // ===========================================================================
  // LOGIC: CONTENT MANAGEMENT
  // ===========================================================================

  void _setupFirestoreListener() {
    _curationSubscription = FirebaseFirestore.instance
        .collection('questions_curation')
        .doc(widget.curationId)
        .snapshots()
        .listen((snapshot) {
      if (snapshot.exists && mounted) {
        final data = snapshot.data() as Map<String, dynamic>;
        final newIds = List<String>.from(data['questionIds'] ?? []);

        setState(() {
          _questionIds = newIds;
          _isLoaded = true;
        });

        _ensureQuestionsLoaded(newIds);
      }
    }, onError: (e) {
      debugPrint("Error listening to curation: $e");
    });
  }

  Future<void> _ensureQuestionsLoaded(List<String> questionIds) async {
    final idsToFetch = questionIds.where((id) =>
    !_questionCache.containsKey(id) && !_attemptedFetches.contains(id)
    ).toList();

    if (idsToFetch.isEmpty) return;
    if (_isLoadingQuestions) return;

    Future.microtask(() async {
      if (!mounted) return;
      setState(() => _isLoadingQuestions = true);
      _attemptedFetches.addAll(idsToFetch);

      try {
        final questions = await TestOrchestrationService().getQuestionsByIds(idsToFetch);
        if (mounted) {
          setState(() {
            for (var q in questions) {
              _questionCache[q.id] = q;
            }
          });
        }
      } catch (e) {
        debugPrint("Error loading questions: $e");
      } finally {
        if (mounted) setState(() => _isLoadingQuestions = false);
      }
    });
  }

  Future<void> _handleReorder(int oldIndex, String newIndexStr) async {
    int? newIndex = int.tryParse(newIndexStr);
    if (newIndex == null) {
      _showSafeSnackBar("Please enter a valid number");
      return;
    }

    int targetIndex = newIndex - 1;
    if (targetIndex < 0 || targetIndex >= _questionIds.length) {
      _showSafeSnackBar("Position must be between 1 and ${_questionIds.length}");
      return;
    }
    if (targetIndex == oldIndex) return;

    FocusScope.of(context).unfocus();

    final movedId = _questionIds[oldIndex];
    final newList = List<String>.from(_questionIds);
    newList.removeAt(oldIndex);
    newList.insert(targetIndex, movedId);

    setState(() => _questionIds = newList);

    try {
      await _teacherService.updateQuestionOrder(widget.curationId, newList);
      _showSafeSnackBar("Reordered successfully");
    } catch (e) {
      _showSafeSnackBar("Error saving order: $e");
    }
  }

  Future<void> _promptAndRandomize() async {
    if (_questionIds.isEmpty) return;
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Randomize Order"),
        content: const Text("Are you sure you want to shuffle all questions? This cannot be undone."),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("Cancel")),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple, foregroundColor: Colors.white),
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text("Shuffle"),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    final shuffledList = List<String>.from(_questionIds)..shuffle();
    setState(() => _questionIds = shuffledList);

    try {
      await _teacherService.updateQuestionOrder(widget.curationId, shuffledList);
      _showSafeSnackBar("Questions shuffled successfully!");
    } catch (e) {
      _showSafeSnackBar("Error shuffling: $e");
    }
  }

  // ===========================================================================
  // LOGIC: PERFORMANCE TAB
  // ===========================================================================

  Future<void> _navigateToResults(AttemptModel attempt) async {
    // 1. Show Loading
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final service = TestOrchestrationService();

      // 2. Fetch full question objects
      // We assume attempt.responses contains all keys, but for safety we use the curation list if available
      List<String> qIdsToFetch = attempt.responses.keys.toList();
      if (qIdsToFetch.isEmpty) qIdsToFetch = _questionIds;

      final questions = await service.getQuestionsByIds(qIdsToFetch);

      // 3. Reconstruct Answer States
      Map<int, AnswerState> answerStates = {};
      for (int i = 0; i < questions.length; i++) {
        final q = questions[i];
        final response = attempt.responses[q.id];

        AnswerStatus status = AnswerStatus.notVisited;
        if (response != null) {
          if (response.status == 'CORRECT' || response.status == 'INCORRECT') {
            status = AnswerStatus.answered;
          } else if (response.status == 'SKIPPED') {
            status = AnswerStatus.notAnswered;
          }
        }

        answerStates[i] = AnswerState(
          status: status,
          userAnswer: response?.selectedOption,
        );
      }

      // 4. Build Result Object
      final result = TestResult(
        attemptId: attempt.id,
        questions: questions,
        answerStates: answerStates,
        timeTaken: Duration(seconds: attempt.timeTakenSeconds),
        totalMarks: questions.length * 4,
        responses: attempt.responses,
      );

      if (mounted) {
        Navigator.pop(context); // Close loader
        // 5. Navigate
        Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => ResultsScreen(result: result)),
        );
      }
    } catch (e) {
      if (mounted) {
        Navigator.pop(context);
        _showSafeSnackBar("Error opening results: $e");
      }
    }
  }

  void _showSafeSnackBar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message), duration: const Duration(seconds: 2)),
    );
  }

  // ===========================================================================
  // UI BUILDERS
  // ===========================================================================

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      resizeToAvoidBottomInset: false,
      appBar: AppBar(
        title: Text(widget.title),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
        bottom: TabBar(
          controller: _tabController,
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          indicatorColor: Colors.yellowAccent,
          tabs: const [
            Tab(icon: Icon(Icons.edit_note), text: "Manage Content"),
            Tab(icon: Icon(Icons.bar_chart), text: "Performance"),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildManageContentTab(),
          _buildPerformanceTab(),
        ],
      ),
    );
  }

  Widget _buildManageContentTab() {
    if (!_isLoaded) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_questionIds.isEmpty) {
      return const Center(child: Text("No questions in this curation."));
    }

    return Column(
      children: [
        // Header
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          decoration: BoxDecoration(
            color: Colors.grey.shade50,
            border: Border(bottom: BorderSide(color: Colors.grey.shade300)),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                "${_questionIds.length} Questions",
                style: TextStyle(fontWeight: FontWeight.bold, color: Colors.grey.shade700),
              ),
              ElevatedButton.icon(
                onPressed: _promptAndRandomize,
                icon: const Icon(Icons.shuffle, size: 18),
                label: const Text("Randomize Order"),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange.shade600,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                ),
              ),
            ],
          ),
        ),

        // List
        Expanded(
          child: ListView.builder(
            padding: EdgeInsets.only(
              left: 16,
              right: 16,
              top: 16,
              bottom: MediaQuery.of(context).viewInsets.bottom + 100,
            ),
            itemCount: _questionIds.length,
            itemBuilder: (context, index) {
              final qId = _questionIds[index];
              final question = _questionCache[qId];

              return QuestionReorderTile(
                key: ValueKey(qId),
                index: index,
                questionId: qId,
                questionData: question,
                onReorder: (newPos) => _handleReorder(index, newPos),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildPerformanceTab() {
    return FutureBuilder<AttemptModel?>(
      future: _teacherService.getAttemptForCuration(widget.curationId),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          return Center(child: Text("Error: ${snapshot.error}"));
        }

        final attempt = snapshot.data;

        if (attempt == null) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.pending_actions, size: 60, color: Colors.grey.shade300),
                const SizedBox(height: 16),
                const Text(
                  "Student has not attempted this test yet.",
                  style: TextStyle(color: Colors.grey, fontSize: 16),
                ),
              ],
            ),
          );
        }

        // REUSING EXISTING WIDGET
        return Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            children: [
              const Text(
                "Latest Attempt",
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.deepPurple),
              ),
              const SizedBox(height: 20),
              AttemptDisplayCard(
                attempt: attempt,
                onTap: () => _navigateToResults(attempt),
              ),
            ],
          ),
        );
      },
    );
  }
}

// --------------------------------------------------------------------------
// ISOLATED TILE WIDGET (Kept same as before)
// --------------------------------------------------------------------------

class QuestionReorderTile extends StatefulWidget {
  final int index;
  final String questionId;
  final Question? questionData;
  final Function(String) onReorder;

  const QuestionReorderTile({
    Key? key,
    required this.index,
    required this.questionId,
    required this.questionData,
    required this.onReorder,
  }) : super(key: key);

  @override
  State<QuestionReorderTile> createState() => _QuestionReorderTileState();
}

class _QuestionReorderTileState extends State<QuestionReorderTile>
    with AutomaticKeepAliveClientMixin {
  final TextEditingController _posController = TextEditingController();

  @override
  bool get wantKeepAlive => true;

  @override
  void dispose() {
    _posController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);

    return Card(
      margin: const EdgeInsets.only(bottom: 24),
      elevation: 3,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      clipBehavior: Clip.antiAlias,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Control Bar
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              border: Border(bottom: BorderSide(color: Colors.grey.shade300)),
            ),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: const BoxDecoration(
                    color: Colors.deepPurple,
                    shape: BoxShape.circle,
                  ),
                  child: Text(
                    "${widget.index + 1}",
                    style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                  ),
                ),
                const SizedBox(width: 10),
                const Text(
                  "Position",
                  style: TextStyle(fontWeight: FontWeight.bold, color: Colors.black87),
                ),
                const Spacer(),
                SizedBox(
                  width: 50,
                  height: 35,
                  child: TextField(
                    controller: _posController,
                    keyboardType: TextInputType.number,
                    textAlign: TextAlign.center,
                    decoration: const InputDecoration(
                      hintText: "#",
                      contentPadding: EdgeInsets.zero,
                      border: OutlineInputBorder(),
                      filled: true,
                      fillColor: Colors.white,
                    ),
                    onSubmitted: (val) {
                      if (val.isNotEmpty) {
                        widget.onReorder(val);
                        _posController.clear();
                      }
                    },
                  ),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurple,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 0),
                    minimumSize: const Size(0, 35),
                    tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                  ),
                  onPressed: () {
                    if (_posController.text.isNotEmpty) {
                      widget.onReorder(_posController.text);
                      _posController.clear();
                    }
                  },
                  child: const Text("Move"),
                ),
              ],
            ),
          ),
          if (widget.questionData != null)
            QuestionPreviewCard(
              question: widget.questionData!,
              isExpanded: true,
            )
          else
            Container(
              height: 150,
              alignment: Alignment.center,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const SizedBox(
                    width: 24, height: 24,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  ),
                  const SizedBox(height: 10),
                  Text("Loading QID: ${widget.questionId}", style: const TextStyle(color: Colors.grey, fontSize: 12)),
                ],
              ),
            ),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/features/teacher/screens/teacher_curation_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/teacher_service.dart';
import 'package:study_smart_qc/features/teacher/screens/teacher_filter_screen.dart';

class TeacherCurationScreen extends StatefulWidget {
  const TeacherCurationScreen({super.key});

  @override
  State<TeacherCurationScreen> createState() => _TeacherCurationScreenState();
}

class _TeacherCurationScreenState extends State<TeacherCurationScreen> {
  final TeacherService _teacherService = TeacherService();
  final TextEditingController _studentIdController = TextEditingController();

  // State
  String _targetAudience = 'Particular Student'; // 'General', 'Particular Student', 'Batch'
  bool _isLoadingStats = false;
  Map<String, int>? _studentStats;

  void _fetchStats() async {
    final idStr = _studentIdController.text.trim();
    if (idStr.isEmpty) return;

    setState(() => _isLoadingStats = true);
    try {
      final stats = await _teacherService.getStudentStats(int.parse(idStr));
      setState(() => _studentStats = stats);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    } finally {
      if (mounted) setState(() => _isLoadingStats = false);
    }
  }

  void _onNextPressed() {
    if (_targetAudience == 'Particular Student' && _studentIdController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Please enter a Student ID")));
      return;
    }

    // Navigate to Step 2 (Filters)
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => TeacherFilterScreen(
          audienceType: _targetAudience,
          studentId: _studentIdController.text.isNotEmpty ? int.parse(_studentIdController.text) : null,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Questions Curation'),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 1. Audience
            _buildSectionHeader('1. Target Audience'),
            Wrap(
              spacing: 10,
              children: ['General', 'Particular Student', 'Batch'].map((type) {
                return ChoiceChip(
                  label: Text(type),
                  selected: _targetAudience == type,
                  onSelected: (selected) {
                    if (selected) setState(() {
                      _targetAudience = type;
                      _studentStats = null; // Reset stats on change
                    });
                  },
                );
              }).toList(),
            ),

            const SizedBox(height: 30),

            // 2. Student Input (Conditional)
            if (_targetAudience == 'Particular Student') ...[
              _buildSectionHeader('2. Student Details'),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _studentIdController,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                        labelText: 'Enter Student ID',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.person),
                      ),
                      onChanged: (_) => setState(() => _studentStats = null), // Clear stats on edit
                    ),
                  ),
                  const SizedBox(width: 10),
                  ElevatedButton(
                    onPressed: _fetchStats,
                    child: const Text("Load Stats"),
                  ),
                ],
              ),
              const SizedBox(height: 20),

              if (_isLoadingStats)
                const Center(child: CircularProgressIndicator())
              else if (_studentStats != null)
                _buildStatsGrid(),
            ],

            const SizedBox(height: 40),

            // 3. Next Action
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.deepPurple,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                onPressed: _onNextPressed,
                child: const Text('Next', style: TextStyle(fontSize: 18)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 10.0),
      child: Text(title, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.grey)),
    );
  }

  Widget _buildStatsGrid() {
    if (_studentStats!.isEmpty) return const Text("No data found for this student.");

    return GridView.count(
      shrinkWrap: true,
      crossAxisCount: 3,
      childAspectRatio: 1.5,
      physics: const NeverScrollableScrollPhysics(),
      mainAxisSpacing: 10,
      crossAxisSpacing: 10,
      children: _studentStats!.entries.map((e) {
        return Card(
          color: Colors.deepPurple.shade50,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(e.value.toString(), style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Colors.deepPurple)),
              Text(e.key, style: const TextStyle(fontSize: 12, color: Colors.grey)),
            ],
          ),
        );
      }).toList(),
    );
  }
}

================================================================================
FILE: lib/features/teacher/screens/teacher_filter_screen.dart
================================================================================
// lib/features/teacher/screens/teacher_filter_screen.dart

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/common/widgets/question_preview_card.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/services/teacher_service.dart';

// --- Helper Model to store parsed Syllabus Data ---
class SyllabusChapter {
  final String id;
  final String name;
  final Map<String, String> topics; // key: id, value: display name

  SyllabusChapter({required this.id, required this.name, required this.topics});
}

class TeacherFilterScreen extends StatefulWidget {
  final String audienceType;
  final int? studentId;

  const TeacherFilterScreen({
    super.key,
    required this.audienceType,
    this.studentId,
  });

  @override
  State<TeacherFilterScreen> createState() => _TeacherFilterScreenState();
}

class _TeacherFilterScreenState extends State<TeacherFilterScreen>
    with SingleTickerProviderStateMixin {
  final TeacherService _teacherService = TeacherService();
  late TabController _tabController;

  // --- 1. DYNAMIC DATA STATE ---
  bool _isLoadingFilters = true;
  List<String> _examsList = [];
  List<String> _subjectsList = [];

  // Cache: Subject (lowercase) -> List of parsed Chapters
  final Map<String, List<SyllabusChapter>> _syllabusCache = {};

  // --- 2. FILTER STATE ---
  String? _selectedExam;
  String? _selectedSubject;
  final Set<String> _selectedChapters = {};
  final Set<String> _selectedTopics = {};
  bool _isPyqOnly = false;

  // --- 3. SEARCH STATE ---
  bool _isSearching = false;
  List<Question> _searchResults = [];
  int _totalMatchCount = 0; // <--- ADDED: To store total count from DB

  // --- 4. SELECTION STATE (The Cart) ---
  final Map<String, Question> _selectedQuestions = {};

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _fetchFilterData();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  // --- DATA FETCHING & PARSING (Kept same as previous working version) ---
  Future<void> _fetchFilterData() async {
    try {
      final firestore = FirebaseFirestore.instance;
      final optionsDoc = await firestore.collection('static_data').doc('option_sets').get();
      if (optionsDoc.exists) {
        final data = optionsDoc.data()!;
        _examsList = List<String>.from(data['exams_list'] ?? []);
        _subjectsList = List<String>.from(data['subjects_list'] ?? []);
      }

      final syllabusDoc = await firestore.collection('static_data').doc('syllabus').get();
      if (syllabusDoc.exists) {
        final data = syllabusDoc.data()!;
        if (data.containsKey('subjects') && data['subjects'] is Map) {
          final subjectsMap = data['subjects'] as Map<String, dynamic>;
          subjectsMap.forEach((subjectKey, subjectVal) {
            if (subjectVal is Map && subjectVal.containsKey('chapters')) {
              final chaptersMap = subjectVal['chapters'] as Map<String, dynamic>;
              List<SyllabusChapter> parsedChapters = [];
              chaptersMap.forEach((chapKey, chapVal) {
                if (chapVal is Map) {
                  String name = chapVal['name'] ?? chapKey;
                  Map<String, String> topics = {};
                  if (chapVal.containsKey('topics') && chapVal['topics'] is Map) {
                    final topicRaw = chapVal['topics'] as Map<String, dynamic>;
                    topicRaw.forEach((tKey, tVal) {
                      topics[tKey] = tVal.toString();
                    });
                  }
                  parsedChapters.add(SyllabusChapter(id: chapKey, name: name, topics: topics));
                }
              });
              parsedChapters.sort((a, b) => a.name.compareTo(b.name));
              _syllabusCache[subjectKey.toLowerCase()] = parsedChapters;
            }
          });
        }
      }
      setState(() { _isLoadingFilters = false; });
    } catch (e) {
      debugPrint("Error loading filters: $e");
      setState(() { _isLoadingFilters = false; });
    }
  }

  // --- CASCADING GETTERS ---
  String _normalizeSubject(String? subject) {
    if (subject == null) return "";
    return subject.toLowerCase().trim();
  }

  List<String> get _currentChaptersList {
    if (_selectedSubject == null) return [];
    String key = _normalizeSubject(_selectedSubject);
    final chapters = _syllabusCache[key] ?? [];
    return chapters.map((c) => c.name).toList();
  }

  List<String> get _currentTopicsList {
    if (_selectedChapters.isEmpty || _selectedSubject == null) return [];
    String key = _normalizeSubject(_selectedSubject);
    final allChapters = _syllabusCache[key] ?? [];
    final selectedChaps = allChapters.where((c) => _selectedChapters.contains(c.name));
    List<String> topics = [];
    for (var chap in selectedChaps) {
      topics.addAll(chap.topics.values);
    }
    return topics.toSet().toList()..sort();
  }

  void _resetFiltersBelow(String level) {
    setState(() {
      if (level == 'Exam') {
        _selectedSubject = null;
        _selectedChapters.clear();
        _selectedTopics.clear();
      } else if (level == 'Subject') {
        _selectedChapters.clear();
        _selectedTopics.clear();
      } else if (level == 'Chapter') {
        _selectedTopics.clear();
      }
    });
  }

  // --- SEARCH LOGIC (UPDATED WITH COUNT) ---
  String _generateRandomId() {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final rnd = Random();
    return String.fromCharCodes(Iterable.generate(20, (_) => chars.codeUnitAt(rnd.nextInt(chars.length))));
  }

  Future<void> _performSearch() async {
    if (_selectedExam == null || _selectedSubject == null) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Please select Exam and Subject")));
      return;
    }

    setState(() {
      _isSearching = true;
      _searchResults = [];
      _totalMatchCount = 0; // Reset count
    });

    try {
      Query query = FirebaseFirestore.instance.collection('questions');

      // 1. Build Base Query (Exact Matching)
      query = query.where('Exam', isEqualTo: _selectedExam);
      query = query.where('Subject', isEqualTo: _selectedSubject);

      if (_selectedChapters.isNotEmpty && _selectedChapters.length <= 10) {
        query = query.where('Chapter', whereIn: _selectedChapters.toList());
      }
      if (_selectedTopics.isNotEmpty && _selectedTopics.length <= 10) {
        query = query.where('Topic', whereIn: _selectedTopics.toList());
      }
      if (_isPyqOnly) {
        query = query.where('PYQ', isEqualTo: "Yes");
      }

      // --- ADDED: Fetch Total Count ---
      // We run this separately to get the total number of documents matching filters
      AggregateQuerySnapshot countSnapshot = await query.count().get();
      int totalCount = countSnapshot.count ?? 0;
      // --------------------------------

      // 2. Randomization Logic
      String randomAnchor = _generateRandomId();
      Query randomQuery = query.orderBy(FieldPath.documentId).startAt([randomAnchor]).limit(50);

      QuerySnapshot snapshot = await randomQuery.get();
      if (snapshot.docs.isEmpty) {
        // Fallback to start if random index hit the end
        snapshot = await query.limit(50).get();
      }

      List<Question> fetched = snapshot.docs
          .map((doc) => Question.fromFirestore(doc))
          .toList();

      // 3. Client-side filtering (if > 10 items selected)
      if (_selectedChapters.length > 10) {
        fetched = fetched.where((q) => _selectedChapters.contains(q.chapter)).toList();
        // Note: If filtering client-side, the 'totalCount' from server might be higher
        // than actual local matches, but it's the best approximation without expensive reads.
      }
      if (_selectedTopics.length > 10) {
        fetched = fetched.where((q) => _selectedTopics.contains(q.topic)).toList();
      }

      fetched.shuffle();
      if (fetched.length > 20) fetched = fetched.sublist(0, 20);

      setState(() {
        _searchResults = fetched;
        _totalMatchCount = totalCount; // Update State
      });

    } catch (e) {
      debugPrint("Search Error: $e");
      String msg = "Error fetching data.";
      if (e.toString().contains("failed-precondition")) msg = "Missing Index. Check debug console.";
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
    } finally {
      setState(() {
        _isSearching = false;
      });
    }
  }

  void _toggleSelection(Question q) {
    setState(() {
      if (_selectedQuestions.containsKey(q.id)) {
        _selectedQuestions.remove(q.id);
      } else {
        _selectedQuestions[q.id] = q;
      }
    });
  }

  // --- ASSIGNMENT LOGIC (Kept same) ---
  Future<void> _onAssign() async {
    if (_selectedQuestions.isEmpty) return;
    final teacher = FirebaseAuth.instance.currentUser;
    if (teacher == null) return;

    final titleCtrl = TextEditingController(text: "Homework - ${DateTime.now().toString().split(' ')[0]}");
    final timeCtrl = TextEditingController(text: "${_selectedQuestions.length * 2}");
    bool isSingleAttempt = false;

    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            title: const Text("Confirm Assignment"),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text("Assigning ${_selectedQuestions.length} questions."),
                  const SizedBox(height: 15),
                  TextField(controller: titleCtrl, decoration: const InputDecoration(labelText: "Assignment Title", border: OutlineInputBorder())),
                  const SizedBox(height: 15),
                  TextField(controller: timeCtrl, keyboardType: TextInputType.number, decoration: const InputDecoration(labelText: "Time Limit (Min)", border: OutlineInputBorder())),
                  const SizedBox(height: 10),
                  CheckboxListTile(
                    title: const Text("Strict Mode (Single Attempt)"),
                    value: isSingleAttempt,
                    onChanged: (val) => setDialogState(() => isSingleAttempt = val ?? false),
                    controlAffinity: ListTileControlAffinity.leading,
                    contentPadding: EdgeInsets.zero,
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("Cancel")),
              ElevatedButton(onPressed: () => Navigator.pop(ctx, true), child: const Text("Assign")),
            ],
          );
        },
      ),
    );

    if (confirm != true) return;

    try {
      int? customTime = int.tryParse(timeCtrl.text.trim());
      await _teacherService.assignQuestionsToStudent(
        studentId: widget.studentId!,
        questions: _selectedQuestions.values.toList(),
        teacherUid: teacher.uid,
        targetAudience: widget.audienceType,
        assignmentTitle: titleCtrl.text,
        onlySingleAttempt: isSingleAttempt,
        timeLimitMinutes: customTime,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Assigned Successfully!")));
        Navigator.pop(context);
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
    }
  }

  // --- UI COMPONENTS ---
  void _showMultiSelectDialog({required String title, required List<String> items, required Set<String> selectedItems, required Function(Set<String>) onConfirm}) {
    showDialog(
      context: context,
      builder: (context) {
        Set<String> localSelected = Set.from(selectedItems);
        String searchQuery = "";
        return StatefulBuilder(
          builder: (context, setDialogState) {
            final filteredItems = items.where((item) => item.toLowerCase().contains(searchQuery.toLowerCase())).toList();
            return Dialog(
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              child: Container(
                constraints: BoxConstraints(maxHeight: MediaQuery.of(context).size.height * 0.7),
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
                    const SizedBox(height: 10),
                    TextField(
                      decoration: const InputDecoration(hintText: "Search...", prefixIcon: Icon(Icons.search), border: OutlineInputBorder()),
                      onChanged: (val) => setDialogState(() => searchQuery = val),
                    ),
                    const SizedBox(height: 10),
                    Expanded(
                      child: ListView.builder(
                        itemCount: filteredItems.length,
                        itemBuilder: (context, index) {
                          final item = filteredItems[index];
                          final isSelected = localSelected.contains(item);
                          return CheckboxListTile(
                            title: Text(item),
                            value: isSelected,
                            activeColor: Colors.deepPurple,
                            onChanged: (val) => setDialogState(() { val == true ? localSelected.add(item) : localSelected.remove(item); }),
                          );
                        },
                      ),
                    ),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton(onPressed: () => Navigator.pop(context), child: const Text("Cancel")),
                        const SizedBox(width: 8),
                        ElevatedButton(
                          onPressed: () { onConfirm(localSelected); Navigator.pop(context); },
                          child: const Text("Done"),
                        ),
                      ],
                    )
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Filter & Search"),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
        bottom: TabBar(
          controller: _tabController,
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          indicatorColor: Colors.yellowAccent,
          tabs: [
            const Tab(text: "Search Results"),
            Tab(text: "Selected (${_selectedQuestions.length})"),
          ],
        ),
      ),
      body: _isLoadingFilters
          ? const Center(child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [CircularProgressIndicator(), SizedBox(height: 10), Text("Loading Syllabus...")]))
          : TabBarView(
        controller: _tabController,
        children: [
          _buildSearchTab(),
          _buildSelectedTab(),
        ],
      ),
    );
  }

  Widget _buildSearchTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildFilters(),

          const SizedBox(height: 20),

          SizedBox(
            width: double.infinity,
            child: ElevatedButton.icon(
              icon: const Icon(Icons.search),
              label: const Text("Search & Shuffle"),
              style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple, foregroundColor: Colors.white, padding: const EdgeInsets.symmetric(vertical: 14)),
              onPressed: _performSearch,
            ),
          ),

          const Divider(height: 40),

          if (_isSearching)
            const Center(child: CircularProgressIndicator())
          else if (_searchResults.isEmpty && _totalMatchCount == 0)
          // Only show 'No questions' if we haven't searched yet or truly found nothing
            const Center(child: Text("Adjust filters and click Search.", style: TextStyle(color: Colors.grey)))
          else
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // --- ADDED: Display Total Count ---
                Text(
                    "Showing ${_searchResults.length} of $_totalMatchCount Results (Randomized)",
                    style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.black87, fontSize: 16)
                ),
                const SizedBox(height: 10),
                if (_searchResults.isEmpty)
                  const Padding(padding: EdgeInsets.all(8.0), child: Text("No items fetched. Try searching again.", style: TextStyle(color: Colors.red))),

                ListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: _searchResults.length,
                  itemBuilder: (context, index) {
                    final q = _searchResults[index];
                    final isSelected = _selectedQuestions.containsKey(q.id);
                    return Card(
                      elevation: 2,
                      margin: const EdgeInsets.only(bottom: 12),
                      child: Padding(
                        padding: const EdgeInsets.all(8.0),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Checkbox(value: isSelected, onChanged: (val) => _toggleSelection(q)),
                            Expanded(
                              child: QuestionPreviewCard(question: q),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              ],
            ),
        ],
      ),
    );
  }

  Widget _buildSelectedTab() {
    if (_selectedQuestions.isEmpty) {
      return const Center(child: Text("No questions selected."));
    }

    // Convert map values to list for display
    final selectedList = _selectedQuestions.values.toList();

    return Stack(
      children: [
        ListView.builder(
          // Add padding at bottom so the list isn't hidden behind the Assign button
          padding: const EdgeInsets.fromLTRB(16, 16, 16, 100),
          itemCount: selectedList.length,
          itemBuilder: (context, index) {
            final q = selectedList[index];

            return Card(
              elevation: 2,
              margin: const EdgeInsets.only(bottom: 12),
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Checkbox is always checked here. Unchecking it removes from list.

                    Expanded(
                      child: QuestionPreviewCard(question: q),
                    ),
                    // Optional: Keep a delete icon for explicit removal if preferred,
                    // but the checkbox does the same thing.
                    IconButton(
                      icon: const Icon(Icons.delete_outline, color: Colors.red),
                      onPressed: () => _toggleSelection(q),
                    ),
                  ],
                ),
              ),
            );
          },
        ),

        // Assign Button (Floating at bottom)
        Positioned(
          bottom: 20,
          left: 20,
          right: 20,
          child: ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.green,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(vertical: 16),
              elevation: 4,
            ),
            onPressed: _onAssign,
            child: Text(
                "Assign ${_selectedQuestions.length} Questions",
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)
            ),
          ),
        ),
      ],
    );
  }


  Widget _buildFilters() {
    final decoration = InputDecoration(border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)), contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 15));

    return Column(
      children: [
        DropdownButtonFormField<String>(
          value: _selectedExam,
          hint: const Text("Select Exam"),
          items: _examsList.map((e) => DropdownMenuItem(value: e, child: Text(e))).toList(),
          onChanged: (val) => setState(() { _selectedExam = val; _resetFiltersBelow('Exam'); }),
          decoration: decoration.copyWith(labelText: "Exam"),
        ),
        const SizedBox(height: 10),
        DropdownButtonFormField<String>(
          value: _selectedSubject,
          hint: const Text("Select Subject"),
          items: _subjectsList.map((s) => DropdownMenuItem(value: s, child: Text(s))).toList(),
          onChanged: (val) => setState(() { _selectedSubject = val; _resetFiltersBelow('Subject'); }),
          decoration: decoration.copyWith(labelText: "Subject"),
        ),
        const SizedBox(height: 10),
        InkWell(
          onTap: _selectedSubject == null || _currentChaptersList.isEmpty
              ? null
              : () => _showMultiSelectDialog(
            title: "Select Chapters",
            items: _currentChaptersList,
            selectedItems: _selectedChapters,
            onConfirm: (set) => setState(() { _selectedChapters.clear(); _selectedChapters.addAll(set); _resetFiltersBelow('Chapter'); }),
          ),
          child: InputDecorator(
            decoration: decoration.copyWith(labelText: "Chapters", suffixIcon: const Icon(Icons.arrow_drop_down)),
            child: Text(_selectedChapters.isEmpty ? "All" : "${_selectedChapters.length} Selected", maxLines: 1, overflow: TextOverflow.ellipsis),
          ),
        ),
        const SizedBox(height: 10),
        InkWell(
          onTap: _selectedChapters.isEmpty || _currentTopicsList.isEmpty
              ? null
              : () => _showMultiSelectDialog(
            title: "Select Topics",
            items: _currentTopicsList,
            selectedItems: _selectedTopics,
            onConfirm: (set) => setState(() { _selectedTopics.clear(); _selectedTopics.addAll(set); }),
          ),
          child: InputDecorator(
            decoration: decoration.copyWith(labelText: "Topics", suffixIcon: const Icon(Icons.arrow_drop_down)),
            child: Text(_selectedTopics.isEmpty ? "All" : "${_selectedTopics.length} Selected", maxLines: 1, overflow: TextOverflow.ellipsis),
          ),
        ),
        const SizedBox(height: 10),
        CheckboxListTile(
          title: const Text("Previous Year Questions (PYQ) Only"),
          value: _isPyqOnly,
          onChanged: (val) => setState(() => _isPyqOnly = val ?? false),
          contentPadding: EdgeInsets.zero,
          activeColor: Colors.deepPurple,
        ),
      ],
    );
  }
}

================================================================================
FILE: lib/features/teacher/screens/teacher_history_screen.dart
================================================================================
// lib/features/teacher/screens/teacher_history_screen.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:study_smart_qc/services/teacher_service.dart';
// IMPORT THE NEW SCREEN
import 'package:study_smart_qc/features/teacher/screens/curation_management_screen.dart';

class TeacherHistoryScreen extends StatelessWidget {
  const TeacherHistoryScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final teacherUid = FirebaseAuth.instance.currentUser?.uid;

    if (teacherUid == null) {
      return const Scaffold(body: Center(child: Text("Authentication Error")));
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text("My Curations"),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
      ),
      body: StreamBuilder<QuerySnapshot>(
        stream: TeacherService().getTeacherCurations(teacherUid),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.folder_open, size: 60, color: Colors.grey),
                  SizedBox(height: 10),
                  Text("No curations found.", style: TextStyle(color: Colors.grey)),
                ],
              ),
            );
          }

          final docs = snapshot.data!.docs;

          return ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: docs.length,
            itemBuilder: (context, index) {
              final docId = docs[index].id; // Capture the Doc ID for navigation
              final data = docs[index].data() as Map<String, dynamic>;

              final String title = data['title'] ?? 'Untitled';
              final String code = data['assignmentCode'] ?? '----';
              final String status = data['status'] ?? 'assigned';
              final bool isStrict = data['onlySingleAttempt'] ?? false;
              final int questionCount = (data['questionIds'] as List?)?.length ?? 0;

              // Format Date
              final Timestamp? ts = data['createdAt'];
              final String dateStr = ts != null
                  ? DateFormat('MMM d, yyyy').format(ts.toDate())
                  : 'Unknown Date';

              return Card(
                elevation: 2,
                margin: const EdgeInsets.only(bottom: 12),
                child: ListTile(
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  title: Text(
                    title,
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const SizedBox(height: 4),
                      Text("$questionCount Questions â€¢ $dateStr"),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          _buildStatusChip(status),
                          const SizedBox(width: 8),
                          if (isStrict)
                            _buildMiniLabel("STRICT", Colors.red.shade100, Colors.red.shade800),
                        ],
                      ),
                    ],
                  ),
                  trailing: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      const Text("CODE", style: TextStyle(fontSize: 10, color: Colors.grey)),
                      Text(
                        code,
                        style: const TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            letterSpacing: 1.0,
                            color: Colors.deepPurple
                        ),
                      ),
                    ],
                  ),
                  onTap: () {
                    // Navigate to the Management Screen
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (_) => CurationManagementScreen(
                          curationId: docId,
                          title: title,
                        ),
                      ),
                    );
                  },
                ),
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildStatusChip(String status) {
    Color color = Colors.grey.shade100;
    Color textColor = Colors.black87;

    if (status == 'submitted') {
      color = Colors.green.shade100;
      textColor = Colors.green.shade800;
    } else if (status == 'assigned') {
      color = Colors.blue.shade100;
      textColor = Colors.blue.shade800;
    }

    return _buildMiniLabel(status.toUpperCase(), color, textColor);
  }

  Widget _buildMiniLabel(String text, Color bg, Color fg) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        text,
        style: TextStyle(fontSize: 10, fontWeight: FontWeight.bold, color: fg),
      ),
    );
  }
}

================================================================================
FILE: lib/features/test_creation/screens/custom_test_history_screen.dart
================================================================================
// lib/features/test_creation/screens/custom_test_history_screen.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';
import 'package:study_smart_qc/features/test_creation/screens/syllabus_screen.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';
// CRITICAL IMPORT: Needed for TestMode
import 'package:study_smart_qc/models/test_enums.dart';

class CustomTestHistoryScreen extends StatefulWidget {
  const CustomTestHistoryScreen({super.key});
  @override
  State<CustomTestHistoryScreen> createState() =>
      _CustomTestHistoryScreenState();
}

class _CustomTestHistoryScreenState extends State<CustomTestHistoryScreen> {
  final TestOrchestrationService _testService = TestOrchestrationService();
  String _filter = 'All';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Create Your Own Test')),
      body: Column(
        children: [
          _buildFilterChips(),
          Expanded(
            child: StreamBuilder<List<TestModel>>(
              stream: _testService.getSavedTestsStream(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                if (!snapshot.hasData || snapshot.data!.isEmpty) {
                  return const Center(child: Text('No tests created yet.'));
                }

                final allTests = snapshot.data!;
                final filteredTests = allTests.where((test) {
                  if (_filter == 'All') return true;
                  return test.status == _filter;
                }).toList();

                if (filteredTests.isEmpty) {
                  return Center(
                    child: Text('No tests match the \'$_filter\' filter.'),
                  );
                }

                return ListView.builder(
                  padding: const EdgeInsets.only(bottom: 100),
                  itemCount: filteredTests.length,
                  itemBuilder: (context, index) {
                    final test = filteredTests[index];
                    return _buildTestListItem(test);
                  },
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          Navigator.of(context).push(
            MaterialPageRoute(builder: (context) => const SyllabusScreen()),
          );
        },
        icon: const Icon(Icons.add),
        label: const Text('Create new custom test'),
        backgroundColor: Colors.blue,
        foregroundColor: Colors.white,
      ),
    );
  }

  Widget _buildFilterChips() {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: ['All', 'Attempted', 'Not Attempted'].map((filter) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 4.0),
            child: ChoiceChip(
              label: Text(filter),
              selected: _filter == filter,
              onSelected: (selected) {
                if (selected) {
                  setState(() => _filter = filter);
                }
              },
            ),
          );
        }).toList(),
      ),
    );
  }

  Widget _buildTestListItem(TestModel test) {
    final formattedDate = DateFormat(
      'd MMM yyyy',
    ).format(test.createdAt.toDate());
    bool isAttempted = test.status == 'Attempted';

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              test.testName,
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 4),
            Text(
              'JEE Main â€¢ $formattedDate',
              style: TextStyle(color: Colors.grey.shade600),
            ),
            const SizedBox(height: 12),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () async {
                    if (isAttempted) {
                      final attempt = await _testService.getAttemptForTest(
                        test.id,
                      );
                      final questions = await _testService.getQuestionsByIds(
                        test.questionIds,
                      );
                      if (mounted && attempt != null) {
                        final answerStates = <int, AnswerState>{};
                        for (int i = 0; i < questions.length; i++) {
                          final questionId = questions[i].id;
                          final response = attempt.responses[questionId];
                          answerStates[i] = AnswerState(
                            userAnswer: response?.selectedOption,
                            status: response?.status == 'CORRECT' ||
                                response?.status == 'INCORRECT'
                                ? AnswerStatus.answered
                                : AnswerStatus.notAnswered,
                          );
                        }

                        // FIXED: Added attemptId here
                        final result = TestResult(
                          attemptId: attempt.id,
                          questions: questions,
                          answerStates: answerStates,
                          timeTaken: Duration(
                            seconds: attempt.timeTakenSeconds,
                          ),
                          totalMarks: questions.length * 4,
                          responses: attempt.responses,
                        );

                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (context) => ResultsScreen(result: result),
                          ),
                        );
                      }
                    } else {
                      final List<Question> questions = await _testService
                          .getQuestionsByIds(test.questionIds);
                      if (mounted) {
                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (context) => TestScreen(
                              questions: questions,
                              timeLimitInMinutes:
                              test.config.durationSeconds ~/ 60,
                              // FIXED: Using sourceId instead of testId
                              sourceId: test.id,
                              // FIXED: Added TestMode enum
                              testMode: TestMode.test,
                            ),
                          ),
                        );
                      }
                    }
                  },
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(isAttempted ? 'View Analysis' : 'Attempt now'),
                      const Icon(Icons.arrow_forward_ios, size: 14),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/test_creation/screens/syllabus_screen.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/services/auth_service.dart';
import 'package:study_smart_qc/widgets/test_configuration_bottom_sheet.dart';

class SyllabusScreen extends StatefulWidget {
  const SyllabusScreen({super.key});

  @override
  State<SyllabusScreen> createState() => _SyllabusScreenState();
}

class _SyllabusScreenState extends State<SyllabusScreen> {
  // State for user selections
  final Set<String> _selectedTopicIds = {};
  final Set<String> _selectedChapterIds = {};
  final Map<String, bool> _expansionState = {};

  // State to hold parsed syllabus data, preventing re-parsing on every UI rebuild
  Map<String, String> _chapterIdToNameMap = {};
  Map<String, String> _topicIdToNameMap = {};
  Map<String, Map<String, String>> _chapterIdToTopicsMap = {};
  List<String> _chapterKeys = [];

  void _onTopicSelected(bool isSelected, String chapterId, String topicId) {
    setState(() {
      if (isSelected) {
        _selectedTopicIds.add(topicId);
        _selectedChapterIds.add(chapterId);
      } else {
        _selectedTopicIds.remove(topicId);
        final chapterTopics = _chapterIdToTopicsMap[chapterId]?.keys ?? [];
        if (chapterTopics.every((topic) => !_selectedTopicIds.contains(topic))) {
          _selectedChapterIds.remove(chapterId);
        }
      }
    });
  }

  void _toggleSelectAll(String chapterId, Set<String> topicKeys) {
    setState(() {
      final areAllSelected = topicKeys.isNotEmpty && topicKeys.every((key) => _selectedTopicIds.contains(key));
      if (areAllSelected) {
        _selectedTopicIds.removeAll(topicKeys);
        _selectedChapterIds.remove(chapterId);
      } else {
        _selectedTopicIds.addAll(topicKeys);
        _selectedChapterIds.add(chapterId);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Select Topics"),
        backgroundColor: Colors.deepPurple,
        foregroundColor: Colors.white,
        actions: [
          IconButton(icon: const Icon(Icons.logout), onPressed: () => AuthService().signOut()),
        ],
      ),
      body: StreamBuilder<DocumentSnapshot>(
        stream: FirebaseFirestore.instance.collection('static_data').doc('syllabus').snapshots(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (!snapshot.hasData || !snapshot.data!.exists) {
            return const Center(child: Text("No Syllabus Found"));
          }

          if (snapshot.hasData) {
            Map<String, dynamic> data = snapshot.data!.data() as Map<String, dynamic>;
            final chapters = data['subjects']?['physics']?['chapters'] as Map<String, dynamic>? ?? {};
            _chapterKeys = chapters.keys.toList();

            _chapterIdToNameMap = {};
            _topicIdToNameMap = {};
            _chapterIdToTopicsMap = {};

            for (var chapterKey in _chapterKeys) {
              final chapterData = chapters[chapterKey] as Map<String, dynamic>;
              _chapterIdToNameMap[chapterKey] = chapterData['name'] ?? 'Unnamed Chapter';
              final topics = Map<String, String>.from(chapterData['topics'] ?? {});
              _chapterIdToTopicsMap[chapterKey] = topics;
              for (var topicEntry in topics.entries) {
                _topicIdToNameMap[topicEntry.key] = topicEntry.value as String;
              }
            }
          }

          return ListView.builder(
            key: const PageStorageKey<String>('syllabus_list'),
            padding: const EdgeInsets.only(bottom: 120),
            itemCount: _chapterKeys.length,
            itemBuilder: (context, index) {
              final chapterKey = _chapterKeys[index];
              final chapterName = _chapterIdToNameMap[chapterKey]!;
              final topics = _chapterIdToTopicsMap[chapterKey]!;
              final topicKeys = topics.keys.toSet();

              final areAllSelected = topicKeys.isNotEmpty && topicKeys.every((key) => _selectedTopicIds.contains(key));
              final isExpanded = _expansionState[chapterKey] ?? false;

              return Card(
                margin: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                  side: BorderSide(color: areAllSelected ? Colors.green : Colors.transparent, width: 2),
                ),
                child: Column(
                  children: [
                    ListTile(
                      leading: const Icon(Icons.book, color: Colors.deepPurple),
                      title: Text(chapterName, style: const TextStyle(fontWeight: FontWeight.bold)),
                      onTap: () => _toggleSelectAll(chapterKey, topicKeys),
                      trailing: IconButton(
                        icon: Icon(isExpanded ? Icons.expand_less : Icons.expand_more),
                        onPressed: () => setState(() => _expansionState[chapterKey] = !isExpanded),
                      ),
                    ),
                    if (isExpanded)
                      Padding(
                        padding: const EdgeInsets.all(8.0),
                        child: GridView.builder(
                          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 2,
                            childAspectRatio: 2.5,
                            crossAxisSpacing: 8,
                            mainAxisSpacing: 8,
                          ),
                          itemCount: topicKeys.length,
                          shrinkWrap: true,
                          physics: const NeverScrollableScrollPhysics(),
                          itemBuilder: (context, gridIndex) {
                            final topicKey = topicKeys.elementAt(gridIndex);
                            final topicName = topics[topicKey]!;
                            final isSelected = _selectedTopicIds.contains(topicKey);

                            return GestureDetector(
                              onTap: () => _onTopicSelected(!isSelected, chapterKey, topicKey),
                              child: Card(
                                color: isSelected ? Colors.green.withOpacity(0.15) : null,
                                elevation: 0,
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8), side: BorderSide(color: Colors.grey.shade300)),
                                child: Center(
                                  child: Padding(
                                    padding: const EdgeInsets.all(8.0),
                                    child: Text(topicName, textAlign: TextAlign.center, style: const TextStyle(fontSize: 12)),
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                      ),
                  ],
                ),
              );
            },
          );
        },
      ),
      bottomSheet: _selectedTopicIds.isNotEmpty ? _buildStickyBottomBar() : null,
    );
  }

  Widget _buildStickyBottomBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 15).copyWith(bottom: MediaQuery.of(context).padding.bottom + 10),
      decoration: BoxDecoration(color: Colors.deepPurple.shade700, boxShadow: const [BoxShadow(color: Colors.black26, blurRadius: 8, offset: Offset(0, -2))]),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${_selectedTopicIds.length} Topic(s) Selected', style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16)),
              Text('${_selectedChapterIds.length} Chapter(s)', style: const TextStyle(color: Colors.white70, fontSize: 12)),
            ],
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(foregroundColor: Colors.deepPurple, backgroundColor: Colors.white, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)), padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12)),
            onPressed: () {
              showModalBottomSheet(
                context: context,
                isScrollControlled: true,
                builder: (ctx) => TestConfigurationBottomSheet(
                  chapterIds: _selectedChapterIds,
                  topicIds: _selectedTopicIds,
                  chapterIdToNameMap: _chapterIdToNameMap,
                  topicIdToNameMap: _topicIdToNameMap,
                  chapterIdToTopicsMap: _chapterIdToTopicsMap, // FIX: This is now correctly passed
                ),
              );
            },
            child: const Row(children: [Text('Configure Test'), SizedBox(width: 5), Icon(Icons.arrow_forward_ios, size: 14)]),
          ),
        ],
      ),
    );
  }
}


================================================================================
FILE: lib/features/test_taking/screens/enter_code_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_preview_screen.dart';

class EnterCodeScreen extends StatefulWidget {
  const EnterCodeScreen({super.key});

  @override
  State<EnterCodeScreen> createState() => _EnterCodeScreenState();
}

class _EnterCodeScreenState extends State<EnterCodeScreen> {
  final _codeController = TextEditingController();
  final _testService = TestOrchestrationService();
  bool _isLoading = false;
  String? _errorText;

  Future<void> _findTest() async {
    if (_codeController.text.isEmpty) return;

    setState(() {
      _isLoading = true;
      _errorText = null;
    });

    final test = await _testService.getTestByShareCode(
      _codeController.text.trim(),
    );

    if (test == null) {
      setState(() {
        _isLoading = false;
        _errorText = 'Invalid or expired test code.';
      });
      return;
    }

    final questions = await _testService.getQuestionsByIds(test.questionIds);

    if (!mounted) return;

    setState(() => _isLoading = false);

    // Navigate to Test Preview Screen
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => TestPreviewScreen(
          questions: questions,
          timeLimitInMinutes: test.config.durationSeconds ~/ 60,
          selectedSyllabus: {
            for (var v in test.chapters) v: [],
          }, // Reconstruct a simplified map
          testName: test.testName,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Enter Test Code')),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            TextField(
              controller: _codeController,
              textAlign: TextAlign.center,
              style: const TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                letterSpacing: 8,
              ),
              decoration: InputDecoration(
                hintText: '_ _ _ _',
                errorText: _errorText,
                border: const OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 20),
            if (_isLoading)
              const CircularProgressIndicator()
            else
              ElevatedButton(
                onPressed: _findTest,
                child: const Text('Find Test'),
              ),
          ],
        ),
      ),
    );
  }
}


================================================================================
FILE: lib/features/test_taking/screens/test_preview_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
// NEW IMPORT
import 'package:study_smart_qc/models/test_enums.dart';

class TestPreviewScreen extends StatelessWidget {
  final List<Question> questions;
  final int timeLimitInMinutes;
  final Map<String, List<String>> selectedSyllabus;
  final String testName;
  final TestModel? existingTest;

  const TestPreviewScreen({
    super.key,
    required this.questions,
    required this.timeLimitInMinutes,
    required this.selectedSyllabus,
    required this.testName,
    this.existingTest,
  });

  Future<void> _handleAttemptLater(BuildContext context) async {
    final service = TestOrchestrationService();
    if (existingTest == null) {
      await service.createAndSaveTestBlueprint(
        questions: questions,
        durationSeconds: timeLimitInMinutes * 60,
        chapterNames: selectedSyllabus.keys.toList(),
        testName: testName,
      );
    }

    if (context.mounted) {
      Navigator.of(context).popUntil((route) => route.isFirst);
    }
  }

  Future<void> _handleAttemptNow(BuildContext context) async {
    final service = TestOrchestrationService();
    TestModel? testToAttempt = existingTest;

    if (testToAttempt == null) {
      testToAttempt = await service.createAndSaveTestBlueprint(
        questions: questions,
        durationSeconds: timeLimitInMinutes * 60,
        chapterNames: selectedSyllabus.keys.toList(),
        testName: testName,
      );
    }

    if (testToAttempt == null) return;

    await service.recordTestAttempt(testToAttempt.id);

    if (context.mounted) {
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (context) => TestScreen(
            questions: questions,
            timeLimitInMinutes: timeLimitInMinutes,
            // FIXED: Updated arguments here
            sourceId: testToAttempt!.id,
            testMode: TestMode.test,
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Test Preview'),
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              testName,
              style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            const Wrap(
              spacing: 8.0,
              children: [
                Chip(
                  label: Text('JEE Main'),
                  avatar: Icon(Icons.check_circle, color: Colors.green),
                ),
                Chip(label: Text('Physics')),
              ],
            ),
            const SizedBox(height: 20),
            Row(
              children: [
                Expanded(
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        children: [
                          const Icon(
                            Icons.help_outline,
                            color: Colors.deepPurple,
                          ),
                          const SizedBox(height: 8),
                          Text('${questions.length} Qs'),
                        ],
                      ),
                    ),
                  ),
                ),
                Expanded(
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        children: [
                          const Icon(
                            Icons.timer_outlined,
                            color: Colors.deepPurple,
                          ),
                          const SizedBox(height: 8),
                          Text('$timeLimitInMinutes Mins'),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),
            const Divider(),
            const SizedBox(height: 10),
            Text(
              'Syllabus - ${selectedSyllabus.length} chapters',
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            Expanded(
              child: ListView.builder(
                itemCount: selectedSyllabus.length,
                itemBuilder: (context, index) {
                  final chapterName = selectedSyllabus.keys.elementAt(index);
                  final topicNames = selectedSyllabus[chapterName]!;
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 8.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'â€¢ $chapterName',
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        if (topicNames.isNotEmpty)
                          Padding(
                            padding: const EdgeInsets.only(left: 20, top: 4),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: topicNames
                                  .map(
                                    (topic) => Text(
                                  '    - $topic',
                                  style: TextStyle(
                                    color: Colors.grey.shade700,
                                  ),
                                ),
                              )
                                  .toList(),
                            ),
                          ),
                      ],
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                onPressed: () => _handleAttemptNow(context),
                child: const Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text('Attempt test now'),
                    Icon(Icons.arrow_forward),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 10),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: () => _handleAttemptLater(context),
                child: const Text('Attempt later'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: lib/features/test_taking/screens/test_screen.dart
================================================================================
// lib/features/test_taking/screens/test_screen.dart

import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

// 1. IMPORT MODELS
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/models/test_enums.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';

// 2. IMPORT SCREENS & SERVICES
import 'package:study_smart_qc/features/analytics/screens/results_screen.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/services/local_session_service.dart';
import 'package:study_smart_qc/widgets/expandable_image.dart';
import 'package:study_smart_qc/widgets/question_input_widget.dart';

class TestScreen extends StatefulWidget {
  final String sourceId;
  final String assignmentCode;

  // Title
  final String title;

  // NEW FIELD: Only Single Attempt Flag
  final bool onlySingleAttempt;

  final List<Question> questions;
  final int timeLimitInMinutes;
  final TestMode testMode;

  final int? resumedTimerSeconds;
  final int? resumedPageIndex;
  final Map<String, ResponseObject>? resumedResponses;

  const TestScreen({
    super.key,
    required this.questions,
    required this.timeLimitInMinutes,
    this.sourceId = '',
    this.assignmentCode = 'PRAC',
    this.title = 'Practice Test',

    // Initialize new field
    this.onlySingleAttempt = false,

    this.testMode = TestMode.test,
    this.resumedTimerSeconds,
    this.resumedPageIndex,
    this.resumedResponses,
  });

  @override
  State<TestScreen> createState() => _TestScreenState();
}

class _TestScreenState extends State<TestScreen> with WidgetsBindingObserver {
  late final PageController _pageController;
  late final Timer _timer;
  late Duration _overallTimeCounter;
  bool _isPaused = false;

  final Map<int, AnswerState> _answerStates = {};
  final Map<int, int> _visitCounts = {};
  final Map<int, Stopwatch> _timeTrackers = {};
  final Map<int, int> _accumulatedTime = {};

  int _currentPage = 0;
  bool _isAnswerChecked = false;

  final LocalSessionService _localSessionService = LocalSessionService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    _currentPage = widget.resumedPageIndex ?? 0;
    _pageController = PageController(initialPage: _currentPage);

    if (widget.resumedTimerSeconds != null) {
      _overallTimeCounter = Duration(seconds: widget.resumedTimerSeconds!);
    } else {
      if (widget.testMode == TestMode.test) {
        _overallTimeCounter = Duration(minutes: widget.timeLimitInMinutes);
      } else {
        _overallTimeCounter = Duration.zero;
      }
    }

    for (int i = 0; i < widget.questions.length; i++) {
      final question = widget.questions[i];
      _visitCounts[i] = 0;
      _timeTrackers[i] = Stopwatch();
      _accumulatedTime[i] = 0;

      AnswerState newState = AnswerState(status: AnswerStatus.notVisited);

      if (widget.resumedResponses != null &&
          widget.resumedResponses!.containsKey(question.id)) {

        final savedResponse = widget.resumedResponses![question.id]!;
        newState.userAnswer = savedResponse.selectedOption;
        _accumulatedTime[i] = savedResponse.timeSpent;

        switch (savedResponse.status) {
          case 'REVIEW':
            newState.status = AnswerStatus.markedForReview;
            break;
          case 'REVIEW_ANSWERED':
            newState.status = AnswerStatus.answeredAndMarked;
            break;
          case 'ANSWERED':
          case 'CORRECT':
          case 'INCORRECT':
            newState.status = AnswerStatus.answered;
            break;
          case 'SKIPPED':
            newState.status = AnswerStatus.notAnswered;
            break;
          default:
            if (savedResponse.selectedOption != null) {
              newState.status = AnswerStatus.answered;
            }
        }
        _visitCounts[i] = savedResponse.visitCount;
      }
      _answerStates[i] = newState;
    }

    _onPageChanged(_currentPage, fromInit: true);
    _startTimer();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _timer.cancel();
    _pageController.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      _triggerLocalSave();
    }
  }

  Future<void> _triggerLocalSave() async {
    Map<String, ResponseObject> currentResponses = _buildResponseMap();
    await _localSessionService.saveSession(
      assignmentCode: widget.assignmentCode,
      mode: widget.testMode == TestMode.test ? 'Test' : 'Practice',
      testId: widget.sourceId,
      totalQuestions: widget.questions.length,
      currentTimerValue: _overallTimeCounter.inSeconds,
      currentQuestionIndex: _currentPage,
      responses: currentResponses,
    );
  }

  Map<String, ResponseObject> _buildResponseMap() {
    Map<String, ResponseObject> responses = {};
    for (int i = 0; i < widget.questions.length; i++) {
      final question = widget.questions[i];
      final state = _answerStates[i]!;

      final int totalTimeSpent = (_accumulatedTime[i] ?? 0) + (_timeTrackers[i]?.elapsed.inSeconds ?? 0);

      String statusString = 'SKIPPED';
      if (state.status == AnswerStatus.answered) {
        final isCorrect = _checkEquality(state.userAnswer, question.correctAnswer);
        statusString = isCorrect ? 'CORRECT' : 'INCORRECT';
      } else if (state.status == AnswerStatus.answeredAndMarked) {
        statusString = 'REVIEW_ANSWERED';
      } else if (state.status == AnswerStatus.markedForReview) {
        statusString = 'REVIEW';
      } else if (state.status == AnswerStatus.notAnswered) {
        statusString = 'SKIPPED';
      }

      responses[question.id] = ResponseObject(
        status: statusString,
        selectedOption: state.userAnswer,
        correctOption: question.correctAnswer.toString(),
        timeSpent: totalTimeSpent,
        visitCount: _visitCounts[i] ?? 0,
        q_no: i + 1,
        exam: question.exam,
        subject: question.subject,
        chapter: question.chapter,
        topic: question.topic,
        topicL2: question.topicL2,
        chapterId: question.chapterId,
        topicId: question.topicId,
        topicL2Id: question.topicL2Id,
        pyq: question.isPyq ? 'Yes' : 'No',
        difficultyTag: question.difficulty,
      );
    }
    return responses;
  }

  void _startTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_isPaused) return;
      if (mounted) {
        setState(() {
          if (widget.testMode == TestMode.test) {
            if (_overallTimeCounter.inSeconds > 0) {
              _overallTimeCounter -= const Duration(seconds: 1);
            } else {
              _timer.cancel();
              _handleSubmit();
            }
          } else {
            _overallTimeCounter += const Duration(seconds: 1);
          }
        });
      }
    });
  }

  void _onPageChanged(int page, {bool fromInit = false}) {
    if (!fromInit && _timeTrackers.containsKey(_currentPage)) {
      _timeTrackers[_currentPage]!.stop();
    }
    setState(() {
      _currentPage = page;
      _isAnswerChecked = false;
      _visitCounts[page] = (_visitCounts[page] ?? 0) + 1;
      if (_answerStates[page]?.status == AnswerStatus.notVisited) {
        _answerStates[page]?.status = AnswerStatus.notAnswered;
      }
    });
    if (_timeTrackers.containsKey(page)) {
      _timeTrackers[page]!.start();
    }
    if(!fromInit) _triggerLocalSave();
  }

  void _togglePauseState() {
    setState(() => _isPaused = !_isPaused);
    if (_isPaused) {
      _timeTrackers[_currentPage]?.stop();
      _triggerLocalSave();
    } else {
      _timeTrackers[_currentPage]?.start();
    }
  }

  void _showPauseDialog() {
    _togglePauseState();
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => PopScope(
        canPop: false,
        child: AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
          title: Row(
            children: const [
              Icon(Icons.pause_circle_filled, color: Colors.orange, size: 28),
              SizedBox(width: 10),
              Text('Paused'),
            ],
          ),
          content: const Text(
            'Test timer is paused. Click Resume to continue.',
            style: TextStyle(fontSize: 16),
          ),
          actions: [
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  Navigator.pop(ctx);
                  _togglePauseState();
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.deepPurple,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
                child: const Text('Resume',
                    style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  bool _checkEquality(dynamic userAns, dynamic correctAns) {
    if (userAns == null || correctAns == null) return false;
    if (userAns is String || userAns is num) {
      return userAns.toString().trim().toLowerCase() ==
          correctAns.toString().trim().toLowerCase();
    }
    if (userAns is List && correctAns is List) {
      if (userAns.length != correctAns.length) return false;
      final userSet = userAns.map((e) => e.toString()).toSet();
      final correctSet = correctAns.map((e) => e.toString()).toSet();
      return userSet.containsAll(correctSet);
    }
    if (userAns is Map && correctAns is Map) {
      if (userAns.length != correctAns.length) return false;
      for (var key in userAns.keys) {
        if (!correctAns.containsKey(key)) return false;
        if (!_checkEquality(userAns[key], correctAns[key])) return false;
      }
      return true;
    }
    return userAns == correctAns;
  }

  void _checkAnswer() {
    final state = _answerStates[_currentPage]!;
    bool isEmpty = false;
    if (state.userAnswer == null) isEmpty = true;
    if (state.userAnswer is String && (state.userAnswer as String).isEmpty) isEmpty = true;
    if (state.userAnswer is List && (state.userAnswer as List).isEmpty) isEmpty = true;
    if (state.userAnswer is Map && (state.userAnswer as Map).isEmpty) isEmpty = true;

    if (isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Please select an answer first!")));
      return;
    }
    setState(() {
      _isAnswerChecked = true;
    });
    _triggerLocalSave();
  }

  void _showSolution() {
    final q = widget.questions[_currentPage];
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (ctx) => Container(
        padding: const EdgeInsets.all(16),
        height: MediaQuery.of(ctx).size.height * 0.7,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text("Solution", style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const Divider(),
            const SizedBox(height: 10),
            Text("Correct Answer: ${q.correctAnswer}",
                style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.green)),
            const SizedBox(height: 10),
            if (q.solutionUrl != null)
              Expanded(child: Center(child: ExpandableImage(imageUrl: q.solutionUrl!)))
            else
              const Text("No image solution available."),
          ],
        ),
      ),
    );
  }

  void _handleSaveAndNext() {
    final state = _answerStates[_currentPage]!;
    bool hasAnswer = state.userAnswer != null;
    if (state.userAnswer is String && (state.userAnswer as String).isEmpty) hasAnswer = false;
    if (state.userAnswer is List && (state.userAnswer as List).isEmpty) hasAnswer = false;

    if (hasAnswer) {
      setState(() => state.status = AnswerStatus.answered);
    } else {
      setState(() => state.status = AnswerStatus.notAnswered);
    }
    _triggerLocalSave().then((_) => _moveToNextPage());
  }

  void _handleSaveAndMarkForReview() {
    final state = _answerStates[_currentPage]!;
    bool hasAnswer = state.userAnswer != null;
    if (state.userAnswer is String && (state.userAnswer as String).isEmpty) hasAnswer = false;
    if (state.userAnswer is List && (state.userAnswer as List).isEmpty) hasAnswer = false;

    if (hasAnswer) {
      setState(() => state.status = AnswerStatus.answeredAndMarked);
      _triggerLocalSave().then((_) => _moveToNextPage());
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Please select an answer to Save & Mark for Review")),
      );
    }
  }

  void _handleMarkForReviewAndNext() {
    setState(() {
      _answerStates[_currentPage]!.status = AnswerStatus.markedForReview;
    });
    _triggerLocalSave().then((_) => _moveToNextPage());
  }

  void _handleClearResponse() {
    setState(() {
      _answerStates[_currentPage]!.userAnswer = null;
      _answerStates[_currentPage]!.status = AnswerStatus.notAnswered;
      _isAnswerChecked = false;
    });
    _triggerLocalSave();
  }

  void _moveToNextPage() {
    if (_currentPage < widget.questions.length - 1) {
      _pageController.nextPage(
          duration: const Duration(milliseconds: 300), curve: Curves.easeIn);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("You are on the last question. Click Submit to finish.")),
      );
    }
  }

  // =================================================================
  //  CORE SUBMISSION LOGIC (UPDATED)
  // =================================================================
  void _handleSubmit() async {
    _timer.cancel();
    _timeTrackers.values.forEach((sw) => sw.stop());

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    Map<String, ResponseObject> initialResponses = _buildResponseMap();

    final score = (initialResponses.values.where((r) => r.status == 'CORRECT').length * 4) -
        (initialResponses.values.where((r) => r.status == 'INCORRECT').length * 1);

    final finalTime = widget.testMode == TestMode.test
        ? (Duration(minutes: widget.timeLimitInMinutes) - _overallTimeCounter).inSeconds
        : _overallTimeCounter.inSeconds;

    final int? limitToSave = widget.testMode == TestMode.test
        ? widget.timeLimitInMinutes
        : null;

    final enrichedAttempt = await TestOrchestrationService().submitAttempt(
      sourceId: widget.sourceId,
      assignmentCode: widget.assignmentCode,
      title: widget.title,

      // PASS NEW FIELD
      onlySingleAttempt: widget.onlySingleAttempt,

      mode: widget.testMode == TestMode.test ? 'Test' : 'Practice',
      questions: widget.questions,
      score: score,
      timeTakenSeconds: finalTime,
      responses: initialResponses,
      timeLimitMinutes: limitToSave,
    );

    if (mounted) {
      Navigator.pop(context);

      if (enrichedAttempt != null) {
        await _localSessionService.clearSession();

        final result = TestResult(
          attemptId: enrichedAttempt.id,
          questions: widget.questions,
          answerStates: _answerStates,
          timeTaken: Duration(seconds: finalTime),
          totalMarks: widget.questions.length * 4,
          responses: enrichedAttempt.responses,
        );

        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (context) => ResultsScreen(result: result)),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("Error uploading. Progress saved locally. Check internet."))
        );
      }
    }
  }

  Future<bool> _onWillPop() async {
    final shouldPop = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Quit Test?'),
        content: const Text('If you quit now, your progress will be saved locally. You can resume later.'),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(ctx, false),
              child: const Text('No, Resume')),
          TextButton(
            onPressed: () {
              _triggerLocalSave().then((_) => Navigator.pop(ctx, true));
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Yes, Quit (Save & Exit)'),
          ),
        ],
      ),
    );
    return shouldPop ?? false;
  }

  Future<void> _showSubmitConfirmationDialog() async {
    return showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Submit Test'),
        content: const Text('Are you sure you want to finish the test?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(
            onPressed: () {
              Navigator.pop(ctx);
              _handleSubmit();
            },
            child: const Text('Submit'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false,
      onPopInvoked: (didPop) async {
        if (didPop) return;
        final shouldExit = await _onWillPop();
        if (shouldExit && context.mounted) {
          Navigator.of(context).pop();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          backgroundColor: Colors.deepPurple,
          foregroundColor: Colors.white,
          centerTitle: true,
          automaticallyImplyLeading: false,
          leading: IconButton(
            icon: const Icon(Icons.close, color: Colors.white),
            onPressed: () async {
              final shouldExit = await _onWillPop();
              if (shouldExit && context.mounted) {
                Navigator.of(context).pop();
              }
            },
          ),
          title: _buildOverallTimerWidget(),
          actions: [
            if (widget.testMode == TestMode.practice)
              IconButton(
                onPressed: _showPauseDialog,
                icon: const Icon(Icons.pause_circle_filled, color: Colors.white),
                tooltip: "Pause",
              ),
            TextButton(
              onPressed: _showSubmitConfirmationDialog,
              child: const Text('Submit', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
            ),
            const SizedBox(width: 8),
          ],
        ),
        body: Column(
          children: [
            _buildNTAQuestionPalette(),
            const Divider(height: 1),
            Expanded(
              child: PageView.builder(
                controller: _pageController,
                physics: _isPaused
                    ? const NeverScrollableScrollPhysics()
                    : const AlwaysScrollableScrollPhysics(),
                onPageChanged: (index) => _onPageChanged(index),
                itemCount: widget.questions.length,
                itemBuilder: (context, index) {
                  final q = widget.questions[index];
                  return SingleChildScrollView(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text('Q.${index + 1}', style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                            _buildQuestionTimerWidget(index),
                          ],
                        ),
                        const SizedBox(height: 10),
                        if (q.imageUrl.isNotEmpty)
                          Align(
                            alignment: Alignment.centerLeft,
                            child: ExpandableImage(imageUrl: q.imageUrl),
                          ),
                        const SizedBox(height: 20),
                        QuestionInputWidget(
                          question: q,
                          currentAnswer: _answerStates[index]?.userAnswer,
                          onAnswerChanged: (newAnswer) {
                            if (!_isPaused) {
                              setState(() {
                                _answerStates[index]?.userAnswer = newAnswer;
                                if (widget.testMode == TestMode.practice) {
                                  _isAnswerChecked = false;
                                }
                              });
                            }
                          },
                        ),
                        if (widget.testMode == TestMode.practice && _isAnswerChecked)
                          _buildFeedbackUI(q),
                      ],
                    ),
                  );
                },
              ),
            ),
          ],
        ),
        bottomNavigationBar: _buildBottomNavBar(),
      ),
    );
  }

  // ... (Remainder of the widget logic for timers/palettes/UI remains unchanged)
  Widget _buildOverallTimerWidget() {
    String twoDigits(int n) => n.toString().padLeft(2, "0");
    final minutes = twoDigits(_overallTimeCounter.inMinutes.remainder(60));
    final seconds = twoDigits(_overallTimeCounter.inSeconds.remainder(60));
    final hours = twoDigits(_overallTimeCounter.inHours);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
      decoration: BoxDecoration(
        color: Colors.deepPurple.shade700,
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        "$hours:$minutes:$seconds",
        style: const TextStyle(fontSize: 16, color: Colors.white, fontWeight: FontWeight.bold, letterSpacing: 1.2),
      ),
    );
  }

  Widget _buildQuestionTimerWidget(int index) {
    final currentElapsed = _timeTrackers[index]?.elapsed.inSeconds ?? 0;
    final totalSeconds = (_accumulatedTime[index] ?? 0) + currentElapsed;
    final duration = Duration(seconds: totalSeconds);

    String twoDigits(int n) => n.toString().padLeft(2, "0");
    final minutes = twoDigits(duration.inMinutes.remainder(60));
    final seconds = twoDigits(duration.inSeconds.remainder(60));

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.access_time_filled, size: 16, color: Colors.black54),
          const SizedBox(width: 5),
          Text(
            "$minutes:$seconds",
            style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold, color: Colors.black87),
          ),
        ],
      ),
    );
  }

  Widget _buildNTAQuestionPalette() {
    return Container(
      height: 70,
      padding: const EdgeInsets.symmetric(vertical: 10),
      color: Colors.grey.shade50,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        padding: const EdgeInsets.symmetric(horizontal: 10),
        itemCount: widget.questions.length,
        itemBuilder: (context, index) {
          final state = _answerStates[index]!;
          final isCurrent = index == _currentPage;

          BoxShape shape = BoxShape.rectangle;
          Color color = Colors.white;
          Border? border = Border.all(color: Colors.grey.shade300);
          Widget? badge;

          switch (state.status) {
            case AnswerStatus.notVisited:
              color = Colors.white;
              break;
            case AnswerStatus.notAnswered:
              color = Colors.red;
              border = null;
              break;
            case AnswerStatus.answered:
              color = Colors.green;
              border = null;
              break;
            case AnswerStatus.markedForReview:
              shape = BoxShape.circle;
              color = Colors.purple;
              border = null;
              break;
            case AnswerStatus.answeredAndMarked:
              shape = BoxShape.circle;
              color = Colors.purple;
              border = null;
              badge = const Positioned(
                bottom: 0,
                right: 0,
                child: Icon(Icons.check_circle, size: 14, color: Colors.green),
              );
              break;
          }

          return GestureDetector(
            onTap: () => _pageController.jumpToPage(index),
            child: Container(
              width: 50,
              margin: const EdgeInsets.symmetric(horizontal: 5),
              child: Stack(
                alignment: Alignment.center,
                children: [
                  Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: color,
                      shape: shape,
                      border: isCurrent
                          ? Border.all(color: Colors.blueAccent, width: 3)
                          : border,
                      borderRadius: shape == BoxShape.rectangle
                          ? BorderRadius.circular(4)
                          : null,
                    ),
                    child: Center(
                      child: Text(
                        "${index + 1}",
                        style: TextStyle(
                          color: (color == Colors.white) ? Colors.black : Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  if (badge != null) badge,
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildFeedbackUI(Question q) {
    final isCorrect = _checkEquality(_answerStates[_currentPage]?.userAnswer, q.correctAnswer);
    return Container(
      margin: const EdgeInsets.only(top: 20),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: isCorrect ? Colors.green.shade50 : Colors.red.shade50,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: isCorrect ? Colors.green : Colors.red),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(children: [
            Icon(isCorrect ? Icons.check_circle : Icons.cancel, color: isCorrect ? Colors.green : Colors.red),
            const SizedBox(width: 10),
            Text(isCorrect ? "Correct!" : "Incorrect",
                style: TextStyle(fontWeight: FontWeight.bold, color: isCorrect ? Colors.green : Colors.red)),
          ]),
          const SizedBox(height: 10),
          ElevatedButton(onPressed: _showSolution, child: const Text("View Full Solution")),
        ],
      ),
    );
  }

  Widget _buildBottomNavBar() {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(color: Colors.white, boxShadow: [
        BoxShadow(color: Colors.grey.shade200, blurRadius: 4, offset: const Offset(0, -2))
      ]),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (widget.testMode == TestMode.practice)
            Padding(
              padding: const EdgeInsets.only(bottom: 12.0),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _checkAnswer,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.orange,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: const Text("Check Answer"),
                ),
              ),
            ),
          Row(
            children: [
              Expanded(
                child: ElevatedButton(
                  onPressed: _handleSaveAndMarkForReview,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white,
                    foregroundColor: Colors.purple,
                    side: const BorderSide(color: Colors.purple),
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    elevation: 0,
                  ),
                  child: const Text("Save & Mark Review",
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold)),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: ElevatedButton(
                  onPressed: _handleMarkForReviewAndNext,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white,
                    foregroundColor: Colors.purple,
                    side: const BorderSide(color: Colors.purple),
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    elevation: 0,
                  ),
                  child: const Text("Mark Review & Next",
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold)),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: _handleClearResponse,
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    foregroundColor: Colors.red,
                    side: const BorderSide(color: Colors.red),
                  ),
                  child: const Text("Clear", style: TextStyle(fontWeight: FontWeight.bold)),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: ElevatedButton(
                  onPressed: _handleSaveAndNext,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: const Text("Save & Next", style: TextStyle(fontWeight: FontWeight.bold)),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/models/attempt_item_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

class AttemptItemModel {
  final String userId;
  final DocumentReference attemptRef; // <--- The Fix: Stores reference to parent
  final String questionId;
  final String chapterId;
  final String topicId;
  final String status;
  final int timeSpent;
  final Timestamp attemptedAt;
  final String assignmentCode;
  final String mode;
  final String? mistakeCategory;
  final String? mistakeNote;

  AttemptItemModel({
    required this.userId,
    required this.attemptRef,
    required this.questionId,
    required this.chapterId,
    required this.topicId,
    required this.status,
    required this.timeSpent,
    required this.attemptedAt,
    required this.assignmentCode,
    required this.mode,
    this.mistakeCategory,
    this.mistakeNote,
  });

  factory AttemptItemModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    return AttemptItemModel(
      userId: data['userId'] ?? '',
      // Safe casting for the reference
      attemptRef: data['attemptRef'] is DocumentReference
          ? data['attemptRef']
          : FirebaseFirestore.instance.collection('attempts').doc('unknown'),
      questionId: data['questionId'] ?? '',
      chapterId: data['chapterId'] ?? '',
      topicId: data['topicId'] ?? '',
      status: data['status'] ?? 'SKIPPED',
      timeSpent: data['timeSpent'] ?? 0,
      attemptedAt: data['attemptedAt'] ?? Timestamp.now(),
      assignmentCode: data['assignmentCode'] ?? '',
      mode: data['mode'] ?? 'Test',
      mistakeCategory: data['mistakeCategory'],
      mistakeNote: data['mistakeNote'],
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'attemptRef': attemptRef,
      'questionId': questionId,
      'chapterId': chapterId,
      'topicId': topicId,
      'status': status,
      'timeSpent': timeSpent,
      'attemptedAt': attemptedAt,
      'assignmentCode': assignmentCode,
      'mode': mode,
      'mistakeCategory': mistakeCategory,
      'mistakeNote': mistakeNote,
    };
  }
}

================================================================================
FILE: lib/models/attempt_model.dart
================================================================================
// lib/models/attempt_model.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class ResponseObject {
  // ... (No changes to ResponseObject needed, keeping it as is) ...
  final String status;
  final dynamic selectedOption;
  final String correctOption;
  final int timeSpent;
  final int visitCount;
  final int q_no;

  // Context Fields
  final String exam;
  final String subject;

  // Tags
  final String chapter;
  final String topic;
  final String topicL2;

  // IDs
  final String? chapterId;
  final String? topicId;
  final String? topicL2Id;

  // Smart Time Analysis Tag
  final String smartTimeAnalysis;

  final String pyq;
  final String difficultyTag;

  final String? mistakeCategory;
  final String? mistakeNote;

  ResponseObject({
    required this.status,
    this.selectedOption,
    required this.correctOption,
    required this.timeSpent,
    required this.visitCount,
    required this.q_no,
    required this.exam,
    required this.subject,
    this.chapter = '',
    this.topic = '',
    this.topicL2 = '',
    this.chapterId,
    this.topicId,
    this.topicL2Id,
    this.smartTimeAnalysis = '',
    this.pyq = '',
    this.difficultyTag = '',
    this.mistakeCategory,
    this.mistakeNote,
  });

  Map<String, dynamic> toJson() => toMap();
  factory ResponseObject.fromJson(Map<String, dynamic> json) => ResponseObject.fromMap(json);

  factory ResponseObject.fromMap(Map<String, dynamic> map) {
    return ResponseObject(
      status: map['status'] ?? 'SKIPPED',
      selectedOption: map['selectedOption'],
      correctOption: map['correctOption'] ?? '',
      timeSpent: map['timeSpent'] ?? 0,
      visitCount: map['visitCount'] ?? 0,
      q_no: map['q_no'] ?? 0,
      exam: map['exam'] ?? '',
      subject: map['subject'] ?? 'Physics',
      chapter: map['chapter'] ?? '',
      topic: map['topic'] ?? '',
      topicL2: map['topicL2'] ?? '',
      chapterId: map['chapterId'] as String?,
      topicId: map['topicId'] as String?,
      topicL2Id: map['topicL2Id'] as String?,
      smartTimeAnalysis: map['smartTimeAnalysis'] ?? '',
      pyq: map['pyq'] ?? '',
      difficultyTag: map['difficultyTag'] ?? '',
      mistakeCategory: map['mistakeCategory'],
      mistakeNote: map['mistakeNote'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'status': status,
      'selectedOption': selectedOption,
      'correctOption': correctOption,
      'timeSpent': timeSpent,
      'visitCount': visitCount,
      'q_no': q_no,
      'exam': exam,
      'subject': subject,
      'chapter': chapter,
      'topic': topic,
      'topicL2': topicL2,
      'chapterId': chapterId,
      'topicId': topicId,
      'topicL2Id': topicL2Id,
      'smartTimeAnalysis': smartTimeAnalysis,
      'pyq': pyq,
      'difficultyTag': difficultyTag,
      'mistakeCategory': mistakeCategory,
      'mistakeNote': mistakeNote,
    };
  }
}

class AttemptModel {
  final String id;
  final String sourceId;
  final String assignmentCode;

  // Title
  final String title;

  // NEW FIELD: Only Single Attempt Flag
  final bool onlySingleAttempt;

  final String mode;
  final String userId;
  final Timestamp startedAt;
  final Timestamp completedAt;
  final num score;
  final int totalQuestions;
  final int maxMarks;

  final int correctCount;
  final int incorrectCount;
  final int skippedCount;

  final int timeTakenSeconds;

  final int? timeLimitMinutes;

  final Map<String, int> smartTimeAnalysisCounts;
  final Map<String, int> secondsBreakdownHighLevel;
  final Map<String, int> secondsBreakdownSmartTimeAnalysis;

  final Map<String, ResponseObject> responses;

  AttemptModel({
    required this.id,
    required this.sourceId,
    required this.assignmentCode,
    this.title = 'Test Attempt',

    // Initialize new field (Defaulting to false ensures backward compatibility)
    this.onlySingleAttempt = false,

    required this.mode,
    required this.userId,
    required this.startedAt,
    required this.completedAt,
    required this.score,
    required this.totalQuestions,
    required this.maxMarks,
    required this.correctCount,
    required this.incorrectCount,
    required this.skippedCount,
    required this.timeTakenSeconds,
    this.timeLimitMinutes,
    required this.smartTimeAnalysisCounts,
    required this.responses,
    this.secondsBreakdownHighLevel = const {},
    this.secondsBreakdownSmartTimeAnalysis = const {},
  });

  factory AttemptModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    dynamic rawStartedAt = data['startedAt'];
    Timestamp startedAtTimestamp = (rawStartedAt is String)
        ? Timestamp.fromDate(DateTime.parse(rawStartedAt))
        : rawStartedAt ?? Timestamp.now();

    dynamic rawCompletedAt = data['completedAt'];
    Timestamp completedAtTimestamp = (rawCompletedAt is String)
        ? Timestamp.fromDate(DateTime.parse(rawCompletedAt))
        : rawCompletedAt ?? Timestamp.now();

    Map<String, ResponseObject> parsedResponses = {};
    if (data['responses'] is Map) {
      (data['responses'] as Map).forEach((key, value) {
        if (value is Map) {
          parsedResponses[key] =
              ResponseObject.fromMap(value as Map<String, dynamic>);
        }
      });
    }

    Map<String, int> parseIntMap(dynamic mapData) {
      Map<String, int> result = {};
      if (mapData is Map) {
        mapData.forEach((key, value) {
          result[key.toString()] = (value as num).toInt();
        });
      }
      return result;
    }

    return AttemptModel(
      id: doc.id,
      sourceId: data['sourceId'] ?? data['testId'] ?? '',
      assignmentCode: data['assignmentCode'] ?? '----',
      title: data['title'] ?? 'Test Attempt',

      // READ NEW FIELD
      onlySingleAttempt: data['onlySingleAttempt'] ?? false,

      mode: data['mode'] ?? 'Test',
      userId: data['userId'] ?? '',
      startedAt: startedAtTimestamp,
      completedAt: completedAtTimestamp,
      score: data['score'] ?? 0,
      totalQuestions: data['total_questions'] ?? 0,
      maxMarks: data['max_marks'] ?? 0,
      correctCount: data['correct_count'] ?? 0,
      incorrectCount: data['incorrect_count'] ?? 0,
      skippedCount: data['skipped_count'] ?? 0,
      timeTakenSeconds: data['timeTakenSeconds'] ?? 0,
      timeLimitMinutes: data['timeLimitMinutes'],
      smartTimeAnalysisCounts: parseIntMap(data['smartTimeAnalysisCounts']),
      responses: parsedResponses,
      secondsBreakdownHighLevel: parseIntMap(data['secondsBreakdownHighLevel']),
      secondsBreakdownSmartTimeAnalysis: parseIntMap(data['secondsBreakdownSmartTimeAnalysis']),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'sourceId': sourceId,
      'assignmentCode': assignmentCode,
      'title': title,

      // WRITE NEW FIELD
      'onlySingleAttempt': onlySingleAttempt,

      'mode': mode,
      'userId': userId,
      'startedAt': startedAt,
      'completedAt': completedAt,
      'score': score,
      'total_questions': totalQuestions,
      'max_marks': maxMarks,
      'correct_count': correctCount,
      'incorrect_count': incorrectCount,
      'skipped_count': skippedCount,
      'timeTakenSeconds': timeTakenSeconds,
      'timeLimitMinutes': timeLimitMinutes,
      'smartTimeAnalysisCounts': smartTimeAnalysisCounts,
      'secondsBreakdownHighLevel': secondsBreakdownHighLevel,
      'secondsBreakdownSmartTimeAnalysis': secondsBreakdownSmartTimeAnalysis,
      'responses': responses.map((key, value) => MapEntry(key, value.toMap())),
    };
  }
}

================================================================================
FILE: lib/models/custom_test_model.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';

// Represents a test that has been generated and potentially saved.
class CustomTest {
  final String id;
  final String userId;
  final String testName;
  final String status; // e.g., 'Not Attempted', 'Attempted'
  final List<String> questionIds;
  final int totalQuestions;
  final int timeLimitInMinutes;
  final Timestamp createdAt;
  final List<String> chapterNames;

  CustomTest({
    required this.id,
    required this.userId,
    required this.testName,
    required this.status,
    required this.questionIds,
    required this.totalQuestions,
    required this.timeLimitInMinutes,
    required this.createdAt,
    required this.chapterNames,
  });

  // Factory to create a CustomTest from a Firestore document.
  factory CustomTest.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    return CustomTest(
      id: doc.id,
      userId: data['userId'] ?? '',
      testName: data['testName'] ?? 'Custom Test',
      status: data['status'] ?? 'Not Attempted',
      questionIds: List<String>.from(data['questionIds'] ?? []),
      totalQuestions: data['totalQuestions'] ?? 0,
      timeLimitInMinutes: data['timeLimitInMinutes'] ?? 0,
      createdAt: data['createdAt'] ?? Timestamp.now(),
      chapterNames: List<String>.from(data['chapterNames'] ?? []),
    );
  }

  // Method to convert a CustomTest instance to a map for Firestore.
  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'testName': testName,
      'status': status,
      'questionIds': questionIds,
      'totalQuestions': totalQuestions,
      'timeLimitInMinutes': timeLimitInMinutes,
      'createdAt': createdAt,
      'chapterNames': chapterNames,
    };
  }
}


================================================================================
FILE: lib/models/nta_test_models.dart
================================================================================
import 'package:flutter/material.dart';

enum AnswerStatus {
  notVisited,
  notAnswered, // Visited but skipped
  answered,
  markedForReview, // Not answered, but marked
  answeredAndMarked, // Answered and marked for review
}

extension AnswerStatusExtension on AnswerStatus {
  Color get color {
    switch (this) {
      case AnswerStatus.answered:
        return Colors.green;
      case AnswerStatus.notAnswered:
        return Colors.red;
      case AnswerStatus.markedForReview:
        return Colors.purple;
      case AnswerStatus.answeredAndMarked:
        return Colors.blue;
      case AnswerStatus.notVisited:
      default:
        return Colors.grey.shade400;
    }
  }
}

class AnswerState {
  String? userAnswer;
  AnswerStatus status;

  AnswerState({this.userAnswer, this.status = AnswerStatus.notVisited});
}


================================================================================
FILE: lib/models/question_model.dart
================================================================================
// lib/models/question_model.dart

import 'package:cloud_firestore/cloud_firestore.dart';

enum QuestionType {
  singleCorrect,   // Matches Firestore 'Single Correct'
  numerical,       // Matches Firestore 'Numerical type'
  multipleCorrect, // Matches Firestore 'One or more options correct'
  matrixSingle,    // Matches Firestore 'Single Matrix Match'
  matrixMulti,     // Matches Firestore 'Multi Matrix Match'
  unknown          // Safety fallback
}

class Question {
  final String id;

  // IDs
  final String chapterId;
  final String topicId;
  final String topicL2Id;

  // Names / Context
  final String subject;
  final String chapter;
  final String topic;
  final String topicL2;

  // Question Details
  final QuestionType type;
  final String imageUrl;
  final String? solutionUrl;
  final dynamic correctAnswer;
  final String difficulty;
  final String exam; // Matches 'Exam' field
  final bool isPyq;
  final int questionNo;

  Question({
    required this.id,
    required this.chapterId,
    required this.topicId,
    required this.topicL2Id,
    required this.subject,
    required this.chapter,
    required this.topic,
    required this.topicL2,
    required this.type,
    required this.imageUrl,
    this.solutionUrl,
    required this.correctAnswer,
    required this.difficulty,
    required this.exam,
    required this.isPyq,
    required this.questionNo,
  });

  factory Question.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    return Question(
      id: doc.id,
      // IDs
      chapterId: data['chapterId'] ?? '',
      topicId: data['topicId'] ?? '', // Default if missing in doc
      topicL2Id: data['topicL2Id'] ?? '',

      // Names
      subject: data['Subject'] ?? 'Physics',
      chapter: data['Chapter'] ?? '',
      topic: data['Topic'] ?? '',
      topicL2: data['Topic_L2'] ?? '',

      // Details
      type: _mapStringToType(data['Question type']),
      imageUrl: data['image_url'] ?? '',
      solutionUrl: data['solution_url'],
      correctAnswer: data['Correct Answer'],
      difficulty: data['Difficulty_tag'] ?? 'Medium',
      exam: data['Exam'] ?? '',
      isPyq: (data['PYQ'] ?? '') == 'Yes',
      questionNo: data['Question No.'] is int
          ? data['Question No.']
          : int.tryParse(data['Question No.']?.toString() ?? '0') ?? 0,
    );
  }

  // Helper to convert Firestore String -> Enum
  static QuestionType _mapStringToType(String? typeString) {
    switch (typeString) {
      case 'Single Correct':
        return QuestionType.singleCorrect;
      case 'Numerical type':
        return QuestionType.numerical;
      case 'One or more options correct':
        return QuestionType.multipleCorrect;
      case 'Single Matrix Match':
        return QuestionType.matrixSingle;
      case 'Multi Matrix Match':
        return QuestionType.matrixMulti;
      default:
        return QuestionType.unknown;
    }
  }
}

================================================================================
FILE: lib/models/test_enums.dart
================================================================================
// lib/models/test_enums.dart
enum TestMode {
  test,      // Timer counts down, no feedback, auto-submit
  practice,  // Timer counts up (or hidden), instant feedback, solution access, pause allowed
}

enum PerformanceCategory {
  mastery,      // Correct & Fast (Ideal)
  needsSpeed,   // Correct & Slow (Knowledge is there, speed is not)
  rushed,       // Incorrect & Fast (Likely a silly mistake or guess)
  struggle,     // Incorrect & Slow (Conceptual gap)
  skipped,      // Not attempted
  notVisited    // Didn't reach
}

================================================================================
FILE: lib/models/test_model.dart
================================================================================


import 'package:cloud_firestore/cloud_firestore.dart';

class TestConfig {
  final int durationSeconds;
  final int totalQuestions;

  TestConfig({
    required this.durationSeconds,
    required this.totalQuestions,
  });

  factory TestConfig.fromMap(Map<String, dynamic> map) {
    return TestConfig(
      durationSeconds: map['durationSeconds'] ?? 0,
      totalQuestions: map['totalQuestions'] ?? 0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'durationSeconds': durationSeconds,
      'totalQuestions': totalQuestions,
    };
  }
}

class TestModel {
  final String id;
  final String createdBy;
  final Timestamp createdAt;
  final String status;
  final String testName;
  final TestConfig config;
  final List<String> questionIds;
  final List<String> chapters;
  final String? shareCode; // New field
  final List<String> uidsAttemptedTests; // New field

  TestModel({
    required this.id,
    required this.createdBy,
    required this.createdAt,
    required this.status,
    required this.testName,
    required this.config,
    required this.questionIds,
    required this.chapters,
    this.shareCode,
    required this.uidsAttemptedTests,
  });

  factory TestModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    dynamic rawTimestamp = data['createdAt'];
    Timestamp createdAtTimestamp;
    if (rawTimestamp is String) {
      createdAtTimestamp = Timestamp.fromDate(DateTime.parse(rawTimestamp));
    } else if (rawTimestamp is Timestamp) {
      createdAtTimestamp = rawTimestamp;
    } else {
      createdAtTimestamp = Timestamp.now();
    }

    return TestModel(
      id: doc.id,
      createdBy: data['createdBy'] ?? '',
      createdAt: createdAtTimestamp,
      status: data['status'] ?? 'GENERATED',
      testName: data['testName'] ?? 'Unnamed Test',
      config: TestConfig.fromMap(data['config'] ?? {}),
      questionIds: List<String>.from(data['questionIds'] ?? []),
      chapters: List<String>.from(data['chapters'] ?? []),
      shareCode: data['shareCode'],
      uidsAttemptedTests: List<String>.from(data['uidsAttemptedTests'] ?? []),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'createdBy': createdBy,
      'createdAt': createdAt,
      'status': status,
      'testName': testName,
      'config': config.toMap(),
      'questionIds': questionIds,
      'chapters': chapters,
      'shareCode': shareCode,
      'uidsAttemptedTests': uidsAttemptedTests,
    };
  }
}


================================================================================
FILE: lib/models/test_result.dart
================================================================================
// lib/models/test_result.dart

import 'package:study_smart_qc/models/attempt_model.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/question_model.dart';

class TestResult {
  final String attemptId; // Added: Unique ID of the attempt session
  final List<Question> questions;
  final Map<int, AnswerState> answerStates;
  final Duration timeTaken;
  final int totalMarks;
  final Map<String, ResponseObject> responses;

  TestResult({
    required this.attemptId, // Added
    required this.questions,
    required this.answerStates,
    required this.timeTaken,
    required this.totalMarks,
    required this.responses,
  });
}

================================================================================
FILE: lib/models/user_model.dart
================================================================================
// lib/models/user_model.dart

import 'package:cloud_firestore/cloud_firestore.dart';

class UserStats {
  final int testsTaken;
  final int questionsSolved;
  final double averageAccuracy;

  UserStats({
    this.testsTaken = 0,
    this.questionsSolved = 0,
    this.averageAccuracy = 0.0,
  });

  factory UserStats.fromMap(Map<String, dynamic> map) {
    return UserStats(
      testsTaken: map['testsTaken'] ?? 0,
      questionsSolved: map['questionsSolved'] ?? 0,
      averageAccuracy: (map['averageAccuracy'] ?? 0.0).toDouble(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'testsTaken': testsTaken,
      'questionsSolved': questionsSolved,
      'averageAccuracy': averageAccuracy,
    };
  }
}

class UserModel {
  final String uid;
  final String email;
  final String displayName;
  final UserStats stats;
  final List<String> testIDsattempted;
  final Timestamp createdAt;

  // --- NEW FIELD FOR TRACKING SUBMISSIONS ---
  final List<String> assignmentCodesSubmitted;

  // --- NEW ONBOARDING FIELDS ---
  final String role; // 'student' or 'teacher'
  final bool onboardingCompleted;

  // Student Specific
  final int? studentId;
  final String? targetExam;
  final String? currentClass;
  final int? targetYear;

  // Teacher Specific
  final List<String>? teachingExams;
  final List<String>? teachingSubjects;

  UserModel({
    required this.uid,
    required this.email,
    required this.displayName,
    required this.stats,
    required this.testIDsattempted,
    required this.createdAt,
    this.assignmentCodesSubmitted = const [], // Default empty
    this.role = 'student',
    this.onboardingCompleted = false,
    this.studentId,
    this.targetExam,
    this.currentClass,
    this.targetYear,
    this.teachingExams,
    this.teachingSubjects,
  });

  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;

    return UserModel(
      uid: doc.id,
      email: data['email'] ?? '',
      displayName: data['displayName'] ?? '',
      stats: UserStats.fromMap(data['stats'] ?? {}),
      testIDsattempted: List<String>.from(data['testIDsattempted'] ?? []),
      createdAt: data['createdAt'] ?? Timestamp.now(),

      // Map New Submission Tracking Field
      assignmentCodesSubmitted: List<String>.from(data['assignmentCodesSubmitted'] ?? []),

      // Map Onboarding Fields
      role: data['role'] ?? 'student',
      onboardingCompleted: data['onboardingCompleted'] ?? false,
      studentId: data['studentId'],
      targetExam: data['targetExam'],
      currentClass: data['currentClass'],
      targetYear: data['targetYear'],
      teachingExams: data['teachingExams'] != null
          ? List<String>.from(data['teachingExams'])
          : null,
      teachingSubjects: data['teachingSubjects'] != null
          ? List<String>.from(data['teachingSubjects'])
          : null,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'email': email,
      'displayName': displayName,
      'stats': stats.toMap(),
      'testIDsattempted': testIDsattempted,
      'createdAt': createdAt,

      // Save New Submission Tracking Field
      'assignmentCodesSubmitted': assignmentCodesSubmitted,

      // Save Onboarding Fields
      'role': role,
      'onboardingCompleted': onboardingCompleted,
      'studentId': studentId,
      'targetExam': targetExam,
      'currentClass': currentClass,
      'targetYear': targetYear,
      'teachingExams': teachingExams,
      'teachingSubjects': teachingSubjects,
    };
  }
}

================================================================================
FILE: lib/Screens/teacher/curation_management_screen.dart
================================================================================
import 'package:flutter/material.dart';

class CurationManagementScreen extends StatefulWidget {
  final String curationId;
  final String title;

  const CurationManagementScreen({
    Key? key,
    required this.curationId,
    required this.title,
  }) : super(key: key);

  @override
  State<CurationManagementScreen> createState() => _CurationManagementScreenState();
}

class _CurationManagementScreenState extends State<CurationManagementScreen>
    with SingleTickerProviderStateMixin {

  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    // Tab 0: Manage Questions, Tab 1: Student Stats
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.edit_note), text: "Manage Content"),
            Tab(icon: Icon(Icons.bar_chart), text: "Performance"),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          // Placeholder for the Re-ordering/Randomizing Logic
          Center(child: Text("Manage content for ${widget.curationId}")),

          // Placeholder for the Student Stats Logic
          Center(child: Text("Student stats for ${widget.curationId}")),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/services/auth_service.dart
================================================================================
// lib/services/auth_service.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:study_smart_qc/models/user_model.dart';

class AuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final GoogleSignIn _googleSignIn = GoogleSignIn();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Stream for auth changes
  Stream<User?> get userStream {
    return _auth.authStateChanges();
  }

  Future<void> _createUserDocumentIfNotExist(
      User user, {
        String? displayName,
      }) async {
    final userRef = _firestore.collection('users').doc(user.uid);
    final doc = await userRef.get();
    if (!doc.exists) {
      final newUser = UserModel(
        uid: user.uid,
        email: user.email ?? '',
        displayName: displayName ?? user.displayName ?? '',
        stats: UserStats(),
        testIDsattempted: [],
        createdAt: Timestamp.now(),
        // Defaults
        role: 'student',
        onboardingCompleted: false,
      );
      await userRef.set(newUser.toFirestore());
    }
  }

  // UPDATED: Now rethrows exceptions so UI can handle them
  Future<UserCredential?> signInWithGoogle() async {
    // Let errors bubble up to be caught by the UI
    final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
    if (googleUser == null) return null; // User canceled

    final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
    final OAuthCredential credential = GoogleAuthProvider.credential(
      accessToken: googleAuth.accessToken,
      idToken: googleAuth.idToken,
    );

    UserCredential userCredential = await _auth.signInWithCredential(credential);
    if (userCredential.user != null) {
      await _createUserDocumentIfNotExist(userCredential.user!);
    }
    return userCredential;
  }

  // UPDATED: Removed try-catch to allow specific error handling in UI
  Future<UserCredential?> signInWithEmailAndPassword(String email, String password) async {
    return await _auth.signInWithEmailAndPassword(email: email, password: password);
  }

  // UPDATED: Removed try-catch to allow specific error handling in UI
  Future<UserCredential?> signUpWithEmailAndPassword(String email, String password, String displayName) async {
    UserCredential userCredential = await _auth.createUserWithEmailAndPassword(email: email, password: password);
    User? user = userCredential.user;
    if (user != null) {
      await user.updateDisplayName(displayName);
      await _createUserDocumentIfNotExist(user, displayName: displayName);
    }
    return userCredential;
  }

  Future<void> signOut() async {
    await _googleSignIn.signOut();
    await _auth.signOut();
  }
}

================================================================================
FILE: lib/services/custom_test_service.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:study_smart_qc/models/custom_test_model.dart';

class CustomTestService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Get the current user's ID
  String? get _userId => _auth.currentUser?.uid;

  // Save a generated test to Firestore
  Future<void> saveTest(CustomTest test) async {
    if (_userId == null) return;

    final docRef = _firestore
        .collection('users')
        .doc(_userId)
        .collection('custom_tests')
        .doc(); // Auto-generate ID

    await docRef.set(test.toFirestore());
  }

  // Retrieve all tests for the current user
  Stream<List<CustomTest>> getCustomTests() {
    if (_userId == null) return Stream.value([]);

    return _firestore
        .collection('users')
        .doc(_userId)
        .collection('custom_tests')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => CustomTest.fromFirestore(doc))
              .toList();
        });
  }

  // Fetch the full Question objects for a saved test
  Future<List<Map<String, dynamic>>> getQuestionsForTest(
    List<String> questionIds,
  ) async {
    if (questionIds.isEmpty) return [];

    final querySnapshot = await _firestore
        .collection('questions')
        .where(FieldPath.documentId, whereIn: questionIds)
        .get();

    return querySnapshot.docs.map((doc) => doc.data()).toList();
  }
}


================================================================================
FILE: lib/services/local_session_service.dart
================================================================================
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:study_smart_qc/models/attempt_model.dart';

class LocalSessionService {
  static const String _sessionKey = 'current_active_session';

  // ===========================================================================
  // 1. SAVE SESSION (The Black Box Recorder)
  // ===========================================================================
  /// Call this on every user interaction (Next, Answer, Mark Review) and Lifecycle Pause.
  Future<void> saveSession({
    required String assignmentCode,
    required String mode, // Expects 'Test' or 'Practice' (Title Case)
    required String testId,
    required int totalQuestions,
    required int currentTimerValue, // Seconds remaining (Test) or elapsed (Practice)
    required int currentQuestionIndex,
    required Map<String, ResponseObject> responses,
  }) async {
    final prefs = await SharedPreferences.getInstance();

    // Serialize Responses using the new .toJson() method
    final serializedResponses = responses.map(
          (key, value) => MapEntry(key, value.toJson()),
    );

    final sessionData = {
      "testSessionPending": "Session pending",
      "meta": {
        "assignmentCode": assignmentCode,
        "mode": mode,
        "testId": testId,
        "totalQuestions": totalQuestions
      },
      "timestamps": {
        "quitTimeTimestamp": DateTime.now().toIso8601String(),
        "quitTimeTimerValue": currentTimerValue
      },
      "state": {
        "currentQuestionIndex": currentQuestionIndex,
        "responses": serializedResponses
      }
    };

    await prefs.setString(_sessionKey, jsonEncode(sessionData));
  }

  // ===========================================================================
  // 2. CHECK & FETCH (The Gatekeeper)
  // ===========================================================================

  /// Checks if a valid pending session exists.
  Future<bool> hasPendingSession() async {
    final prefs = await SharedPreferences.getInstance();
    if (!prefs.containsKey(_sessionKey)) return false;

    final jsonString = prefs.getString(_sessionKey);
    if (jsonString == null) return false;

    try {
      final data = jsonDecode(jsonString);
      return data['testSessionPending'] == "Session pending";
    } catch (e) {
      return false; // Corrupt data
    }
  }

  /// Retrieves the raw session data.
  Future<Map<String, dynamic>?> getSessionData() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_sessionKey);
    if (jsonString == null) return null;
    return jsonDecode(jsonString);
  }

  // ===========================================================================
  // 3. TIMER RECONCILIATION (The Anti-Cheat Math)
  // ===========================================================================

  /// Calculates the correct time to resume from.
  /// Returns NULL if the test time has expired while away.
  int? calculateResumeTime({
    required String mode,
    required int savedTimerValue,
    required String savedTimestampIso,
  }) {
    // 1. Practice Mode: Effort based. Ignore the gap.
    if (mode == 'Practice') {
      return savedTimerValue;
    }

    // 2. Test Mode: Strict time.
    final savedTime = DateTime.parse(savedTimestampIso);
    final now = DateTime.now();
    final timeGoneSeconds = now.difference(savedTime).inSeconds;

    // We subtract the time they were away from the time they had left.
    final newRemainingTime = savedTimerValue - timeGoneSeconds;

    if (newRemainingTime <= 0) {
      return null; // Time Expired!
    }
    return newRemainingTime;
  }

  // ===========================================================================
  // 4. HELPERS
  // ===========================================================================

  /// Helper to convert the JSON map back into your ResponseObject Map
  Map<String, ResponseObject> parseResponses(Map<String, dynamic> jsonMap) {
    // The jsonMap from storage is Map<String, dynamic> where value is the JSON of ResponseObject
    return jsonMap.map(
          (key, value) => MapEntry(key, ResponseObject.fromJson(value)),
    );
  }

  /// Clears the session from disk (Call after successful submission).
  Future<void> clearSession() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_sessionKey);
  }
}

================================================================================
FILE: lib/services/onboarding_service.dart
================================================================================
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart'; // Import this
import 'package:study_smart_qc/models/user_model.dart'; // Import this

class OnboardingService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance; // Add auth instance

  // --- NEW METHOD TO FIX ERROR ---
  Future<UserModel?> getCurrentUserModel() async {
    final user = _auth.currentUser;
    if (user == null) return null;

    try {
      final doc = await _firestore.collection('users').doc(user.uid).get();
      if (doc.exists) {
        return UserModel.fromFirestore(doc);
      }
    } catch (e) {
      print("Error fetching user profile: $e");
    }
    return null;
  }

  /// Completes the onboarding process.
  // ... (Keep the rest of your existing code below specifically completeOnboarding, _handleStudentOnboarding, etc.)
  Future<void> completeOnboarding({
    required String uid,
    required String role,
    required Map<String, dynamic> profileData,
  }) async {
    // ... (Your existing logic) ...
    final userRef = _firestore.collection('users').doc(uid);
    if (role == 'student') {
      await _handleStudentOnboarding(userRef, uid, profileData);
    } else {
      await _handleTeacherOnboarding(userRef, profileData);
    }
  }

  // ... (Keep _handleStudentOnboarding and _handleTeacherOnboarding exactly as they were) ...
  Future<void> _handleStudentOnboarding(
      DocumentReference userRef,
      String uid,
      Map<String, dynamic> profileData,
      ) async {
    // ... existing implementation ...
    final optionSetsRef = _firestore.collection('static_data').doc('option_sets');
    final trackerRef = _firestore.collection('student_question_tracker').doc(uid);

    return _firestore.runTransaction((transaction) async {
      DocumentSnapshot optionSetsSnapshot = await transaction.get(optionSetsRef);
      if (!optionSetsSnapshot.exists) throw Exception("System Error");

      int currentId = optionSetsSnapshot.get('last_assigned_student_id') ?? 0;
      int newId = currentId + 1;

      transaction.update(optionSetsRef, {'last_assigned_student_id': newId});
      transaction.update(userRef, {
        'role': 'student',
        'onboardingCompleted': true,
        'studentId': newId,
        'targetExam': profileData['targetExam'],
        'currentClass': profileData['currentClass'],
        'targetYear': profileData['targetYear'],
        'teachingExams': FieldValue.delete(),
        'teachingSubjects': FieldValue.delete(),
      });
      transaction.set(trackerRef, {
        'student_id': newId,
        'assigned_history': [],
        'buckets': {'unattempted': [], 'skipped': [], 'incorrect': [], 'correct': []}
      });
    });
  }

  Future<void> _handleTeacherOnboarding(DocumentReference userRef, Map<String, dynamic> profileData) async {
    await userRef.update({
      'role': 'teacher',
      'onboardingCompleted': true,
      'teachingExams': profileData['teachingExams'],
      'teachingSubjects': profileData['teachingSubjects'],
      'studentId': FieldValue.delete(),
      'targetExam': FieldValue.delete(),
      'currentClass': FieldValue.delete(),
      'targetYear': FieldValue.delete(),
    });
  }
}

================================================================================
FILE: lib/services/teacher_service.dart
================================================================================
// lib/services/teacher_service.dart

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/attempt_model.dart';

// --- HELPER CLASS FOR PAGINATION ---
class PaginatedQuestions {
  final List<Question> questions;
  final DocumentSnapshot? lastDoc;
  PaginatedQuestions(this.questions, this.lastDoc);
}

class TeacherService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // --- 1. STATS DASHBOARD ---
  Future<Map<String, int>> getStudentStats(int studentId) async {
    final uid = await _findUidByStudentId(studentId);
    if (uid == null) return {};

    final doc = await _firestore.collection('student_question_tracker').doc(uid).get();
    if (!doc.exists) return {};

    final data = doc.data()!;
    final buckets = data['buckets'] as Map<String, dynamic>;
    final assigned = (data['assigned_history'] as List?)?.length ?? 0;

    return {
      'Assigned': assigned,
      'Unattempted': (buckets['unattempted'] as List?)?.length ?? 0,
      'Incorrect': (buckets['incorrect'] as List?)?.length ?? 0,
      'Correct': (buckets['correct'] as List?)?.length ?? 0,
      'Skipped': (buckets['skipped'] as List?)?.length ?? 0,
    };
  }

  // --- 2. ADVANCED SEARCH (PAGINATED) ---

  Future<PaginatedQuestions> fetchQuestionsPaged({
    required String audienceType,
    int? studentId,
    String? smartFilter,
    String? subject,
    List<String>? chapterIds,
    List<String>? topicIds,
    int limit = 20, // Default reduced to 20
    DocumentSnapshot? startAfter, // Cursor for pagination
  }) async {
    // 1. Determine Source (Tracker vs General Pool)
    // Note: Tracker-based fetching (Smart Filter) is hard to paginate via Firestore query
    // because it reads a list of IDs. For now, we fetch the list and handle slicing manually
    // if needed, or just return all since tracker buckets usually aren't massive.
    // For 'General' search, we use true Firestore pagination.

    if (audienceType == 'Particular Student' && smartFilter != null && smartFilter != 'New Questions') {
      // Logic for Tracker (Pre-existing logic, simplified return)
      final allQuestions = await _fetchFromTracker(studentId!, smartFilter);
      // We simulate pagination or just return all for tracker buckets
      return PaginatedQuestions(allQuestions, null);
    }

    // 2. General Pool Query Construction
    Query query = _firestore.collection('questions');

    if (chapterIds != null && chapterIds.isNotEmpty) {
      // 'whereIn' limits to 10. If more, we might need multiple queries,
      // but assuming the UI restricts or we take first 10.
      query = query.where('chapterId', whereIn: chapterIds.take(10).toList());
    }

    // Apply Cursor
    if (startAfter != null) {
      query = query.startAfterDocument(startAfter);
    }

    // Apply Limit
    final snap = await query.limit(limit).get();

    // Convert
    List<Question> questions = snap.docs.map((d) => Question.fromFirestore(d)).toList();

    // 3. Filter by Topic (Client-side)
    // Firestore can't do whereIn(chapters) AND whereIn(topics) easily.
    if (topicIds != null && topicIds.isNotEmpty) {
      questions = questions.where((q) => topicIds.contains(q.topicId)).toList();
    }

    // 4. Exclude History (Client-side)
    if (audienceType == 'Particular Student' && studentId != null) {
      final historyIds = await _getStudentHistory(studentId);
      questions = questions.where((q) => !historyIds.contains(q.id)).toList();
    }

    return PaginatedQuestions(
        questions,
        snap.docs.isNotEmpty ? snap.docs.last : null
    );
  }

  // --- 3. MANAGE CURATIONS ---
  Stream<QuerySnapshot> getTeacherCurations(String teacherUid) {
    return _firestore
        .collection('questions_curation')
        .where('teacherUid', isEqualTo: teacherUid)
        .orderBy('createdAt', descending: true)
        .snapshots();
  }

  // --- 4. MANAGEMENT ---
  Future<void> cloneAssignment({
    required String originalDocId,
    required int targetStudentId,
    required String teacherUid,
  }) async {
    final docSnapshot = await _firestore.collection('questions_curation').doc(originalDocId).get();
    if (!docSnapshot.exists) throw Exception("Original assignment not found.");
    final data = docSnapshot.data()!;

    final newStudentUid = await _findUidByStudentId(targetStudentId);
    if (newStudentUid == null) throw Exception("Target student ID not found.");

    final newRef = _firestore.collection('questions_curation').doc();
    final newCode = _generateAssignmentCode();

    final newData = Map<String, dynamic>.from(data);
    newData['assignmentId'] = newRef.id;
    newData['assignmentCode'] = newCode;
    newData['studentUid'] = newStudentUid;
    newData['teacherUid'] = teacherUid;
    newData['createdAt'] = FieldValue.serverTimestamp();
    newData['status'] = 'assigned';

    final batch = _firestore.batch();
    batch.set(newRef, newData);

    final trackerRef = _firestore.collection('student_question_tracker').doc(newStudentUid);
    final List<dynamic> qIds = data['questionIds'] ?? [];

    batch.update(trackerRef, {
      'assigned_history': FieldValue.arrayUnion(qIds),
      'buckets.unattempted': FieldValue.arrayUnion(qIds),
    });

    await batch.commit();
  }

  Future<void> updateQuestionOrder(String docId, List<String> newOrder) async {
    await _firestore.collection('questions_curation').doc(docId).update({
      'questionIds': newOrder,
    });
  }

  // --- 5. ASSIGNMENT LOGIC ---
  Future<void> assignQuestionsToStudent({
    required int studentId,
    required List<Question> questions,
    required String teacherUid,
    required String targetAudience,
    String assignmentTitle = "Teacher Assignment",
    bool onlySingleAttempt = false,
    int? timeLimitMinutes,
  }) async {
    final studentUid = await _findUidByStudentId(studentId);
    if (studentUid == null) throw Exception("Student not found");

    final newAssignmentRef = _firestore.collection('questions_curation').doc();
    final trackerRef = _firestore.collection('student_question_tracker').doc(studentUid);
    final batch = _firestore.batch();

    final assignmentCode = _generateAssignmentCode();
    final questionIds = questions.map((q) => q.id).toList();
    final subjects = questions.map((q) => q.chapterId.split('_').first).toSet().toList();
    final hierarchy = _buildHierarchy(questions);
    final int finalTimeLimit = timeLimitMinutes ?? (questions.length * 2);

    batch.set(newAssignmentRef, {
      'assignmentId': newAssignmentRef.id,
      'assignmentCode': assignmentCode,
      'targetAudience': targetAudience,
      'studentUid': studentUid,
      'teacherUid': teacherUid,
      'title': assignmentTitle,
      'questionIds': questionIds,
      'createdAt': FieldValue.serverTimestamp(),
      'status': 'assigned',
      'onlySingleAttempt': onlySingleAttempt,
      'timeLimitMinutes': finalTimeLimit,
      'subjects': subjects,
      'meta_hierarchy': hierarchy,
    });

    batch.update(trackerRef, {
      'assigned_history': FieldValue.arrayUnion(questionIds),
      'buckets.unattempted': FieldValue.arrayUnion(questionIds),
    });

    await batch.commit();
  }

  // --- 6. PERFORMANCE MONITORING ---
  Future<AttemptModel?> getAttemptForCuration(String curationId) async {
    try {
      final query = await _firestore
          .collection('attempts')
          .where('sourceId', isEqualTo: curationId)
          .orderBy('completedAt', descending: true)
          .limit(1)
          .get();

      if (query.docs.isNotEmpty) {
        return AttemptModel.fromFirestore(query.docs.first);
      }
      return null;
    } catch (e) {
      print("Error fetching curation attempt: $e");
      return null;
    }
  }

  // --- INTERNAL HELPERS ---
  Future<List<Question>> _fetchFromTracker(int studentId, String bucketKey) async {
    final uid = await _findUidByStudentId(studentId);
    if (uid == null) return [];

    final doc = await _firestore.collection('student_question_tracker').doc(uid).get();
    if (!doc.exists) return [];

    final buckets = doc.data()!['buckets'] as Map<String, dynamic>;
    String dbKey = bucketKey.toLowerCase();
    if (bucketKey.contains('Incorrect')) dbKey = 'incorrect';
    if (bucketKey.contains('Unattempted')) dbKey = 'unattempted';
    if (bucketKey.contains('Correct')) dbKey = 'correct';
    if (bucketKey.contains('Skipped')) dbKey = 'skipped';

    final ids = List<String>.from(buckets[dbKey] ?? []);
    if (ids.isEmpty) return [];

    final safeIds = ids.take(20).toList(); // Limit tracker fetch too
    final query = await _firestore.collection('questions').where(FieldPath.documentId, whereIn: safeIds).get();
    return query.docs.map((d) => Question.fromFirestore(d)).toList();
  }

  Future<Set<String>> _getStudentHistory(int studentId) async {
    final uid = await _findUidByStudentId(studentId);
    if (uid == null) return {};
    final doc = await _firestore.collection('student_question_tracker').doc(uid).get();
    if (!doc.exists) return {};
    return Set<String>.from(doc.data()!['assigned_history'] ?? []);
  }

  Future<String?> _findUidByStudentId(int studentId) async {
    final query = await _firestore.collection('users').where('studentId', isEqualTo: studentId).limit(1).get();
    if (query.docs.isEmpty) return null;
    return query.docs.first.id;
  }

  String _generateAssignmentCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final rnd = Random();
    return String.fromCharCodes(Iterable.generate(4, (_) => chars.codeUnitAt(rnd.nextInt(chars.length))));
  }

  Map<String, dynamic> _buildHierarchy(List<Question> questions) {
    Map<String, dynamic> hierarchy = {};
    for (var q in questions) {
      final exam = q.exam.isEmpty ? 'Unknown Exam' : q.exam;
      final subject = 'Physics';
      final chapter = q.chapterId.isEmpty ? 'Unknown Chapter' : q.chapterId;
      final topic = q.topicId.isEmpty ? 'Unknown Topic' : q.topicId;

      hierarchy.putIfAbsent(exam, () => <String, dynamic>{});
      hierarchy[exam].putIfAbsent(subject, () => <String, dynamic>{});
      hierarchy[exam][subject].putIfAbsent(chapter, () => <String, dynamic>{});

      final currentCount = hierarchy[exam][subject][chapter][topic] ?? 0;
      hierarchy[exam][subject][chapter][topic] = currentCount + 1;
    }
    return hierarchy;
  }
}

================================================================================
FILE: lib/services/test_orchestration_service.dart
================================================================================
// lib/services/test_orchestration_service.dart

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

// Ensure these imports point to your actual file locations
import 'package:study_smart_qc/models/attempt_item_model.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/models/test_model.dart';
import 'package:study_smart_qc/models/attempt_model.dart';

class TestOrchestrationService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  String? get _userId => _auth.currentUser?.uid;

  // ===========================================================================
  // 1. HISTORY FETCH LOGIC
  // ===========================================================================

  /// Fetch attempts for a user.
  Future<List<AttemptModel>> getUserAttempts({String? targetUserId}) async {
    final String? idToQuery = targetUserId ?? _userId;
    if (idToQuery == null) return [];
    try {
      final snapshot = await _firestore
          .collection('attempts')
          .where('userId', isEqualTo: idToQuery)
          .orderBy('completedAt', descending: true)
          .get();
      return snapshot.docs
          .map((doc) => AttemptModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      print("Error fetching user attempts: $e");
      return [];
    }
  }

  // ===========================================================================
  // 2. UNIVERSAL SUBMISSION LOGIC
  // ===========================================================================

  /// Submits the test attempt and returns the enriched AttemptModel for immediate UI use
  Future<AttemptModel?> submitAttempt({
    required String sourceId,
    required String assignmentCode,
    required String title,

    // NEW ARGUMENT: Only Single Attempt Flag
    required bool onlySingleAttempt,

    required String mode,
    required List<Question> questions,
    required num score,
    required int timeTakenSeconds,
    required Map<String, ResponseObject> responses,
    int? timeLimitMinutes,
  }) async {
    if (_userId == null) return null;

    // --- STEP 1: FETCH CONFIGURATION FOR SMART ANALYSIS ---
    Map<String, dynamic> idealTimeMap = {};
    double carelessFactor = 0.25;
    double goodSkipFactorRaw = 20.0;

    try {
      final configSnap = await _firestore
          .collection('static_data')
          .doc('option_sets')
          .get();

      if (configSnap.exists) {
        final data = configSnap.data()!;
        if (data['idealTimePerQuestion'] != null) {
          idealTimeMap = Map<String, dynamic>.from(data['idealTimePerQuestion']);
        }
        carelessFactor = (data['factorForCarelessAttempt'] ?? 0.25).toDouble();
        goodSkipFactorRaw = (data['factorForGoodSkip'] ?? 20.0).toDouble();
      }
    } catch (e) {
      print("Error fetching analysis config: $e");
    }

    final batch = _firestore.batch();
    final timestamp = Timestamp.now();

    // --- PHASE 2: Enrich Responses & Calculate Tags ---
    Map<String, ResponseObject> enrichedResponses = {};

    Map<String, int> analysisCounts = {
      "Perfect Attempt": 0,
      "Overtime Correct": 0,
      "Careless Mistake": 0,
      "Wasted Attempt": 0,
      "Good Skip": 0,
      "Time Wasted": 0
    };

    Map<String, int> highLevelTime = {"CORRECT": 0, "INCORRECT": 0, "SKIPPED": 0};
    Map<String, int> smartTimeBreakdown = {
      "Perfect Attempt": 0,
      "Overtime Correct": 0,
      "Careless Mistake": 0,
      "Wasted Attempt": 0,
      "Good Skip": 0,
      "Time Wasted": 0
    };

    int correctCount = 0;
    int incorrectCount = 0;
    int skippedCount = 0;

    for (int i = 0; i < questions.length; i++) {
      final question = questions[i];
      final userResponse = responses[question.id];

      final String status = userResponse?.status ?? 'SKIPPED';
      final int timeSpent = userResponse?.timeSpent ?? 0;

      if (status == 'CORRECT') {
        correctCount++;
      } else if (status == 'INCORRECT') {
        incorrectCount++;
      } else {
        skippedCount++;
      }

      highLevelTime[status] = (highLevelTime[status] ?? 0) + timeSpent;

      String smartTag = _generateSmartTag(
        status: status,
        timeTaken: timeSpent,
        examName: question.exam,
        subject: question.subject,
        idealTimeMap: idealTimeMap,
        carelessFactor: carelessFactor,
        goodSkipFactorRaw: goodSkipFactorRaw,
      );

      if (smartTag.isNotEmpty) {
        String shortKey = smartTag.split(' (').first.trim();
        analysisCounts[shortKey] = (analysisCounts[shortKey] ?? 0) + 1;
        smartTimeBreakdown[shortKey] = (smartTimeBreakdown[shortKey] ?? 0) + timeSpent;
      }

      final enrichedResponse = ResponseObject(
        status: status,
        selectedOption: userResponse?.selectedOption,
        correctOption: userResponse?.correctOption ?? question.correctAnswer.toString(),
        timeSpent: timeSpent,
        visitCount: userResponse?.visitCount ?? 0,
        q_no: userResponse?.q_no ?? (i + 1),
        exam: question.exam,
        subject: question.subject,
        chapter: question.chapter,
        topic: question.topic,
        chapterId: question.chapterId,
        topicId: question.topicId,
        topicL2Id: question.topicL2Id,
        smartTimeAnalysis: smartTag,
        mistakeCategory: userResponse?.mistakeCategory,
        mistakeNote: userResponse?.mistakeNote,
        pyq: question.isPyq ? 'Yes' : 'No',
        difficultyTag: question.difficulty,
      );
      enrichedResponses[question.id] = enrichedResponse;
    }

    // --- PHASE 3: Create Records ---
    final int totalQuestionsCount = questions.length;
    final int maxMarksValue = totalQuestionsCount * 4;

    final attemptRef = _firestore.collection('attempts').doc();
    final newAttempt = AttemptModel(
      id: attemptRef.id,
      sourceId: sourceId,
      assignmentCode: assignmentCode,
      title: title,

      // SAVE TO ATTEMPT MODEL
      onlySingleAttempt: onlySingleAttempt,

      mode: mode,
      userId: _userId!,
      startedAt: timestamp,
      completedAt: timestamp,
      score: score,
      totalQuestions: totalQuestionsCount,
      maxMarks: maxMarksValue,
      correctCount: correctCount,
      incorrectCount: incorrectCount,
      skippedCount: skippedCount,
      timeTakenSeconds: timeTakenSeconds,
      timeLimitMinutes: timeLimitMinutes,
      smartTimeAnalysisCounts: analysisCounts,
      secondsBreakdownHighLevel: highLevelTime,
      secondsBreakdownSmartTimeAnalysis: smartTimeBreakdown,
      responses: enrichedResponses,
    );
    batch.set(attemptRef, newAttempt.toFirestore());

    for (final question in questions) {
      final response = enrichedResponses[question.id];
      if (response != null) {
        final attemptItemRef = _firestore.collection('attempt_items').doc();
        batch.set(attemptItemRef, AttemptItemModel(
          userId: _userId!,
          attemptRef: attemptRef,
          questionId: question.id,
          chapterId: question.chapterId,
          topicId: question.topicId,
          status: response.status,
          timeSpent: response.timeSpent,
          attemptedAt: timestamp,
          assignmentCode: assignmentCode,
          mode: mode,
          mistakeCategory: response.mistakeCategory,
          mistakeNote: response.mistakeNote,
        ).toFirestore());
      }
    }

    // --- PHASE 4: Update Tracker ---
    final trackerRef = _firestore.collection('student_question_tracker').doc(_userId);
    final trackerDoc = await trackerRef.get();

    if (trackerDoc.exists) {
      final data = trackerDoc.data()!;
      final buckets = data['buckets'] as Map<String, dynamic>;

      List<String> unattempted = List<String>.from(buckets['unattempted'] ?? []);
      List<String> correct = List<String>.from(buckets['correct'] ?? []);
      List<String> incorrect = List<String>.from(buckets['incorrect'] ?? []);
      List<String> skipped = List<String>.from(buckets['skipped'] ?? []);
      List<String> history = List<String>.from(data['attempted_history'] ?? []);

      enrichedResponses.forEach((qid, response) {
        unattempted.remove(qid);
        correct.remove(qid);
        incorrect.remove(qid);
        skipped.remove(qid);

        if (response.status == 'CORRECT') correct.add(qid);
        else if (response.status == 'INCORRECT') incorrect.add(qid);
        else skipped.add(qid);

        if (!history.contains(qid)) history.add(qid);
      });

      batch.update(trackerRef, {
        'buckets.unattempted': unattempted,
        'buckets.correct': correct,
        'buckets.incorrect': incorrect,
        'buckets.skipped': skipped,
        'attempted_history': history,
      });
    }

    // Update Status
    if (sourceId.isNotEmpty) {
      try {
        final assignmentRef = _firestore.collection('questions_curation').doc(sourceId);
        // Optimization: We already have the flag passed in, but we still need to check/update the doc status
        // If 'onlySingleAttempt' is TRUE, we update the status to submitted.

        if (onlySingleAttempt) {
          batch.update(assignmentRef, {'status': 'submitted'});
        } else {
          // Fallback for logic where we might need to check if it's a test
          final testRef = _firestore.collection('tests').doc(sourceId);
          final testDoc = await testRef.get();
          if(testDoc.exists) batch.update(testRef, {'status': 'Attempted'});
        }
      } catch (e) {
        print("Error updating status: $e");
      }
    }

    // ==========================================================
    // Update User's Submitted List (MOVED BEFORE COMMIT)
    // ==========================================================
    if (assignmentCode.isNotEmpty && assignmentCode != 'PRAC') {
      final userRef = _firestore.collection('users').doc(_userId);
      batch.update(userRef, {
        'assignmentCodesSubmitted': FieldValue.arrayUnion([assignmentCode])
      });
    }

    await batch.commit();
    return newAttempt;
  }

  // ===========================================================================
  // HELPER: SMART TIME TAG GENERATION
  // ===========================================================================

  String _generateSmartTag({
    required String status,
    required int timeTaken,
    required String examName,
    required String subject,
    required Map<String, dynamic> idealTimeMap,
    required double carelessFactor,
    required double goodSkipFactorRaw,
  }) {
    String eName = examName.isEmpty ? "JEE Main" : examName;
    String sName = subject.isEmpty ? "Physics" : subject;
    String configKey = "${eName}_${sName}";

    int idealTime = 120;
    if (idealTimeMap.containsKey(configKey)) {
      idealTime = (idealTimeMap[configKey] as num).toInt();
    }

    double fastThreshold = idealTime * carelessFactor;
    double skipFactor = (goodSkipFactorRaw > 1) ? goodSkipFactorRaw / 100 : goodSkipFactorRaw;
    double goodSkipThreshold = idealTime * skipFactor;

    if (status == 'CORRECT') {
      return (timeTaken <= idealTime)
          ? "Perfect Attempt (Correct & answered within reasonable time)"
          : "Overtime Correct (Correct but took too long)";
    } else if (status == 'INCORRECT') {
      return (timeTaken < fastThreshold)
          ? "Careless Mistake (Incorrect & answered too fast)"
          : "Wasted Attempt (Incorrect & took too long)";
    } else {
      return (timeTaken < goodSkipThreshold)
          ? "Good Skip (Skipped quickly)"
          : "Time Wasted (Skipped but spent too much time)";
    }
  }

  // ===========================================================================
  // 3. CUSTOM TEST & HELPER METHODS
  // ===========================================================================

  String _generateShareCode() {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    final rnd = Random();
    return String.fromCharCodes(Iterable.generate(4, (_) => chars.codeUnitAt(rnd.nextInt(chars.length))));
  }

  Future<TestModel?> createAndSaveTestBlueprint({
    required List<Question> questions,
    required int durationSeconds,
    required List<String> chapterNames,
    required String testName,
  }) async {
    if (_userId == null) return null;
    String shareCode;
    bool isUnique = false;
    do {
      shareCode = _generateShareCode();
      final existing = await _firestore.collection('tests').where('shareCode', isEqualTo: shareCode).limit(1).get();
      if (existing.docs.isEmpty) isUnique = true;
    } while (!isUnique);

    final testRef = _firestore.collection('tests').doc();
    final newTest = TestModel(
      id: testRef.id,
      createdBy: _userId!,
      createdAt: Timestamp.now(),
      status: 'Not Attempted',
      testName: testName,
      config: TestConfig(durationSeconds: durationSeconds, totalQuestions: questions.length),
      questionIds: questions.map((q) => q.id).toList(),
      chapters: chapterNames,
      shareCode: shareCode,
      uidsAttemptedTests: [],
    );
    await testRef.set(newTest.toFirestore());
    return newTest;
  }

  Future<void> recordTestAttempt(String testId) async {
    if (_userId == null) return;
    final batch = _firestore.batch();
    batch.update(_firestore.collection('tests').doc(testId), {'uidsAttemptedTests': FieldValue.arrayUnion([_userId])});
    batch.update(_firestore.collection('users').doc(_userId), {'testIDsattempted': FieldValue.arrayUnion([testId])});
    await batch.commit();
  }

  Future<AttemptModel?> getAttemptForTest(String testId) async {
    if (_userId == null) return null;
    final querySnapshot = await _firestore.collection('attempts').where('sourceId', isEqualTo: testId).where('userId', isEqualTo: _userId).orderBy('completedAt', descending: true).limit(1).get();
    if (querySnapshot.docs.isNotEmpty) return AttemptModel.fromFirestore(querySnapshot.docs.first);
    final oldQuerySnapshot = await _firestore.collection('attempts').where('testId', isEqualTo: testId).where('userId', isEqualTo: _userId).limit(1).get();
    if (oldQuerySnapshot.docs.isNotEmpty) return AttemptModel.fromFirestore(oldQuerySnapshot.docs.first);
    return null;
  }

  Stream<List<TestModel>> getSavedTestsStream() {
    if (_userId == null) return Stream.value([]);
    return _firestore.collection('tests').where('createdBy', isEqualTo: _userId).orderBy('createdAt', descending: true).snapshots().map((snapshot) => snapshot.docs.map((doc) => TestModel.fromFirestore(doc)).toList());
  }

  Future<TestModel?> getTestByShareCode(String shareCode) async {
    final querySnapshot = await _firestore.collection('tests').where('shareCode', isEqualTo: shareCode).limit(1).get();
    return querySnapshot.docs.isNotEmpty ? TestModel.fromFirestore(querySnapshot.docs.first) : null;
  }

  Future<List<Question>> getQuestionsByIds(List<String> questionIds) async {
    if (questionIds.isEmpty) return [];
    final List<Question> fetchedQuestions = [];
    for (var i = 0; i < questionIds.length; i += 10) {
      final chunk = questionIds.sublist(i, min(i + 10, questionIds.length));
      final querySnapshot = await _firestore.collection('questions').where(FieldPath.documentId, whereIn: chunk).get();
      fetchedQuestions.addAll(querySnapshot.docs.map((doc) => Question.fromFirestore(doc)));
    }
    final questionMap = {for (var q in fetchedQuestions) q.id: q};
    return questionIds.map((id) => questionMap[id]).whereType<Question>().toList();
  }

  // ===========================================================================
  // 4. MISTAKE UPDATE LOGIC
  // ===========================================================================

  Future<void> updateQuestionMistake({
    required String attemptId,
    required String questionId,
    required String mistakeCategory,
    String? mistakeNote,
  }) async {
    if (_userId == null) return;
    try {
      final attemptRef = _firestore.collection('attempts').doc(attemptId);
      final attemptSnapshot = await attemptRef.get();
      if (!attemptSnapshot.exists) return;
      final data = attemptSnapshot.data();
      final String? assignmentCode = data?['assignmentCode'];

      await attemptRef.update({
        'responses.$questionId.mistakeCategory': mistakeCategory,
        'responses.$questionId.mistakeNote': mistakeNote ?? '',
      });
      if (assignmentCode != null) {
        final itemQuery = await _firestore.collection('attempt_items').where('userId', isEqualTo: _userId).where('questionId', isEqualTo: questionId).where('assignmentCode', isEqualTo: assignmentCode).limit(1).get();
        if (itemQuery.docs.isNotEmpty) {
          await itemQuery.docs.first.reference.update({'mistakeCategory': mistakeCategory, 'mistakeNote': mistakeNote ?? ''});
        }
      }
    } catch (e) {
      print("Error updating mistake category: $e");
      rethrow;
    }
  }
}

================================================================================
FILE: lib/services/test_service.dart
================================================================================
import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:study_smart_qc/models/question_model.dart';

class TestService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  Future<List<Question>> generateTest({
    required Set<String> chapterIds,
    required Set<String> topicIds,
    required int questionCount,
  }) async {
    if (chapterIds.isEmpty || topicIds.isEmpty) {
      return [];
    }

    // Step 1: Fetch all questions from the selected CHAPTERS.
    // Note: Firestore 'whereIn' is limited to 10 items.
    // If you have more than 10 chapters, you might need to chunk this request.
    QuerySnapshot querySnapshot = await _firestore
        .collection('questions')
        .where('chapterId', whereIn: chapterIds.toList())
        .get();

    List<Question> fetchedQuestions = querySnapshot.docs
        .map((doc) => Question.fromFirestore(doc))
        .toList();

    // Step 2: Locally filter those questions by the selected TOPICS.
    List<Question> filteredByTopic = fetchedQuestions
        .where((q) => topicIds.contains(q.topicId))
        .toList();

    // Step 3: Ensure questions have a valid image URL.
    List<Question> validQuestions = filteredByTopic.where((q) {
      final url = q.imageUrl;
      return url.isNotEmpty &&
          (url.startsWith('http') || url.startsWith('https'));
    }).toList();

    // Step 4: Apply 80/20 split for question types

    // CHANGED: Using the Enum defined in the model (QuestionType)
    final scqQuestions = validQuestions
        .where((q) => q.type == QuestionType.singleCorrect)
        .toList();

    final numericalQuestions = validQuestions
        .where((q) => q.type == QuestionType.numerical)
        .toList();

    scqQuestions.shuffle();
    numericalQuestions.shuffle();

    final numNumerical = (questionCount * 0.2).round();
    final numScq = questionCount - numNumerical;

    final finalScq = scqQuestions
        .take(min(numScq, scqQuestions.length))
        .toList();
    final finalNumerical = numericalQuestions
        .take(min(numNumerical, numericalQuestions.length))
        .toList();

    final finalTestQuestions = [...finalScq, ...finalNumerical];
    finalTestQuestions.shuffle();

    return finalTestQuestions;
  }
}

================================================================================
FILE: lib/utils/performance_analysis_utils.dart
================================================================================
// lib/utils/performance_analysis_utils.dart

// 1. Define the Quadrants
enum PerformanceQuadrant {
  mastery,      // Correct & Fast
  needsSpeed,   // Correct & Slow
  learningGap,  // Incorrect (Fast or Slow)
  wastedEffort, // Incorrect & Slow (Special sub-case, optional)
  skipped,      // Not attempted
  unknown       // Fallback
}

class PerformanceAnalysisUtils {

  // 2. Default Benchmarks (in seconds)
  // You will likely fetch these from Firestore later, but these are safe defaults.
  static const int defaultIdealTimePhysics = 120; // 2 mins
  static const int defaultIdealTimeChemistry = 90; // 1.5 mins
  static const int defaultIdealTimeMaths = 150;    // 2.5 mins

  /// Returns the ideal time for a question based on its subject.
  /// You can expand this to take 'difficulty' or 'questionType' later.
  static int getIdealTime(String subject) {
    switch (subject.toLowerCase()) {
      case 'physics':
        return defaultIdealTimePhysics;
      case 'chemistry':
        return defaultIdealTimeChemistry;
      case 'maths':
      case 'mathematics':
        return defaultIdealTimeMaths;
      default:
        return 120; // Default average
    }
  }

  /// The Core Logic: Determines the quadrant for a single response
  static PerformanceQuadrant analyzeResponse({
    required String status,
    required int timeSpent,
    required String subject,
    int? customIdealTime, // Allow passing a specific time if you fetched it from Config
  }) {
    if (status == 'SKIPPED') {
      return PerformanceQuadrant.skipped;
    }

    if (status == 'INCORRECT') {
      // You could split this into "Silly Mistake" (Fast) vs "Conceptual Error" (Slow)
      // For now, we group them as Learning Gap.
      return PerformanceQuadrant.learningGap;
    }

    if (status == 'CORRECT') {
      final int idealTime = customIdealTime ?? getIdealTime(subject);

      if (timeSpent <= idealTime) {
        return PerformanceQuadrant.mastery;
      } else {
        return PerformanceQuadrant.needsSpeed;
      }
    }

    return PerformanceQuadrant.unknown;
  }

  /// Helper to get a color for the UI later
  static int getColorHexForQuadrant(PerformanceQuadrant quadrant) {
    switch (quadrant) {
      case PerformanceQuadrant.mastery:
        return 0xFF4CAF50; // Green
      case PerformanceQuadrant.needsSpeed:
        return 0xFFFFC107; // Amber/Yellow
      case PerformanceQuadrant.learningGap:
        return 0xFFF44336; // Red
      case PerformanceQuadrant.skipped:
        return 0xFF9E9E9E; // Grey
      default:
        return 0xFF000000;
    }
  }
}

================================================================================
FILE: lib/widgets/expandable_image.dart
================================================================================
import 'package:flutter/material.dart';

class ExpandableImage extends StatelessWidget {
  final String imageUrl;

  const ExpandableImage({Key? key, required this.imageUrl}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (_) => Scaffold(
              backgroundColor: Colors.black,
              appBar: AppBar(
                backgroundColor: Colors.transparent,
                elevation: 0,
                iconTheme: const IconThemeData(color: Colors.white),
              ),
              body: Center(
                // This widget allows pinch-to-zoom
                child: InteractiveViewer(
                  panEnabled: true,
                  minScale: 0.5,
                  maxScale: 4.0,
                  child: Image.network(imageUrl), // Switch to Image.asset if local
                ),
              ),
            ),
          ),
        );
      },
      child: Image.network(imageUrl), // The thumbnail view in the question
    );
  }
}

================================================================================
FILE: lib/widgets/question_input_widget.dart
================================================================================
import 'package:flutter/material.dart';
import '../models/question_model.dart';

class QuestionInputWidget extends StatefulWidget {
  final Question question;
  final dynamic currentAnswer;
  final Function(dynamic) onAnswerChanged;

  const QuestionInputWidget({
    Key? key,
    required this.question,
    required this.currentAnswer,
    required this.onAnswerChanged,
  }) : super(key: key);

  @override
  State<QuestionInputWidget> createState() => _QuestionInputWidgetState();
}

class _QuestionInputWidgetState extends State<QuestionInputWidget> {
  late TextEditingController _textController;

  @override
  void initState() {
    super.initState();
    _textController = TextEditingController();
  }

  @override
  void didUpdateWidget(QuestionInputWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Refresh text field if the question changes or answer is externally reset
    if (widget.question.id != oldWidget.question.id || widget.currentAnswer == null) {
      _textController.text = widget.currentAnswer?.toString() ?? '';
    }
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    switch (widget.question.type) {
      case QuestionType.singleCorrect:
        return _buildSingleCorrectUI();
      case QuestionType.numerical:
        return _buildNumericalUI();
      case QuestionType.multipleCorrect:
        return _buildMultiCorrectUI();
      case QuestionType.matrixSingle:
      case QuestionType.matrixMulti:
        return _buildMatrixUI();
      default:
        return const Center(child: Text("Unknown Question Type"));
    }
  }

  // =========================================================
  // TYPE 1: SINGLE CORRECT (Radio Tiles)
  // =========================================================
  Widget _buildSingleCorrectUI() {
    final options = ['A', 'B', 'C', 'D'];
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: options.map((option) {
        final isSelected = widget.currentAnswer == option;
        return Expanded(
          child: GestureDetector(
            onTap: () => widget.onAnswerChanged(option),
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 4),
              padding: const EdgeInsets.symmetric(vertical: 16),
              decoration: BoxDecoration(
                color: isSelected ? Colors.blue : Colors.white,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                    color: isSelected ? Colors.blue : Colors.grey.shade300
                ),
              ),
              child: Center(
                child: Text(
                  option,
                  style: TextStyle(
                    color: isSelected ? Colors.white : Colors.black,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
        );
      }).toList(),
    );
  }

  // =========================================================
  // TYPE 2: NUMERICAL (Text Field)
  // =========================================================
  Widget _buildNumericalUI() {
    return TextField(
      controller: _textController,
      keyboardType: const TextInputType.numberWithOptions(decimal: true),
      decoration: const InputDecoration(
        border: OutlineInputBorder(),
        hintText: 'Enter numerical answer (e.g. 5.5)',
      ),
      onChanged: (val) => widget.onAnswerChanged(val),
    );
  }

  // =========================================================
  // TYPE 3: MULTIPLE CORRECT (Checkboxes)
  // =========================================================
  Widget _buildMultiCorrectUI() {
    final options = ['A', 'B', 'C', 'D'];
    final List<dynamic> currentSelection = (widget.currentAnswer is List)
        ? widget.currentAnswer
        : [];

    return Row(
      children: options.map((option) {
        final isSelected = currentSelection.contains(option);
        return Expanded(
          child: GestureDetector(
            onTap: () {
              List<dynamic> newSel = List.from(currentSelection);
              if (isSelected) {
                newSel.remove(option);
              } else {
                newSel.add(option);
              }
              widget.onAnswerChanged(newSel);
            },
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 4),
              padding: const EdgeInsets.symmetric(vertical: 16),
              decoration: BoxDecoration(
                color: isSelected ? Colors.green.shade100 : Colors.white,
                borderRadius: BorderRadius.circular(4),
                border: Border.all(
                    color: isSelected ? Colors.green : Colors.grey.shade300,
                    width: 2
                ),
              ),
              child: Center(child: Text(option)),
            ),
          ),
        );
      }).toList(),
    );
  }

  // =========================================================
  // TYPE 4: MATRIX MATCH (The Grid)
  // =========================================================
  Widget _buildMatrixUI() {
    // Standard JEE Matrix setup
    final rows = ['A', 'B', 'C', 'D'];
    final cols = ['P', 'Q', 'R', 'S', 'T'];

    // Safe Cast: Ensure answer is a Map. If null/wrong type, start empty.
    Map<String, List<String>> matrixAns = {};
    if (widget.currentAnswer is Map) {
      (widget.currentAnswer as Map).forEach((key, value) {
        if (value is List) {
          matrixAns[key.toString()] = List<String>.from(value);
        }
      });
    }

    return Column(
      children: [
        // 1. Header Row (Labels P, Q, R, S, T)
        Row(
          children: [
            const SizedBox(width: 40), // Empty space for row labels column
            ...cols.map((col) => Expanded(
              child: Center(
                child: Text(col, style: const TextStyle(fontWeight: FontWeight.bold)),
              ),
            )),
          ],
        ),
        const Divider(),

        // 2. The Data Rows (A, B, C, D)
        ...rows.map((rowLabel) {
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: Row(
              children: [
                // Row Label
                SizedBox(
                  width: 40,
                  child: Center(
                    child: Text(
                      rowLabel,
                      style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                    ),
                  ),
                ),

                // The Interactive Bubbles
                ...cols.map((colLabel) {
                  final rowSelections = matrixAns[rowLabel] ?? [];
                  final isSelected = rowSelections.contains(colLabel);

                  return Expanded(
                    child: GestureDetector(
                      onTap: () {
                        // Create a copy of the current row's selection to modify
                        List<String> newRowSel = List.from(rowSelections);

                        if (widget.question.type == QuestionType.matrixSingle) {
                          // LOGIC: Single Matrix (One choice per row)
                          newRowSel.clear();
                          if (!isSelected) {
                            newRowSel.add(colLabel);
                          }
                        } else {
                          // LOGIC: Multi Matrix (Multiple choices per row)
                          if (isSelected) {
                            newRowSel.remove(colLabel);
                          } else {
                            newRowSel.add(colLabel);
                          }
                        }

                        // Update the Main Map
                        Map<String, List<String>> newMatrixAns = Map.from(matrixAns);
                        newMatrixAns[rowLabel] = newRowSel;

                        // Send back to Controller
                        widget.onAnswerChanged(newMatrixAns);
                      },
                      child: Container(
                        height: 36, // Tap target size
                        margin: const EdgeInsets.all(2),
                        decoration: BoxDecoration(
                          color: isSelected ? Colors.deepPurple : Colors.grey.shade100,
                          shape: BoxShape.circle,
                          border: Border.all(
                              color: isSelected ? Colors.deepPurple : Colors.grey.shade400
                          ),
                        ),
                        child: isSelected
                            ? const Icon(Icons.check, size: 20, color: Colors.white)
                            : null,
                      ),
                    ),
                  );
                }),
              ],
            ),
          );
        }).toList(),
      ],
    );
  }
}

================================================================================
FILE: lib/widgets/question_palette.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';

class QuestionPalette extends StatelessWidget {
  final int questionCount;
  final Map<int, AnswerState> answerStates;
  final int currentQuestionIndex;
  final Function(int) onQuestionTapped;

  const QuestionPalette({
    super.key,
    required this.questionCount,
    required this.answerStates,
    required this.currentQuestionIndex,
    required this.onQuestionTapped,
  });

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      itemCount: questionCount,
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 5,
        crossAxisSpacing: 8,
        mainAxisSpacing: 8,
      ),
      itemBuilder: (context, index) {
        final state = answerStates[index] ?? AnswerState();
        final isCurrent = index == currentQuestionIndex;

        return GestureDetector(
          onTap: () => onQuestionTapped(index),
          child: Container(
            decoration: BoxDecoration(
              color: state.status.color,
              borderRadius: BorderRadius.circular(4),
              border: isCurrent ? Border.all(color: Colors.black, width: 2) : null,
            ),
            child: Center(
              child: Text(
                '${index + 1}',
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


================================================================================
FILE: lib/widgets/solution_detail_sheet.dart
================================================================================
// lib/widgets/solution_detail_sheet.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/nta_test_models.dart';
import 'package:study_smart_qc/models/test_result.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';
import 'package:study_smart_qc/widgets/expandable_image.dart';

class SolutionDetailSheet extends StatefulWidget {
  final TestResult result;
  final int initialIndex;
  const SolutionDetailSheet({
    super.key,
    required this.result,
    required this.initialIndex,
  });
  @override
  State<SolutionDetailSheet> createState() => _SolutionDetailSheetState();
}

class _SolutionDetailSheetState extends State<SolutionDetailSheet> {
  late final PageController _pageController;
  int _currentIndex = 0;

  @override
  void initState() {
    super.initState();
    _currentIndex = widget.initialIndex;
    _pageController = PageController(initialPage: _currentIndex);
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  String _formatDuration(int seconds) {
    if (seconds < 60) return '${seconds}s';
    final m = seconds ~/ 60;
    final s = seconds % 60;
    return '${m}m ${s}s';
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // --- HEADER ---
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: const Icon(Icons.arrow_back_ios),
                onPressed: _currentIndex > 0
                    ? () => _pageController.previousPage(
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeIn,
                )
                    : null,
              ),
              Text(
                'Solution ${_currentIndex + 1} / ${widget.result.questions.length}',
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.arrow_forward_ios),
                onPressed: _currentIndex < widget.result.questions.length - 1
                    ? () => _pageController.nextPage(
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeIn,
                )
                    : null,
              ),
            ],
          ),
        ),
        const Divider(height: 1),

        // --- BODY ---
        Expanded(
          child: PageView.builder(
            controller: _pageController,
            itemCount: widget.result.questions.length,
            onPageChanged: (index) => setState(() => _currentIndex = index),
            itemBuilder: (context, index) {
              final question = widget.result.questions[index];
              final answerState = widget.result.answerStates[index]!;
              final isCorrect = answerState.userAnswer?.trim().toLowerCase() ==
                  question.correctAnswer.trim().toLowerCase();

              final responseObj = widget.result.responses[question.id];
              final timeSpentSec = responseObj?.timeSpent ?? 0;

              return SingleChildScrollView(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // 1. Question Text
                    Text(
                      'Question ${index + 1}',
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 10),

                    // 2. Question Image
                    if (question.imageUrl.isNotEmpty)
                      Center(
                        child: Container(
                          constraints: const BoxConstraints(maxHeight: 250),
                          child: ExpandableImage(imageUrl: question.imageUrl),
                        ),
                      ),
                    const SizedBox(height: 20),

                    // 3. Time Spent
                    Container(
                      margin: const EdgeInsets.only(bottom: 12),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 10, vertical: 6),
                      decoration: BoxDecoration(
                        color: Colors.blue.shade50,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(color: Colors.blue.shade100),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.timer, size: 16, color: Colors.blue),
                          const SizedBox(width: 8),
                          const Text("Time Spent: ",
                              style: TextStyle(
                                  fontSize: 14, color: Colors.black54)),
                          Text(
                            _formatDuration(timeSpentSec),
                            style: TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                                color: Colors.blue.shade900),
                          ),
                        ],
                      ),
                    ),

                    // 4. Your Answer
                    _buildAnswerStatus(
                      'Your Answer: ${answerState.userAnswer ?? "Not Answered"}',
                      isCorrect,
                      answerState.status,
                    ),
                    const SizedBox(height: 8),

                    // 5. Correct Answer
                    _buildAnswerStatus(
                      'Correct Answer: ${question.correctAnswer}',
                      true,
                      AnswerStatus.answered,
                    ),
                    const SizedBox(height: 20),

                    // --- MOVED: Mistake Analysis Section (Step 2) ---
                    if (responseObj?.status == 'INCORRECT') ...[
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade100),
                        ),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Self Analysis',
                              style: TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                                color: Colors.red[800],
                              ),
                            ),
                            const SizedBox(height: 8),
                            _MistakeForm(
                              attemptId: widget.result.attemptId,
                              questionId: question.id,
                              initialCategory: responseObj?.mistakeCategory,
                              initialNote: responseObj?.mistakeNote,
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 20),
                    ],

                    const Divider(),
                    const SizedBox(height: 10),

                    // 6. Solution Image
                    if (question.solutionUrl != null &&
                        question.solutionUrl!.isNotEmpty)
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'Solution',
                            style: TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const SizedBox(height: 10),
                          Center(
                            child: Container(
                              constraints: const BoxConstraints(maxHeight: 300),
                              child: ExpandableImage(
                                  imageUrl: question.solutionUrl!),
                            ),
                          ),
                        ],
                      )
                    else
                      const Text("No detailed solution available.",
                          style: TextStyle(
                              fontStyle: FontStyle.italic, color: Colors.grey)),

                    const SizedBox(height: 40),
                  ],
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildAnswerStatus(String text, bool isCorrect, AnswerStatus status) {
    Color color = Colors.grey;
    IconData icon = Icons.help_outline;

    if (status == AnswerStatus.notAnswered ||
        status == AnswerStatus.notVisited) {
      color = Colors.orange;
      icon = Icons.warning_amber_rounded;
    } else if (status == AnswerStatus.answered ||
        status == AnswerStatus.answeredAndMarked) {
      color = isCorrect ? Colors.green : Colors.red;
      icon = isCorrect ? Icons.check_circle : Icons.cancel;
    }

    return Row(
      children: [
        Icon(icon, color: color, size: 20),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            text,
            style: TextStyle(color: color, fontWeight: FontWeight.bold),
          ),
        ),
      ],
    );
  }
}

// =============================================================================
// INTERNAL WIDGET: Mistake Form (Refined)
// =============================================================================
class _MistakeForm extends StatefulWidget {
  final String attemptId;
  final String questionId;
  final String? initialCategory;
  final String? initialNote;

  const _MistakeForm({
    required this.attemptId,
    required this.questionId,
    this.initialCategory,
    this.initialNote,
  });

  @override
  State<_MistakeForm> createState() => _MistakeFormState();
}

class _MistakeFormState extends State<_MistakeForm> {
  final TestOrchestrationService _service = TestOrchestrationService();
  final TextEditingController _noteController = TextEditingController();
  String? _selectedCategory;

  // REMOVED 'Other' (Step 1)
  final List<String> _categories = [
    'Conceptual Error',
    'Calculation Error',
    'Silly Mistake',
    'Time Pressure',
    'Did not understand question',
    'Guessed',
  ];

  @override
  void initState() {
    super.initState();
    _selectedCategory = widget.initialCategory;
    _noteController.text = widget.initialNote ?? '';
  }

  @override
  void dispose() {
    _noteController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          value: _categories.contains(_selectedCategory)
              ? _selectedCategory
              : null,
          hint: const Text("Why did you get this wrong?"),
          isExpanded: true,
          decoration: InputDecoration(
            contentPadding:
            const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
            filled: true,
            fillColor: Colors.white,
          ),
          items: _categories.map((cat) {
            return DropdownMenuItem(
              value: cat,
              child: Text(cat, style: const TextStyle(fontSize: 14)),
            );
          }).toList(),
          onChanged: (value) {
            setState(() {
              _selectedCategory = value;
            });
            // Update Service with Note (even if empty, passed as '')
            _service.updateQuestionMistake(
              attemptId: widget.attemptId,
              questionId: widget.questionId,
              mistakeCategory: value ?? '',
              mistakeNote: _noteController.text, // Passed directly, 'Other' field removed
            );
          },
        ),
      ],
    );
  }
}

================================================================================
FILE: lib/widgets/student_lookup_sheet.dart
================================================================================
// lib/widgets/student_lookup_sheet.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:study_smart_qc/features/analytics/screens/analysis_screen.dart';

class StudentLookupSheet extends StatefulWidget {
  const StudentLookupSheet({super.key});

  @override
  State<StudentLookupSheet> createState() => _StudentLookupSheetState();
}

class _StudentLookupSheetState extends State<StudentLookupSheet> {
  final TextEditingController _idController = TextEditingController();
  bool _isLoading = false;
  String? _error;

  Future<void> _findAndOpenStudent() async {
    final idStr = _idController.text.trim();
    if (idStr.isEmpty) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final int studentId = int.parse(idStr);

      // Query Firestore: Find user where 'studentId' == the number entered
      final query = await FirebaseFirestore.instance
          .collection('users')
          .where('studentId', isEqualTo: studentId)
          .limit(1)
          .get();

      if (query.docs.isEmpty) {
        setState(() => _error = "Student ID $studentId not found.");
      } else {
        final uid = query.docs.first.id;
        final data = query.docs.first.data();
        final name = data['displayName'] ?? "Student";

        if (mounted) {
          Navigator.pop(context); // Close the bottom sheet

          // Open Analysis Screen with the found UID
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => AnalysisScreen(targetStudentUid: uid),
            ),
          );

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text("Viewing reports for $name")),
          );
        }
      }
    } catch (e) {
      setState(() => _error = "Invalid ID format or Network Error");
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      // Handle keyboard covering the field
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
        left: 20,
        right: 20,
        top: 20,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            "Inspect Student Performance",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          const Text(
            "Enter the unique Student ID to view their full analytics.",
            style: TextStyle(color: Colors.grey, fontSize: 13),
          ),
          const SizedBox(height: 15),
          TextField(
            controller: _idController,
            keyboardType: TextInputType.number,
            autofocus: true,
            decoration: InputDecoration(
              labelText: "Enter Student ID (e.g. 10)",
              border: const OutlineInputBorder(),
              errorText: _error,
              prefixIcon: const Icon(Icons.person_search),
            ),
          ),
          const SizedBox(height: 20),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: _isLoading ? null : _findAndOpenStudent,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.deepPurple,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 14),
              ),
              child: _isLoading
                  ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                  : const Text("View Reports"),
            ),
          ),
          const SizedBox(height: 20),
        ],
      ),
    );
  }
}

================================================================================
FILE: lib/widgets/test_configuration_bottom_sheet.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:study_smart_qc/models/question_model.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_preview_screen.dart';
import 'package:study_smart_qc/services/test_service.dart';

class TestConfigurationBottomSheet extends StatefulWidget {
  final Set<String> chapterIds;
  final Map<String, String> chapterIdToNameMap;
  final Set<String> topicIds;
  final Map<String, String> topicIdToNameMap;
  final Map<String, Map<String, String>> chapterIdToTopicsMap;

  const TestConfigurationBottomSheet({
    super.key,
    required this.chapterIds,
    required this.topicIds,
    required this.chapterIdToNameMap,
    required this.topicIdToNameMap,
    required this.chapterIdToTopicsMap, // FIX: Added required parameter
  });

  @override
  State<TestConfigurationBottomSheet> createState() =>
      _TestConfigurationBottomSheetState();
}

class _TestConfigurationBottomSheetState
    extends State<TestConfigurationBottomSheet> {
  int _selectedQuestionCount = 15;
  late int _timeInMinutes;
  final List<int> _questionCountOptions = [10, 15, 20, 30];
  bool _isCustom = false;
  final TextEditingController _customCountController = TextEditingController();
  late final TextEditingController _testNameController;
  bool _isGeneratingTest = false;

  @override
  void initState() {
    super.initState();
    _timeInMinutes = _selectedQuestionCount * 2;
    _customCountController.text = '45';
    final defaultChapterName = widget.chapterIds.isNotEmpty
        ? widget.chapterIdToNameMap[widget.chapterIds.first]
        : 'Custom';
    _testNameController = TextEditingController(
      text: 'P - $defaultChapterName Test',
    );
  }

  @override
  void dispose() {
    _customCountController.dispose();
    _testNameController.dispose();
    super.dispose();
  }

  void _updateQuestionCount(int? count) {
    setState(() {
      _isCustom = count == null;
      if (!_isCustom) {
        _selectedQuestionCount = count!;
      } else {
        _selectedQuestionCount =
            int.tryParse(_customCountController.text) ?? 45;
      }
      _timeInMinutes = _selectedQuestionCount * 2;
    });
  }

  void _onCustomCountChanged(String value) {
    setState(() {
      _selectedQuestionCount = int.tryParse(value) ?? _selectedQuestionCount;
      _timeInMinutes = _selectedQuestionCount * 2;
    });
  }

  void _adjustTime(int delta) {
    setState(() {
      _timeInMinutes = (_timeInMinutes + delta).clamp(5, 180);
    });
  }

  Future<void> _generateAndPreviewTest() async {
    setState(() => _isGeneratingTest = true);

    final service = TestService();
    final questions = await service.generateTest(
      chapterIds: widget.chapterIds,
      topicIds: widget.topicIds,
      questionCount: _selectedQuestionCount,
    );

    if (!mounted) return;
    setState(() => _isGeneratingTest = false);

    if (questions.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No questions found for the selected topics.'),
          backgroundColor: Colors.red,
        ),
      );
      Navigator.pop(context);
      return;
    }

    final Map<String, List<String>> selectedSyllabus = {};
    for (String chapId in widget.chapterIds) {
      final chapterName = widget.chapterIdToNameMap[chapId]!;
      final List<String> selectedTopicsInChapter = [];

      final questionTopicIdsForThisChapter = questions
          .where((q) => q.chapterId == chapId)
          .map((q) => q.topicId)
          .toSet();

      for (var topicId in questionTopicIdsForThisChapter) {
        final topicName = widget.topicIdToNameMap[topicId];
        if (topicName != null && !selectedTopicsInChapter.contains(topicName)) {
          selectedTopicsInChapter.add(topicName);
        }
      }

      if (selectedTopicsInChapter.isNotEmpty) {
        selectedSyllabus[chapterName] = selectedTopicsInChapter;
      }
    }

    Navigator.pop(context);
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TestPreviewScreen(
          questions: questions,
          timeLimitInMinutes: _timeInMinutes,
          selectedSyllabus: selectedSyllabus,
          testName: _testNameController.text,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      child: Container(
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Configure Your Test',
              style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            TextField(
              controller: _testNameController,
              decoration: const InputDecoration(
                labelText: 'Test Name',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 20),
            const Text(
              'Number of Questions:',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 10),
            Wrap(
              spacing: 10,
              children: [
                ..._questionCountOptions.map((count) {
                  return ChoiceChip(
                    label: Text('$count'),
                    selected: !_isCustom && _selectedQuestionCount == count,
                    onSelected: (_) => _updateQuestionCount(count),
                  );
                }).toList(),
                ChoiceChip(
                  label: const Text('Custom'),
                  selected: _isCustom,
                  onSelected: (_) => _updateQuestionCount(null),
                ),
              ],
            ),
            if (_isCustom)
              Padding(
                padding: const EdgeInsets.only(top: 10.0),
                child: TextField(
                  controller: _customCountController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                    labelText: 'Enter number of questions',
                    border: OutlineInputBorder(),
                  ),
                  onChanged: _onCustomCountChanged,
                ),
              ),
            const SizedBox(height: 20),
            const Text(
              'Time Limit:',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 10),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  icon: const Icon(Icons.remove_circle_outline),
                  onPressed: () => _adjustTime(-5),
                ),
                Text(
                  '$_timeInMinutes mins',
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.add_circle_outline),
                  onPressed: () => _adjustTime(5),
                ),
              ],
            ),
            const SizedBox(height: 20),
            SizedBox(
              width: double.infinity,
              child: _isGeneratingTest
                  ? const Center(child: CircularProgressIndicator())
                  : ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurple,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 16),
                      ),
                      onPressed: _generateAndPreviewTest,
                      child: const Text(
                        'Generate Test',
                        style: TextStyle(fontSize: 18),
                      ),
                    ),
            ),
          ],
        ),
      ),
    );
  }
}


================================================================================
FILE: lib/widgets/timer_hms.dart
================================================================================
import 'package:flutter/material.dart';

class Timer_HMS extends StatelessWidget {
  final Duration duration;
  final TextStyle? style;
  final TextAlign? textAlign;

  const Timer_HMS({
    super.key,
    required this.duration,
    this.style,
    this.textAlign,
  });

  @override
  Widget build(BuildContext context) {
    String twoDigits(int n) => n.toString().padLeft(2, "0");

    final int hours = duration.inHours;
    final int minutes = duration.inMinutes.remainder(60);
    final int seconds = duration.inSeconds.remainder(60);

    String formattedTime;

    if (hours > 0) {
      // Format: HH:MM:SS
      formattedTime = "${twoDigits(hours)}:${twoDigits(minutes)}:${twoDigits(seconds)}";
    } else {
      // Format: MM:SS (Hours are hidden)
      formattedTime = "${twoDigits(minutes)}:${twoDigits(seconds)}";
    }

    return Text(
      formattedTime,
      style: style,
      textAlign: textAlign,
    );
  }
}

