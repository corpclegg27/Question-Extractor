



Follow our standard operating procedure. 

1. First identify the relevant files which needs to be modified / created

2. Break the problem into steps

3. Ask for the current code for the file if you need (no guessing please, better safe than sorry), i will provide you

4. then step by step, give me the complete updated codes for the file (not partial)

5. Don't change variable names randomly and keep consistency

6. Dont break things please

7. At start of file, add full file path (e.g, // lib/features/student/widgets/student_assignments_list.dart) and 2-3 line description



// lib/features/student/widgets/student_assignments_list.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

// MODELS & SERVICES
import 'package:study_smart_qc/models/test_enums.dart';
import 'package:study_smart_qc/services/test_orchestration_service.dart';

// WIDGETS & SCREENS
import 'package:study_smart_qc/features/student/widgets/student_curation_preview_card.dart';
import 'package:study_smart_qc/features/test_taking/screens/test_screen.dart';

class StudentAssignmentsList extends StatelessWidget {
  final List<QueryDocumentSnapshot> documents;
  final String? resumableAssignmentCode;
  final Future<void> Function() onResumeTap;
  final VoidCallback onViewAnalysisTap;
  final bool isHistoryMode;

  const StudentAssignmentsList({
    super.key,
    required this.documents,
    required this.resumableAssignmentCode,
    required this.onResumeTap,
    required this.onViewAnalysisTap,
    this.isHistoryMode = false,
  });

  @override
  Widget build(BuildContext context) {
    if (documents.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.assignment_turned_in_outlined,
                size: 64, color: Colors.grey.shade300),
            const SizedBox(height: 16),
            Text(
              isHistoryMode
                  ? "No completed assignments yet."
                  : "No pending assignments!",
              style: TextStyle(color: Colors.grey.shade500),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: documents.length,
      itemBuilder: (context, index) {
        final doc = documents[index];
        final data = doc.data() as Map<String, dynamic>;

        final String assignmentCode = data['assignmentCode'] ?? '';
        final bool isStrict = data['onlySingleAttempt'] ?? false;
        final bool isResumable = (assignmentCode == resumableAssignmentCode);

        return StudentCurationPreviewCard(
          snapshot: doc, // CHANGED: Pass full snapshot
          isResumable: isResumable,
          isSubmitted: isHistoryMode,
          isStrict: isStrict,
          onTap: () {
            if (isResumable) {
              onResumeTap();
            } else if (isHistoryMode) {
              onViewAnalysisTap();
            } else {
              _startNewTest(context, doc.id, data);
            }
          },
        );
      },
    );
  }

  Future<void> _startNewTest(
      BuildContext context, String docId, Map<String, dynamic> data) async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final List<dynamic> rawIds = data['questionIds'] ?? [];
      final List<String> qIds = rawIds.cast<String>();

      if (qIds.isEmpty) throw Exception("No questions in this assignment.");

      final questions = await TestOrchestrationService().getQuestionsByIds(qIds);

      if (context.mounted) {
        Navigator.pop(context);
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (_) => TestScreen(
              sourceId: docId,
              assignmentCode: data['assignmentCode'],
              questions: questions,
              timeLimitInMinutes: data['timeLimitMinutes'] ?? 0,
              testMode: (data['onlySingleAttempt'] ?? false)
                  ? TestMode.test
                  : TestMode.practice,
              resumedTimerSeconds: null,
              resumedPageIndex: 0,
              resumedResponses: const {},
              title: data['title'] ?? 'Assignment',
              onlySingleAttempt: data['onlySingleAttempt'] ?? false,
            ),
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Error starting test: $e")),
        );
      }
    }
  }
}